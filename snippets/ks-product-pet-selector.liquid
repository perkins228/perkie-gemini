{% comment %}
  Pet Selector for Product Pages - V5 Integration
  Displays saved pet images from pet processor and enables cart integration
  Only shows for products with "custom" tag
{% endcomment %}

{% assign has_custom_tag = false %}
{% for tag in product.tags %}
  {% if tag contains 'custom' or tag contains 'Custom' or tag contains 'CUSTOM' %}
    {% assign has_custom_tag = true %}
    {% break %}
  {% endif %}
{% endfor %}

{% comment %} Get block settings {% endcomment %}
{% assign pet_selector_block = section.blocks | where: 'type', 'ks_pet_selector' | first %}
{% assign custom_image_fee = 0 %}
{% assign preview_product_variant_id = '' %}

{% comment %} Get max pets from product metafield with intelligent defaults {% endcomment %}
{% assign max_pets_from_metafield = product.metafields.custom.max_pets | default: nil %}

{% comment %} Set default to 1 pet for all products {% endcomment %}
{% assign default_max_pets = 1 %}

{% comment %} Determine final max_pets value with fallback chain {% endcomment %}
{% if max_pets_from_metafield %}
  {% assign max_pets_per_product = max_pets_from_metafield | plus: 0 %}
{% elsif pet_selector_block and pet_selector_block.settings.max_pets_per_product %}
  {% assign max_pets_per_product = pet_selector_block.settings.max_pets_per_product %}
{% else %}
  {% assign max_pets_per_product = default_max_pets %}
{% endif %}

{% comment %} Ensure max_pets is within valid range (1-10) {% endcomment %}
{% if max_pets_per_product < 1 %}
  {% assign max_pets_per_product = 1 %}
{% elsif max_pets_per_product > 10 %}
  {% assign max_pets_per_product = 10 %}
{% endif %}

{% if pet_selector_block %}
  {% if pet_selector_block.settings.custom_image_fee %}
    {% assign custom_image_fee = pet_selector_block.settings.custom_image_fee %}
  {% endif %}
  {% if pet_selector_block.settings.preview_product_variant_id %}
    {% assign preview_product_variant_id = pet_selector_block.settings.preview_product_variant_id %}
  {% endif %}
{% endif %}

{% if has_custom_tag %}
  <div class="ks-pet-selector" 
       id="pet-selector-{{ section.id }}"
       data-section-id="{{ section.id }}"
       data-custom-image-fee="{{ custom_image_fee }}"
       data-max-pets="{{ max_pets_per_product }}"
       data-preview-variant-id="{{ preview_product_variant_id }}"
       data-product-id="{{ product.id }}"
       data-product-variant-id="{{ product.selected_or_first_available_variant.id }}"
       data-product-price="{{ product.price }}">
    
    <div class="ks-pet-selector__header" id="pet-selector-header-{{ section.id }}">
      <div class="ks-pet-selector__header-top">
        <h3 class="ks-pet-selector__title" id="pet-selector-title-{{ section.id }}">Your Pets</h3>
        <button type="button" 
                class="ks-pet-selector__edit-btn" 
                id="pet-edit-btn-{{ section.id }}"
                style="display: none;">
          Edit
        </button>
      </div>
      <p class="ks-pet-selector__description" 
         id="pet-selector-description-{{ section.id }}"
         style="display: none;">
        Choose from your saved pet images or
        <a href="/pages/custom-image-processing"
           class="ks-pet-selector__link">create a new one</a>
      </p>
    </div>

    {% comment %} Pet Name Input - Required for all scenarios {% endcomment %}
    <div class="ks-pet-selector__pet-name" data-pet-name-section>
      <label for="pet-name-input-{{ section.id }}">
        1. Pet Name(s) <span class="required" style="color: red;">*</span>
      </label>
      <input
        type="text"
        id="pet-name-input-{{ section.id }}"
        name="properties[_pet_name]"
        placeholder="e.g., Bella, Milo, Max"
        required
        maxlength="100"
        pattern="[A-Za-z0-9, \-']+"
        autocapitalize="words"
        aria-label="Enter your pet name(s)"
        aria-describedby="pet-name-help-{{ section.id }}"
        data-sanitize="true"
        style="width: 100%; padding: 12px; margin: 8px 0; border: 1px solid #ddd; border-radius: 4px; font-size: 16px;">
      <small id="pet-name-help-{{ section.id }}" class="form-help" style="display: block; color: #666; font-size: 1rem;">
        Separate multiple names with commas
      </small>
    </div>

    {% comment %} Upload Options - Consolidated Row Layout {% endcomment %}
    <div class="ks-pet-selector__pet-name" style="margin: 1rem 0 0 0;">
      <label>
        2. Upload your image(s)
      </label>
    </div>
    <div class="ks-pet-selector__upload-options"
         data-upload-options
         style="margin: 12px 0 6px 0; display: flex; flex-direction: row; gap: 8px; align-items: stretch;">

      {% comment %} Primary CTA: AI Preview Path (Scenario 1) - 58% width {% endcomment %}
      <a href="/pages/custom-image-processing"
         class="btn btn-primary"
         id="preview-cta-{{ section.id }}"
         data-preview-trigger
         style="flex: 0 0 58%; display: flex; align-items: center; justify-content: center; padding: 14px 8px; font-size: 15px; font-weight: 600; text-align: center; background: #4CAF50; color: white; border-radius: 6px; text-decoration: none; border: none; cursor: pointer; transition: background 0.2s; min-height: 48px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
        🎨 Upload & Preview
      </a>

      {% comment %} Secondary CTA: Quick Upload Path (Scenario 3) - 42% width {% endcomment %}
      <button type="button"
              class="btn btn-secondary"
              id="quick-upload-trigger-{{ section.id }}"
              data-quick-upload-trigger
              style="flex: 0 0 42%; display: flex; align-items: center; justify-content: center; padding: 14px 8px; font-size: 15px; font-weight: 500; background: #2196F3; color: white; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s; min-height: 48px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
        📸 Quick Upload
      </button>

      {% comment %} Hidden file input (triggered by Quick Upload button) {% endcomment %}
      <input type="file"
             id="quick-upload-input-{{ section.id }}"
             name="properties[_pet_image]"
             accept="image/*"
             {% if max_pets_per_product > 1 %}multiple{% endif %}
             data-max-files="{{ max_pets_per_product | default: 1 }}"
             data-quick-upload-input
             style="display: none;"
             aria-label="Upload pet photo(s)">
    </div>

    {% comment %} Returning Customer Form {% endcomment %}
    <div class="ks-pet-selector__returning-customer" style="margin: 8px 0;">
      <label class="checkbox-label" style="display: flex; align-items: center; cursor: pointer;">
        <input
          type="checkbox"
          id="is-repeat-customer-{{ section.id }}"
          name="properties[_is_repeat_customer]"
          value="true"
          data-returning-toggle
          style="margin-right: 8px;">
        <span>Use Existing Perkie Print</span>
      </label>

      <div id="repeat-customer-fields-{{ section.id }}" class="repeat-fields" style="display: none; margin-top: 12px;">
        <label for="previous-order-{{ section.id }}" style="display: block; margin-bottom: 4px; font-weight: 500;">
          Previous Order Number
        </label>
        <input
          type="text"
          id="previous-order-{{ section.id }}"
          name="properties[_previous_order_number]"
          placeholder="#1001"
          inputmode="numeric"
          pattern="[#]?[0-9]+"
          maxlength="10"
          style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 16px;">
        <small class="form-help" style="display: block; margin-top: 4px; color: #666; font-size: 14px;">
          Found in your order confirmation email
        </small>
      </div>
    </div>

    {% comment %} Upload progress indicator (hidden by default) {% endcomment %}
    <div id="upload-progress-{{ section.id }}"
         class="ks-upload-progress"
         style="display: none; margin: 16px 0; padding: 16px; background: #f5f5f5; border-radius: 6px;">
      <p class="ks-upload-progress__title" style="margin: 0 0 8px 0; font-weight: 500;">Your uploaded photos...</p>
      <div id="upload-status-{{ section.id }}"
           class="ks-upload-progress__status"
           style="font-size: 14px; color: #666;">
        No photos selected yet
      </div>
    </div>

    {% comment %} Hidden order type field {% endcomment %}
    <input type="hidden" name="properties[_order_type]" id="order-type-{{ section.id }}" value="standard">

    {% comment %} Hidden fields for express upload scenario {% endcomment %}
    <input type="hidden" name="properties[_processing_state]" id="processing-state-{{ section.id }}" value="">
    <input type="hidden" name="properties[_upload_timestamp]" id="upload-timestamp-{{ section.id }}" value="">

    <div class="ks-pet-selector__content" id="pet-selector-content-{{ section.id }}">
      <div class="ks-pet-selector__loading">
        <div class="ks-pet-selector__spinner"></div>
        <p>Loading your saved pets...</p>
      </div>
    </div>
    
    <div class="ks-pet-selector__selected-info" id="pet-selector-selected-{{ section.id }}" style="display: none;">
      <div class="ks-pet-selector__selected-pet">
        <div class="ks-pet-selector__selected-icon">✅</div>
        <div class="ks-pet-selector__selected-text">
          <strong id="selected-pet-name-{{ section.id }}">Pet Selected</strong>
          <small>Custom image will be added to cart</small>
        </div>
      </div>
      <!-- Multi-pet pricing display (dynamically updated via JavaScript) -->
      <div class="ks-pet-selector__price-info" id="pet-pricing-{{ section.id }}" style="display: none;">
        <span class="ks-pet-selector__base-price">Product: <span id="base-price-{{ section.id }}">{{ product.price | money }}</span></span>
        <span class="ks-pet-selector__custom-fee" id="pet-fee-display-{{ section.id }}" style="display: none;"></span>
        <span class="ks-pet-selector__total">Total: <span id="total-price-{{ section.id }}"></span></span>
      </div>
    </div>
  </div>

  <style>
    .ks-pet-selector {
      background: #f8f9fa;
      border: 2px solid #e9ecef;
      border-radius: 12px;
      padding: 1.5rem;
      margin: 1rem 0;
      font-family: inherit;
    }
    
    .ks-pet-selector__header {
      margin-bottom: 0.5rem; /* Reduced from 1rem to save space */
    }
    
    .ks-pet-selector__header-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    /* Title group wrapper for visual unity */
    .ks-pet-selector__title-group {
      display: flex;
      align-items: baseline; /* Align text baselines for perfect integration */
      gap: 0.125rem; /* 2px minimal spacing */
      flex-shrink: 0; /* Prevent shrinking on mobile */
    }
    
    .ks-pet-selector__title {
      font-size: 1.25rem;
      font-weight: 600;
      margin: 0;
      color: #333;
      line-height: 1.2; /* Consistent line height */
    }
    
    /* Legacy counter - hidden in favor of inline counter */
    .ks-pet-selector__counter {
      display: none;
    }

    /* New inline compact counter for mobile optimization - text only */
    .ks-pet-selector__counter-inline {
      display: inline-flex;
      align-items: baseline;
      margin: 0; /* No margins - gap handled by title group */
    }

    .ks-pet-selector__counter-inline .counter-text {
      font-size: 1.25rem;  /* Same as title */
      color: #666;  /* Slightly lighter for hierarchy */
      font-weight: 600;  /* Same as title */
      white-space: nowrap;
      line-height: 1.2; /* Match title line height */
    }

    /* Mobile-specific optimizations */
    @media (max-width: 750px) {
      .ks-pet-selector__header-top {
        align-items: center;
        justify-content: space-between;
      }

      .ks-pet-selector__title-group {
        gap: 0.0625rem; /* 1px on mobile */
      }

      .ks-pet-selector__counter-inline .counter-text {
        font-size: 1.1rem;
      }
    }

    /* Very small screens */
    @media (max-width: 400px) {
      .ks-pet-selector__title-group {
        gap: 0; /* No gap on very small screens */
      }

      .ks-pet-selector__counter-inline .counter-text {
        font-size: 1rem;
      }
    }

    /* Ultra small screens - hide counter entirely if needed */
    @media (max-width: 320px) {
      .ks-pet-selector__counter-inline {
        display: none;
      }
    }

    /* Auto-selection confirmation banner */
    .ks-pet-auto-confirm {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      padding: 12px 16px;
      margin: 12px 0;
      border-radius: 8px;
      animation: slideInConfirm 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    @keyframes slideInConfirm {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .auto-confirm-content {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .auto-confirm-icon {
      font-size: 20px;
      flex-shrink: 0;
    }

    .auto-confirm-text {
      flex: 1;
      font-size: 14px;
      min-width: 0;
    }

    .auto-confirm-text strong {
      font-weight: 600;
      color: white;
    }

    .auto-confirm-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }

    .auto-confirm-change {
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 6px 14px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease;
      white-space: nowrap;
      flex-shrink: 0;
      min-height: 44px;
    }

    .auto-confirm-change:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .auto-confirm-change:active {
      transform: scale(0.95);
    }

    .auto-confirm-dismiss {
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 18px;
      font-weight: 700;
      cursor: pointer;
      transition: background 0.2s ease;
      line-height: 1;
      min-width: 44px;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .auto-confirm-dismiss:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .auto-confirm-dismiss:active {
      transform: scale(0.95);
    }

    /* Mobile optimizations for confirmation banner */
    @media (max-width: 750px) {
      .ks-pet-auto-confirm {
        margin: 12px -16px;
        border-radius: 0;
        position: sticky;
        top: 60px;
        z-index: 90;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .auto-confirm-content {
        justify-content: space-between;
      }

      .auto-confirm-change,
      .auto-confirm-dismiss {
        min-height: 44px;
      }
    }

    /* Very small screens - stack vertically */
    @media (max-width: 400px) {
      .auto-confirm-content {
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
      }

      .auto-confirm-text {
        text-align: center;
      }

      .auto-confirm-actions {
        width: 100%;
        justify-content: space-between;
      }

      .auto-confirm-change {
        flex: 1;
      }
    }

    .ks-pet-selector__edit-btn {
      background: none;
      border: 1px solid #dc3545;
      color: #dc3545;
      padding: 6px 16px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 44px;
      min-width: 60px;
      margin-left: auto; /* Push to right edge */
      flex-shrink: 0; /* Never shrink */
    }
    
    .ks-pet-selector__edit-btn:hover {
      background: #dc3545;
      color: white;
    }
    
    .ks-pet-selector__edit-btn.edit-mode {
      background: #dc3545;
      color: white;
    }
    
    .ks-pet-selector__description {
      margin: 0;
      color: #666;
      font-size: 0.875rem;
    }
    
    .ks-pet-selector__link {
      color: #007bff;
      text-decoration: none;
      font-weight: 500;
    }
    
    .ks-pet-selector__link:hover {
      text-decoration: underline;
    }
    
    .ks-pet-selector__loading {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 1rem;
      color: #666;
    }
    
    .ks-pet-selector__spinner {
      width: 20px;
      height: 20px;
      border: 2px solid #e9ecef;
      border-top: 2px solid #007bff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .ks-pet-selector__pets {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
      gap: 1rem;
      margin: 1rem 0;
    }
    
    .ks-pet-selector__pet {
      position: relative;
      border: 3px solid #e9ecef;
      border-radius: 8px;
      overflow: visible; /* Changed to allow delete button visibility */
      cursor: pointer;
      transition: all 0.2s ease;
      background: white;
    }
    
    .ks-pet-selector__pet:hover {
      border-color: #007bff;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,123,255,0.15);
    }
    
    /* Delete button hover states for desktop - only show in edit mode */
    @media (hover: hover) {
      .ks-pet-selector.edit-mode .ks-pet-selector__pet:hover .ks-pet-selector__delete-btn {
        opacity: 1 !important;
        transform: scale(1) !important;
      }
    }
    
    /* Fallback for touch-capable desktop devices */
    @media (pointer: coarse) and (min-width: 768px) {
      .ks-pet-selector__pet .ks-pet-selector__delete-btn {
        opacity: 0.7 !important;
        transform: scale(1) !important;
      }
    }
    
    /* Delete button visible state for mobile long-press */
    .ks-pet-selector__pet.show-delete .ks-pet-selector__delete-btn {
      opacity: 1 !important;
      transform: scale(1) !important;
    }
    
    /* Edit mode - always visible delete buttons */
    .ks-pet-selector.edit-mode .ks-pet-selector__delete-btn {
      opacity: 1 !important;
      transform: scale(1) !important;
    }
    
    /* Default state for delete button - HIDDEN until edit mode */
    .ks-pet-selector__delete-btn {
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease, transform 0.2s ease;
      z-index: 20; /* Ensure delete button is above everything */
    }
    
    /* Enable pointer events in edit mode */
    .ks-pet-selector.edit-mode .ks-pet-selector__delete-btn {
      pointer-events: auto;
    }
    
    /* Mobile: Always show delete buttons for better UX */
    @media (max-width: 750px) {
      .ks-pet-selector.edit-mode .ks-pet-selector__pet {
        animation: editModeWiggle 2s ease-in-out infinite;
      }
    }
    
    /* Gentler wiggle animation for edit mode */
    @keyframes editModeWiggle {
      0%, 100% { transform: rotate(0deg); }
      25% { transform: rotate(-0.3deg); }
      75% { transform: rotate(0.3deg); }
    }
    
    /* Reduce motion for users who prefer it */
    @media (prefers-reduced-motion: reduce) {
      .ks-pet-selector.edit-mode .ks-pet-selector__pet {
        animation: none;
      }
    }
    
    /* Delete button hover effect - gentler styling */
    .ks-pet-selector__delete-btn:hover {
      background: rgba(108, 117, 125, 1) !important;
      transform: scale(1.05) !important;
    }
    
    .ks-pet-selector__delete-btn:active {
      transform: scale(0.95) !important;
    }
    
    .ks-pet-selector__pet.selected {
      border-color: #28a745;
      border-width: 4px;
      background: #f8fff9;
      box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.2);
      transform: scale(1.03);
    }
    
    .ks-pet-selector__pet-image {
      width: 100%;
      height: 100px;
      object-fit: cover;
      display: block;
      background: white;
      border-radius: 4px 4px 0 0;
    }
    
    .ks-pet-selector__pet-info {
      padding: 0.5rem;
      text-align: center;
    }
    
    .ks-pet-selector__pet-name {
      font-weight: 600;
      font-size: 0.875rem;
      margin: 0 0 0.25rem 0;
      color: #333;
    }
    
    .ks-pet-selector__pet-effect {
      font-size: 0.75rem;
      color: #666;
      margin: 0;
    }
    
    .ks-pet-selector__selected-badge {
      position: absolute;
      bottom: 8px;
      right: 8px;
      background: #28a745;
      color: white;
      border: 2px solid white; /* White border for visibility on any background */
      border-radius: 50%;
      width: 36px; /* Larger for better mobile visibility */
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem; /* Larger checkmark */
      font-weight: bold;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3); /* Stronger shadow for depth */
      z-index: 14; /* Below delete button but above image */
      animation: popIn 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
    }
    
    @keyframes popIn {
      0% { transform: scale(0); }
      100% { transform: scale(1); }
    }
    
    .ks-pet-selector__btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      text-decoration: none;
      display: inline-block;
      text-align: center;
      transition: all 0.2s ease;
      font-size: 0.875rem;
      width: 100%;
    }
    
    .ks-pet-selector__btn--secondary {
      background: #6c757d;
      color: white;
    }
    
    .ks-pet-selector__btn--secondary:hover {
      background: #545b62;
    }
    
    .ks-pet-selector__selected-info {
      border-top: 1px solid #e9ecef;
      padding-top: 1rem;
      margin-top: 1rem;
    }
    
    .ks-pet-selector__selected-pet {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1rem;
      padding: 0.75rem;
      background: #f8fff9;
      border: 2px solid #28a745;
      border-radius: 8px;
    }
    
    .ks-pet-selector__selected-icon {
      font-size: 1.5rem;
    }
    
    .ks-pet-selector__selected-text strong {
      display: block;
      color: #28a745;
      font-size: 1rem;
    }
    
    .ks-pet-selector__selected-text small {
      display: block;
      color: #666;
      font-size: 0.875rem;
      margin-top: 0.25rem;
    }
    
    /* Only show pricing info when there's an additional charge */
    .ks-pet-selector__price-info {
      font-size: 0.875rem;
      color: #666;
      text-align: center;
      padding: 0.375rem 0.75rem;
      background: #fff3cd;
      border: 1px solid #ffc107;
      border-radius: 8px;
      margin-top: 0.5rem;
      transition: all 0.3s ease;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 0.5rem;
    }
    
    /* Inline display for additional pet charge */
    .ks-pet-selector__price-info span {
      display: inline;
      margin: 0;
    }
    
    /* Hide base price - already shown on product page */
    .ks-pet-selector__base-price {
      display: none !important;
    }
    
    /* Emphasize additional fee */
    .ks-pet-selector__custom-fee {
      color: #856404;
      font-weight: 600;
      font-size: 0.9rem;
    }
    
    /* Total price display */
    .ks-pet-selector__total {
      font-weight: 600;
      color: #333 !important;
      font-size: 0.9rem !important;
      display: inline !important;
    }
    
    /* Layer ordering for cascade control */
    @layer base, components, utilities;
    
    /* Primary Empty State Styles */
    .ks-pet-selector__empty-primary {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem 1.5rem;
      background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
      border: 2px dashed #e1e4e8;
      border-radius: 12px;
      text-align: center;
      gap: 1.5rem;
      transition: all 0.2s ease;
    }
    
    .ks-pet-selector__empty-primary:hover {
      border-color: #007bff;
      background: linear-gradient(135deg, #f0f8ff 0%, #ffffff 100%);
    }
    
    .ks-pet-selector__empty-primary .ks-pet-selector__empty-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      width: 100%;
    }
    
    .ks-pet-selector__empty-primary .ks-pet-selector__empty-icon {
      width: 64px;
      height: 64px;
      background: #e3f2fd;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      margin-bottom: 0.5rem;
    }
    
    .ks-pet-selector__empty-primary .ks-pet-selector__empty-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: #1a202c;
      margin: 0;
      line-height: 1.3;
    }
    
    .ks-pet-selector__empty-primary .ks-pet-selector__empty-subtitle {
      font-size: 0.875rem;
      color: #4a5568;
      margin: 0;
      line-height: 1.4;
      max-width: 280px;
    }
    
    .ks-pet-selector__btn-primary {
      background: #007bff;
      color: white;
      padding: 12px 32px;
      border-radius: 8px;
      text-decoration: none;
      font-size: 15px;
      font-weight: 600;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    
    .ks-pet-selector__btn-primary:hover {
      background: #0056b3;
      transform: translateY(-1px);
      color: white;
      text-decoration: none;
    }
    
    /* Mobile optimizations for primary empty state */
    @media (max-width: 750px) {
      .ks-pet-selector__empty-primary {
        padding: 1.5rem 1rem;
        gap: 1rem;
      }
      
      .ks-pet-selector__empty-primary .ks-pet-selector__empty-icon {
        width: 56px;
        height: 56px;
        font-size: 24px;
      }
      
      .ks-pet-selector__empty-primary .ks-pet-selector__empty-title {
        font-size: 1.125rem;
      }
      
      .ks-pet-selector__empty-primary .ks-pet-selector__empty-subtitle {
        font-size: 0.813rem;
      }
      
      .ks-pet-selector__btn-primary {
        width: 100%;
        padding: 14px 24px;
      }
      
      /* Single line empty state mobile optimizations - size adjustments only */
      .ks-pet-selector__empty-compact {
        padding: 0 10px;
        gap: 10px;
        height: 44px; /* Maintain touch target */
      }
      
      .ks-pet-selector__empty-compact .ks-pet-selector__empty-icon {
        width: 28px;
        height: 28px;
        font-size: 14px;
      }
      
      .ks-pet-selector__empty-compact .ks-pet-selector__empty-text {
        font-size: 13px;
      }
      
      .ks-pet-selector__btn-compact {
        padding: 0 12px;
        font-size: 12px;
        min-width: 60px;
        height: 30px;
        margin-left: auto; /* CRITICAL: Maintain right alignment on mobile */
      }
      
      /* Very small screen adjustments */
      @media (max-width: 320px) {
        .ks-pet-selector__empty-compact .ks-pet-selector__empty-text {
          font-size: 12px;
        }
        .ks-pet-selector__btn-compact {
          min-width: 56px;
        }
      }
    }
    
    .ks-pet-selector__empty-content {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
    }
    
    .ks-pet-selector__empty-icon {
      width: 40px;
      height: 40px;
      background: #f0f8ff;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      flex-shrink: 0;
    }
    
    .ks-pet-selector__empty-text {
      flex: 1;
      min-width: 0;
    }
    
    .ks-pet-selector__empty-title {
      font-size: 14px;
      font-weight: 600;
      color: #24292e;
      margin: 0 0 2px 0;
      line-height: 1.2;
    }
    
    .ks-pet-selector__empty-subtitle {
      font-size: 12px;
      color: #586069;
      margin: 0;
      line-height: 1.3;
    }
    
    /* Button styles defined at line 675 with margin-left: auto */
    
    /* Touch interaction states within layer */
    @layer components {
      .ks-pet-selector__compact-empty:active {
        transform: scale(0.98);
        transition-duration: 0.1s;
      }
    }
    
    /* Single Line Horizontal Empty State - Maximum space efficiency */
    /* Clean CSS without anti-patterns - flexbox works naturally */
    .ks-pet-selector .ks-pet-selector__empty-compact {
      display: flex;
      flex-direction: row;
      align-items: center;
      padding: 0 12px;
      background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
      border: 2px dashed #e1e4e8;
      border-radius: 8px;
      gap: 12px;
      height: 44px; /* Minimum touch target */
      transition: all 0.2s ease;
      cursor: pointer;
      user-select: none;
      position: relative;
    }
    
    .ks-pet-selector__empty-compact:hover {
      border-color: #007bff;
      background: linear-gradient(135deg, #f0f8ff 0%, #ffffff 100%);
    }
    
    .ks-pet-selector__empty-compact:focus-visible {
      outline: 2px solid #007bff;
      outline-offset: 2px;
    }
    
    .ks-pet-selector__empty-compact:active {
      transform: scale(0.98);
      transition-duration: 0.1s;
    }
    
    .ks-pet-selector__empty-compact.loading {
      pointer-events: none;
      opacity: 0.7;
    }
    
    .ks-pet-selector__empty-compact .ks-pet-selector__empty-icon {
      width: 32px;
      height: 32px;
      background: #e3f2fd;
      border-radius: 50%;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      margin: 0;
    }
    
    .ks-pet-selector__empty-compact .ks-pet-selector__empty-text {
      flex: 1;
      min-width: 0;
      font-size: 14px;
      font-weight: 500;
      color: #24292e;
      margin: 0;
      line-height: 1.2;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .ks-pet-selector__btn-compact {
      background: #007bff;
      color: white;
      padding: 0 16px;
      border-radius: 6px;
      text-decoration: none;
      font-size: 13px;
      font-weight: 500;
      white-space: nowrap;
      flex-shrink: 0;
      transition: background 0.2s ease;
      border: none;
      cursor: pointer;
      height: 32px;
      min-width: 64px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-left: auto; /* Push to right side */
    }
    
    .ks-pet-selector__btn-compact:hover {
      background: #0056b3;
      color: white;
      text-decoration: none;
    }
    
    /* Mobile Responsiveness */
    @media screen and (max-width: 750px) {
      .ks-pet-selector {
        padding: 1rem;
        margin: 0.75rem 0;
      }
      
      .ks-pet-selector__pets {
        grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
        gap: 0.75rem;
      }
      
      .ks-pet-selector__pet-image {
        height: 80px;
      }
      
      .ks-pet-selector__title {
        font-size: 1.125rem;
      }
      
      /* Adjust badge position for smaller thumbnails */
      .ks-pet-selector__selected-badge {
        bottom: 6px;
        right: 6px;
        width: 28px; /* Slightly smaller on mobile */
        height: 28px;
        font-size: 0.75rem;
      }
      
      /* Mobile optimizations - removed @layer to avoid cascade issues */
      .ks-pet-selector__compact-empty {
        padding: 10px 12px;
        gap: 10px;
        min-height: 44px;  /* Consistent with desktop */
        max-height: 44px;  /* Fixed height for alignment */
      }
      
      .ks-pet-selector__empty-icon {
        width: 36px;
        height: 36px;
        font-size: 18px;
      }
      
      .ks-pet-selector__empty-title {
        font-size: 13px;
      }
      
      .ks-pet-selector__empty-subtitle {
        font-size: 11px;
      }
      
      .ks-pet-selector__btn-compact {
        padding: 7px 14px;
        font-size: 12px;
        margin-left: auto; /* CRITICAL: Maintain right alignment on mobile */
      }
    }
    
    /* Placeholder pet styling */
    .ks-pet-selector__pet--placeholder {
      opacity: 0.7;
      cursor: not-allowed;
    }
    
    .ks-pet-selector__pet--placeholder .ks-pet-selector__pet-image {
      filter: grayscale(50%);
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
  
  {% comment %} Social Sharing Styles - Removed: Should only load on pet processor page, not product pages
  {{ 'pet-social-sharing.css' | asset_url | stylesheet_tag }}
  {% endcomment %}

  <script>
    // Pet Selector V5 Integration - Inline Implementation
    (function() {
      const sectionId = '{{ section.id }}';
      const petSelector = document.getElementById(`pet-selector-${sectionId}`);
      
      if (!petSelector) {
        console.warn('Pet selector container not found');
        return;
      }
      
      let selectedPetData = null;
      
      // PHASE 0: Migration Configuration and Safeguards
      // Feature flags for safe migration from Map to PetStorage
      var MIGRATION_CONFIG = {
        USE_PETSTORAGE: true,         // ENABLED - Migration complete
        DEBUG_MODE: true,             // Extra logging during migration
        COMPATIBILITY_MODE: false,    // No longer maintaining Map
        BATCH_OPERATIONS: true,       // Batch localStorage operations for mobile
        OPERATION_DEBOUNCE_MS: 200    // Debounce rapid saves
      };
      
      // Log migration status
      console.log('🔄 Pet Selector Migration Status:', {
        USE_PETSTORAGE: MIGRATION_CONFIG.USE_PETSTORAGE,
        PetStorage_Available: !!window.PetStorage,
        Map_Available: !!window.perkieEffects,
        Mode: MIGRATION_CONFIG.USE_PETSTORAGE ? 'PetStorage' : 'Map'
      });
      
      // MIGRATION COMPLETE: Map no longer needed
      // PetStorage is the single source of truth
      // window.perkieEffects Map removed entirely
      
      // Global rollback function for emergency recovery
      window.rollbackToPetMap = function() {
        console.warn('🔄 Rolling back to Map implementation');
        MIGRATION_CONFIG.USE_PETSTORAGE = false;
        MIGRATION_CONFIG.DEBUG_MODE = true;
        restoreEffectsFromLocalStorage();
        console.log('✅ Rollback complete - using window.perkieEffects Map');
      };
      
      // Migration validation function
      function validateMigration() {
        if (!window.perkieEffects || !window.PetStorage) {
          console.warn('Cannot validate - missing dependencies');
          return false;
        }
        
        var effectsCount = getPetEffectsCount();
        var storageCount = Object.keys(PetStorage.getAll()).length;
        
        if (Math.abs(effectsCount - storageCount) > 1) {
          console.error('❌ Data mismatch detected! Effects:', effectsCount, 'Storage:', storageCount);
          return false;
        }
        
        if (MIGRATION_CONFIG.DEBUG_MODE) {
          console.log('✅ Migration validation passed - Map:', mapSize, 'Storage:', storageCount);
        }
        
        return true;
      }
      
      // Dual-write helper for compatibility during migration
      function saveWithCompatibility(petId, data) {
        // Primary: Always write to PetStorage
        if (window.PetStorage) {
          PetStorage.save(petId, data);
        }
        
        // Secondary: Maintain Map for compatibility if needed
        if (MIGRATION_CONFIG.COMPATIBILITY_MODE && window.perkieEffects) {
          // Convert to Map format if needed
          var effectKey = petId + '_' + (data.effect || 'enhancedblackwhite');
          var metadataKey = petId + '_metadata';
          
          setPetEffect(effectKey, data.thumbnail || data.gcsUrl);
          setPetEffect(metadataKey, {
            sessionKey: petId,
            name: data.name || data.petName,
            effect: data.effect || 'enhancedblackwhite',
            filename: data.filename,
            timestamp: data.timestamp || Date.now()
          });
        }
      }
      
      // Performance monitoring for migration
      var migrationMetrics = {
        readOperations: 0,
        writeOperations: 0,
        readTime: [],
        writeTime: [],
        startTime: Date.now()
      };
      
      function trackMigrationMetric(type, duration) {
        migrationMetrics[type + 'Operations']++;
        migrationMetrics[type + 'Time'].push(duration);
        
        // Log every 50 operations in debug mode
        if (MIGRATION_CONFIG.DEBUG_MODE && migrationMetrics.readOperations + migrationMetrics.writeOperations % 50 === 0) {
          var avgRead = migrationMetrics.readTime.reduce(function(a,b) { return a+b; }, 0) / migrationMetrics.readTime.length || 0;
          var avgWrite = migrationMetrics.writeTime.reduce(function(a,b) { return a+b; }, 0) / migrationMetrics.writeTime.length || 0;
          console.log('📊 Migration metrics - Reads:', migrationMetrics.readOperations, 
                      '(avg', avgRead.toFixed(2), 'ms) Writes:', migrationMetrics.writeOperations,
                      '(avg', avgWrite.toFixed(2), 'ms)');
        }
      }
      
      // PHASE 1: Migration wrapper functions for read operations
      // These functions use either Map or PetStorage based on feature flag
      
      // Wrapper for forEach operations
      function forEachPetEffect(callback) {
        var startTime = performance.now();
        
        if (MIGRATION_CONFIG.USE_PETSTORAGE && window.PetStorage) {
          // Use PetStorage's Map-compatible forEach
          // Note: PetStorage.forEachEffect passes (value, key) just like Map
          PetStorage.forEachEffect(function(value, key) {
            // Extract sessionKey and effect from compound key
            var match = key.match(/^(.+?)_(enhancedblackwhite|popart|dithering|color|metadata)$/);
            if (match) {
              // Pass value, key, sessionKey, effect to match Map behavior
              callback(value, key, match[1], match[2]);
            } else {
              callback(value, key, key, null);
            }
          });
        } else if (window.perkieEffects) {
          // Use Map implementation
          window.perkieEffects.forEach(function(value, key) {
            var match = key.match(/^(.+?)_(enhancedblackwhite|popart|dithering|color|metadata)$/);
            if (match) {
              callback(value, key, match[1], match[2]);
            } else {
              callback(value, key, key, null);
            }
          });
        }
        
        trackMigrationMetric('read', performance.now() - startTime);
      }
      
      // Wrapper for get operations
      function getPetEffect(key) {
        var startTime = performance.now();
        var result = null;
        
        if (MIGRATION_CONFIG.USE_PETSTORAGE && window.PetStorage) {
          // Parse the key to determine what we're getting
          if (key.includes('_metadata')) {
            var sessionKey = key.replace('_metadata', '');
            result = PetStorage.getMetadata(sessionKey);
          } else if (key.includes('_')) {
            var parts = key.split('_');
            result = PetStorage.getEffectUrl(parts[0], parts[1]);
          } else {
            var pet = PetStorage.get(key);
            result = pet ? (pet.thumbnail || pet.gcsUrl) : null;
          }
        } else if (window.perkieEffects) {
          result = window.perkieEffects.get(key);
        }
        
        trackMigrationMetric('read', performance.now() - startTime);
        return result;
      }
      
      // Wrapper for size/existence checks
      function hasPetEffects() {
        var startTime = performance.now();
        var hasEffects = false;
        
        if (MIGRATION_CONFIG.USE_PETSTORAGE && window.PetStorage) {
          var pets = PetStorage.getAll();
          hasEffects = pets && Object.keys(pets).length > 0;
        } else if (window.perkieEffects) {
          hasEffects = window.perkieEffects && window.perkieEffects.size > 0;
        }
        
        trackMigrationMetric('read', performance.now() - startTime);
        return hasEffects;
      }
      
      // Wrapper for getting count
      function getPetEffectsCount() {
        if (MIGRATION_CONFIG.USE_PETSTORAGE && window.PetStorage) {
          return Object.keys(PetStorage.getAll()).length;
        } else if (window.perkieEffects) {
          return window.perkieEffects.size;
        }
        return 0;
      }
      
      // Wrapper for checking if specific pet has effects
      function petHasEffects(sessionKey) {
        var hasEffects = false;
        
        if (MIGRATION_CONFIG.USE_PETSTORAGE && window.PetStorage) {
          var pet = PetStorage.get(sessionKey);
          hasEffects = pet && (pet.thumbnail || pet.gcsUrl || pet.effects);
        } else {
          // Check Map for any keys starting with sessionKey
          forEachPetEffect(function(value, key, extractedSessionKey) {
            if (extractedSessionKey === sessionKey || key.startsWith(sessionKey + '_')) {
              hasEffects = true;
            }
          });
        }
        
        return hasEffects;
      }
      
      // PHASE 2: Migration wrapper functions for write operations
      
      // Wrapper for set operations
      function setPetEffect(key, value) {
        var startTime = performance.now();
        
        if (MIGRATION_CONFIG.USE_PETSTORAGE && window.PetStorage) {
          // Parse key to determine what we're setting
          if (key.includes('_metadata')) {
            var sessionKey = key.replace('_metadata', '');
            // Convert metadata to PetStorage format
            var petData = {
              petId: sessionKey,
              name: value.name || value.petName || 'Pet',
              effect: value.effect || 'enhancedblackwhite',
              filename: value.filename,
              timestamp: value.timestamp || Date.now()
            };
            PetStorage.save(sessionKey, petData);
          } else if (key.includes('_')) {
            var parts = key.split('_');
            var sessionKey = parts[0];
            var effect = parts[1];
            // Get existing pet or create new
            var pet = PetStorage.get(sessionKey) || { petId: sessionKey };
            pet.effect = effect;
            pet.thumbnail = value;
            pet.gcsUrl = value;
            PetStorage.save(sessionKey, pet);
          } else {
            // Direct pet data
            PetStorage.save(key, value);
          }
          
          // Maintain Map compatibility if needed
          if (MIGRATION_CONFIG.COMPATIBILITY_MODE && window.perkieEffects) {
            window.perkieEffects.set(key, value);
          }
        } else if (window.perkieEffects) {
          window.perkieEffects.set(key, value);
        }
        
        trackMigrationMetric('write', performance.now() - startTime);
      }
      
      // Wrapper for delete operations
      function deletePetEffect(key) {
        var startTime = performance.now();
        
        if (MIGRATION_CONFIG.USE_PETSTORAGE && window.PetStorage) {
          // Extract sessionKey from compound key if needed
          var sessionKey = key;
          if (key.includes('_')) {
            var parts = key.split('_');
            sessionKey = parts[0];
          }
          
          // Check if we're deleting entire pet or just an effect
          if (key === sessionKey) {
            // Delete entire pet
            PetStorage.delete(sessionKey);
          } else {
            // Just remove from Map if compatibility mode
            if (MIGRATION_CONFIG.COMPATIBILITY_MODE && window.perkieEffects) {
              window.perkieEffects.delete(key);
            }
          }
          
          // Maintain Map compatibility
          if (MIGRATION_CONFIG.COMPATIBILITY_MODE && window.perkieEffects && window.perkieEffects.has(key)) {
            window.perkieEffects.delete(key);
          }
        } else if (window.perkieEffects) {
          window.perkieEffects.delete(key);
        }
        
        trackMigrationMetric('write', performance.now() - startTime);
      }
      
      // Batch delete helper for multiple keys
      function deletePetEffects(keys) {
        keys.forEach(function(key) {
          deletePetEffect(key);
        });
      }
      
      // MIGRATION COMPLETE: Pet selector now uses wrapper functions
      // To fully enable PetStorage: Set USE_PETSTORAGE: true
      // To disable compatibility: Set COMPATIBILITY_MODE: false
      // To rollback: Call window.rollbackToPetMap()
      // All direct Map calls have been replaced with wrapper functions
      
      // Cleanup blob URLs on page unload to prevent memory leaks
      window.addEventListener('beforeunload', function() {
        // MIGRATED: Use PetStorage instead of window.perkieEffects Map
        if (window.PetStorage) {
          PetStorage.forEachEffect(function(url, key) {
            if (url && typeof url === 'string' && url.startsWith('blob:')) {
              URL.revokeObjectURL(url);
            }
          });
        }
      });
      
      // MIGRATION COMPLETE: PetStorage auto-saves
      function saveEffectsToLocalStorage() {
        // PetStorage automatically saves to localStorage
        if (MIGRATION_CONFIG.DEBUG_MODE) {
          console.log('✅ PetStorage auto-save (no action needed)');
        }
      }
      
      // MIGRATION COMPLETE: PetStorage auto-restores
      function restoreEffectsFromLocalStorage() {
        // PetStorage automatically restores from localStorage
        var pets = PetStorage.getAll();
        var count = Object.keys(pets).length;
        
        if (MIGRATION_CONFIG.DEBUG_MODE) {
          console.log('✅ Found', count, 'pets in PetStorage');
        }
        return count > 0;
        
        var restored = 0;
        
        // Priority 1: Immediate backup (most recent)
        try {
          var immediateBackup = localStorage.getItem('perkieEffects_immediate');
          if (immediateBackup) {
            var data = JSON.parse(immediateBackup);
            Object.keys(data).forEach(function(key) {
              setPetEffect(key, data[key]);
              restored++;
            });
            console.log('✅ Restored', restored, 'effects from immediate backup');
            return restored > 0;
          }
        } catch (e) {
          console.warn('Failed to restore immediate backup:', e);
        }
        
        // Priority 2: Run migration if needed
        if (window.PetDataMigration && !localStorage.getItem('perkieMigrationCompleted')) {
          console.log('🔄 Running one-time migration to unified system...');
          var result = window.PetDataMigration.run();
          if (result.success) {
            console.log('✅ Migration completed:', result.message);
          } else {
            console.error('❌ Migration failed:', result.error);
          }
        }
        
        // Priority 3: Use unified manager for restoration
        if (window.PetDataManager) {
          return window.PetDataManager.restoreUnified();
        } else {
          console.warn('PetDataManager not loaded, restoration skipped');
          return false;
        }
      }
      
      // PHASE 3: Updated helper - Clean up old effects backup
      function cleanupOldEffectsBackup() {
        if (MIGRATION_CONFIG.USE_PETSTORAGE) {
          // Use PetStorage's built-in cleanup
          if (window.PetStorage && window.PetStorage.emergencyCleanup) {
            var usage = window.PetStorage.getStorageUsage();
            if (usage.percentage > 80) {
              console.warn('⚠️ Storage at', usage.percentage + '%, running cleanup');
              window.PetStorage.emergencyCleanup();
            }
          }
          return;
        }
        
        // Legacy cleanup for Map mode
        try {
          var sessionKeys = [];
          for (var i = 0; i < localStorage.length; i++) {
            var key = localStorage.key(i);
            if (key && key.startsWith('pet_session_')) {
              try {
                var data = JSON.parse(localStorage.getItem(key));
                if (data && data.timestamp) {
                  var age = Date.now() - data.timestamp;
                  if (age > 24 * 60 * 60 * 1000) { // 24 hours
                    localStorage.removeItem(key);
                  } else if (data.currentSessionKey) {
                    sessionKeys.push(data.currentSessionKey);
                  }
                }
              } catch (e) {
                // Skip invalid entries
              }
            }
          }
          
          // Clean backup data for sessions that no longer exist
          var backup = localStorage.getItem('perkieEffects_backup');
          if (backup) {
            try {
              var effectsData = JSON.parse(backup);
              var cleanedData = {};
              var hasValidEffects = false;
              
              Object.keys(effectsData).forEach(function(key) {
                // Keep all effects for now (simplified cleanup)
                cleanedData[key] = effectsData[key];
                hasValidEffects = true;
              });
              
              if (!hasValidEffects) {
                localStorage.removeItem('perkieEffects_backup');
              }
            } catch (e) {
              // Skip invalid backup data
            }
          }
        } catch (error) {
          console.warn('Cleanup failed:', error);
        }
      }
      
      // AUTO-SELECT: Attempt to auto-select single available pet
      function attemptAutoSelect() {
        var maxPets = parseInt(petSelector.dataset.maxPets) || 1;
        var availablePets = document.querySelectorAll('.ks-pet-selector__pet:not(.ks-pet-selector__pet--no-effects)');
        var currentSelectedCount = selectedPetsData.length;

        // Only auto-select when exactly 1 pet is available and none selected
        // Works for ALL max_pets values (1, 2, or 3)
        if (availablePets.length === 1 && currentSelectedCount === 0) {
          var petEl = availablePets[0];
          var sessionKey = petEl.getAttribute('data-session-key');
          var petName = petEl.getAttribute('data-pet-name') || 'Your Pet';

          console.log('🎯 Auto-selecting single pet:', petName);

          // Use existing selectPet function
          selectPet(sessionKey, petName);

          // Show confirmation banner
          showAutoSelectConfirmation(petName, maxPets);

          // Track analytics
          trackAutoSelectEvent(petName, maxPets);
        }
      }

      // Show mobile-optimized confirmation banner
      function showAutoSelectConfirmation(petName, maxPets) {
        var confirmationHTML =
          '<div class="ks-pet-auto-confirm" ' +
          'id="pet-auto-confirm-' + sectionId + '" ' +
          'role="status" ' +
          'aria-live="polite">' +
          '<div class="auto-confirm-content">' +
          '<span class="auto-confirm-icon">✨</span>' +
          '<span class="auto-confirm-text">' +
          '<strong>' + petName + '</strong> selected' +
          (maxPets > 1 ? ' (you can add up to ' + (maxPets - 1) + ' more)' : '') +
          '</span>' +
          '<div class="auto-confirm-actions">' +
          '<button type="button" class="auto-confirm-change" data-section-id="' + sectionId + '" data-action="scroll-to-grid">Change</button>' +
          '<button type="button" class="auto-confirm-dismiss" data-section-id="' + sectionId + '" data-action="dismiss" aria-label="Dismiss confirmation">✕</button>' +
          '</div>' +
          '</div>' +
          '</div>';

        var header = document.getElementById('pet-selector-header-' + sectionId);
        if (header) {
          header.insertAdjacentHTML('afterend', confirmationHTML);

          // Add event listeners to the buttons we just created
          var banner = document.getElementById('pet-auto-confirm-' + sectionId);
          if (banner) {
            var changeBtn = banner.querySelector('[data-action="scroll-to-grid"]');
            var dismissBtn = banner.querySelector('[data-action="dismiss"]');

            if (changeBtn) {
              changeBtn.addEventListener('click', function() {
                window['scrollToPetGrid_' + sectionId]();
              });
            }

            if (dismissBtn) {
              dismissBtn.addEventListener('click', function() {
                window['dismissAutoConfirm_' + sectionId]();
              });
            }
          }

          // Haptic feedback (mobile)
          if (window.navigator && window.navigator.vibrate) {
            window.navigator.vibrate([10, 50, 10]); // Double-tap pattern
          }

          // Auto-scroll to Add to Cart button (mobile only)
          if (window.innerWidth <= 750) {
            setTimeout(function() {
              var addToCartBtn = document.querySelector('form[action*="/cart/add"] button[name="add"]');
              if (addToCartBtn) {
                addToCartBtn.scrollIntoView({
                  behavior: 'smooth',
                  block: 'center'
                });
              }
            }, 2000);
          }

          // Auto-hide after 10 seconds
          setTimeout(function() {
            window['dismissAutoConfirm_' + sectionId]();
          }, 10000);
        }
      }

      // Dismiss confirmation banner
      window['dismissAutoConfirm_' + sectionId] = function() {
        var banner = document.getElementById('pet-auto-confirm-' + sectionId);
        if (banner) {
          banner.style.opacity = '0';
          banner.style.transform = 'translateY(-10px)';
          setTimeout(function() {
            if (banner.parentNode) {
              banner.parentNode.removeChild(banner);
            }
          }, 300);
        }
      };

      // Scroll to pet grid helper
      window['scrollToPetGrid_' + sectionId] = function() {
        var petContent = document.getElementById('pet-selector-content-' + sectionId);
        if (petContent) {
          petContent.scrollIntoView({ behavior: 'smooth', block: 'start' });

          // Remove confirmation banner
          var banner = document.getElementById('pet-auto-confirm-' + sectionId);
          if (banner && banner.parentNode) {
            banner.parentNode.removeChild(banner);
          }
        }
      };

      // Track auto-selection analytics
      function trackAutoSelectEvent(petName, maxPets) {
        // Google Analytics 4
        if (window.gtag) {
          gtag('event', 'pet_auto_selected', {
            'pet_name': petName,
            'max_pets': maxPets,
            'device_type': window.innerWidth < 750 ? 'mobile' : 'desktop',
            'page_location': window.location.href
          });
        }

        // Shopify Analytics
        if (window.ShopifyAnalytics) {
          window.ShopifyAnalytics.lib.track('Pet Auto Selected', {
            petName: petName,
            maxPets: maxPets,
            isMobile: window.innerWidth < 750,
            timestamp: new Date().toISOString()
          });
        }

        console.log('📊 Analytics: Pet auto-selected', { petName: petName, maxPets: maxPets });
      }

      // Initialize pet selector
      function initPetSelector() {
        // Emergency cleanup if localStorage is full
        try {
          var totalSize = 0;
          for (var i = 0; i < localStorage.length; i++) {
            var key = localStorage.key(i);
            if (key) {
              var value = localStorage.getItem(key);
              if (value) totalSize += value.length;
            }
          }
          
          // If over 4MB, clean up old backups
          if (totalSize > 4 * 1024 * 1024) {
            console.log('🧹 localStorage usage high, cleaning up old backups...');
            var keysToRemove = [
              'perkieEffects_backup',
              'perkieThumbnails_backup', 
              'perkieAllEffects_backup',
              'perkieSessionPets_backup',
              'perkiePersistence' // Remove failed migration data
            ];
            
            keysToRemove.forEach(function(key) {
              localStorage.removeItem(key);
            });
            
            // Also remove old session data
            var allKeys = [];
            for (var i = 0; i < localStorage.length; i++) {
              var k = localStorage.key(i);
              if (k && k.indexOf('pet_session_') === 0) {
                allKeys.push(k);
              }
            }
            allKeys.forEach(function(k) {
              localStorage.removeItem(k);
            });
            
            console.log('✅ Cleanup complete, localStorage ready');
          }
        } catch (e) {
          console.error('Cleanup failed:', e);
        }
        
        // Clean up old data first
        cleanupOldEffectsBackup();
        
        // MIGRATED: Check PetStorage instead of window.perkieEffects Map
        const allPets = PetStorage.getAll();
        if (!allPets || Object.keys(allPets).length === 0) {
          restoreEffectsFromLocalStorage();
        }
        
        loadSavedPets();

        // AUTO-SELECT: Attempt to auto-select single pet after pets are loaded
        setTimeout(function() {
          attemptAutoSelect();
        }, 600); // After loadSavedPets completes

        // Initialize bidirectional variant-pet synchronization
        setTimeout(function() {
          initVariantPetSync();
        }, 500); // Small delay to ensure Shopify variant system is ready
        
        // Listen for new pet processor completions
        document.addEventListener('petProcessorComplete', function(event) {
          console.log('New pet processed, refreshing selector...', event.detail);
          
          // Reset restoration guard since we have new data
          if (typeof showEmptyState !== 'undefined' && showEmptyState.restorationAttempted) {
            showEmptyState.restorationAttempted = false;
            console.log('🔄 Reset restoration guard due to new pet');
          }
          
          setTimeout(function() {
            // Force complete refresh of pet selector
            loadSavedPets();
            
            // Ensure UI is actually updated - fallback if renderPets wasn't called
            setTimeout(function() {
              const petsContainer = document.querySelector('.ks-pet-selector__pets');
              if (!petsContainer || petsContainer.children.length === 0) {
                console.log('🔄 No pets visible after refresh, forcing direct render...');
                
                // Direct render from PetStorage
                if (window.PetStorage) {
                  const petStorageData = window.PetStorage.getAll();
                  const petArray = [];
                  
                  Object.entries(petStorageData).forEach(function(entry) {
                    const petId = entry[0];
                    const pet = entry[1];
                    petArray.push({
                      sessionKey: petId,
                      name: pet.name || 'Pet',
                      thumbnail: pet.thumbnail,
                      effect: pet.effect,
                      originalImage: pet.originalImage
                    });
                  });
                  
                  if (petArray.length > 0) {
                    console.log('🔄 Direct rendering', petArray.length, 'pets from PetStorage');
                    renderPets(petArray);
                  }
                }
              }
            }, 200);
            
            saveEffectsToLocalStorage(); // Backup after new processing
          }, 500);
        });

        // Save effects when they exist (for cross-page persistence)
        if (hasPetEffects()) {
          saveEffectsToLocalStorage();
        }
      }

      // Monitor pet name input for multi-pet variant updates
      var petNameInput = document.getElementById('pet-name-input-' + sectionId);
      if (petNameInput) {
        // Debounce function to avoid excessive calls
        var petNameDebounceTimer;

        petNameInput.addEventListener('input', function(e) {
          clearTimeout(petNameDebounceTimer);

          petNameDebounceTimer = setTimeout(function() {
            var petNameValue = petNameInput.value.trim();

            // Parse comma-separated names (same logic as quick-upload-handler.js)
            var petNames = petNameValue.split(',')
              .map(function(n) { return n.trim(); })
              .filter(function(n) { return n.length > 0; });

            var petCount = petNames.length;

            console.log('🐾 Pet name input changed:', {
              rawValue: petNameValue,
              parsedNames: petNames,
              count: petCount
            });

            // Update variant and pricing if we have at least 1 pet name
            if (petCount > 0) {
              // Call updateVariantForPetCount directly with the name count
              updateVariantForPetCount(petCount);

              // Also update pricing display
              updatePetPricing();

              // Dispatch event for font selector integration
              try {
                var nameChangeEvent;

                // Feature detection for CustomEvent (IE11 polyfill)
                if (typeof CustomEvent === 'function') {
                  nameChangeEvent = new CustomEvent('pet-name:changed', {
                    detail: {
                      names: petNames,
                      displayName: petNames.join(', '),
                      count: petCount,
                      source: 'pet-name-input',
                      sectionId: sectionId
                    }
                  });
                } else {
                  // Fallback for IE11
                  nameChangeEvent = document.createEvent('CustomEvent');
                  nameChangeEvent.initCustomEvent('pet-name:changed', false, false, {
                    names: petNames,
                    displayName: petNames.join(', '),
                    count: petCount,
                    source: 'pet-name-input',
                    sectionId: sectionId
                  });
                }

                document.dispatchEvent(nameChangeEvent);
              } catch (error) {
                // Silent fail - font selector is enhancement, not critical path
              }
            } else {
              // Dispatch event to hide font selector when name cleared
              try {
                var clearEvent;
                if (typeof CustomEvent === 'function') {
                  clearEvent = new CustomEvent('pet-name:changed', {
                    detail: {
                      names: [],
                      displayName: '',
                      count: 0,
                      source: 'pet-name-input',
                      sectionId: sectionId
                    }
                  });
                } else {
                  clearEvent = document.createEvent('CustomEvent');
                  clearEvent.initCustomEvent('pet-name:changed', false, false, {
                    names: [],
                    displayName: '',
                    count: 0,
                    source: 'pet-name-input',
                    sectionId: sectionId
                  });
                }
                document.dispatchEvent(clearEvent);
              } catch (error) {
                // Silent fail
              }
            }
          }, 500); // 500ms debounce
        });
      }

      // Update header based on pet availability
      function updateHeaderState(hasPets) {
        var titleEl = document.getElementById('pet-selector-title-' + sectionId);
        var descriptionEl = document.getElementById('pet-selector-description-' + sectionId);
        var editBtn = document.getElementById('pet-edit-btn-' + sectionId);
        
        if (hasPets) {
          // Header shows collection management
          if (titleEl) titleEl.textContent = 'Your Pets';
          if (descriptionEl) descriptionEl.style.display = 'block';
          if (editBtn) editBtn.style.display = 'inline-block';
        } else {
          // Header minimal when empty state is primary  
          if (titleEl) titleEl.textContent = 'Your Pets';
          if (descriptionEl) descriptionEl.style.display = 'none';
          if (editBtn) editBtn.style.display = 'none';
        }
      }
      
      // Convert blob URL to data URL to avoid Shopify analytics issues
      function convertBlobToDataUrl(blobUrl) {
        return new Promise(function(resolve, reject) {
          // Handle undefined, null, or invalid URLs
          if (!blobUrl || blobUrl === 'undefined' || blobUrl === 'null' || blobUrl === '') {
            // Return transparent GIF as fallback for invalid URLs
            resolve('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7');
            return;
          }
          
          // If already a data URL, return as-is
          if (blobUrl.startsWith('data:')) {
            resolve(blobUrl);
            return;
          }
          
          // If not a blob URL, return as-is (might be a regular URL)
          if (!blobUrl.startsWith('blob:')) {
            resolve(blobUrl);
            return;
          }
          
          try {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', blobUrl);
            xhr.responseType = 'blob';
            xhr.onload = function() {
              if (xhr.status === 200) {
                var reader = new FileReader();
                reader.onload = function() {
                  resolve(reader.result);
                };
                reader.onerror = function() {
                  console.warn('Failed to convert blob to data URL, using original');
                  resolve(blobUrl); // Fallback to original
                };
                reader.readAsDataURL(xhr.response);
              } else {
                resolve(blobUrl); // Fallback to original
              }
            };
            xhr.onerror = function() {
              console.warn('Failed to fetch blob, using original');
              resolve(blobUrl); // Fallback to original
            };
            xhr.send();
          } catch (error) {
            console.warn('Error converting blob URL:', error);
            resolve(blobUrl); // Fallback to original
          }
        });
      }
      
      // Load pets directly from PetStorage (MIGRATION COMPLETE)
      function loadSavedPets() {
        console.log('🐕 loadSavedPets called (PetStorage mode only)');
        const contentEl = document.getElementById(`pet-selector-content-${sectionId}`);
        const selectedEl = document.getElementById(`pet-selector-selected-${sectionId}`);
        const emptyEl = document.getElementById(`pet-selector-empty-${sectionId}`);
        
        // Direct read from PetStorage - single source of truth
        const petData = window.PetStorage.getAllForDisplay();
        console.log('✅ Found', petData.length, 'pets in PetStorage');
        
        if (petData.length === 0) {
          console.log('⚠️ No pets found, showing empty state');
          showEmptyState();
          return;
        }
        
        // Convert URLs and render
        console.log('🐕 Converting URLs for', petData.length, 'pets...');
        convertPetDataUrls(petData).then(function(convertedPetData) {
          console.log('🐕 Conversion complete, rendering', convertedPetData.length, 'pets');
          renderPets(convertedPetData);
        });
        
        function showEmptyState() {
          // Prevent infinite loop - track if we already tried restoration
          if (showEmptyState.restorationAttempted) {
            console.log('⚠️ Restoration already attempted, showing empty state');
            contentEl.style.display = 'none';
            selectedEl.style.display = 'none';
            emptyEl.style.display = 'flex';
            // Hide header description to avoid redundant links
            var descriptionEl = document.getElementById('pet-selector-description-' + sectionId);
            if (descriptionEl) {
              descriptionEl.style.display = 'none';
            }
            return;
          }
          
          // Try restore one more time before showing empty state
          showEmptyState.restorationAttempted = true;
          var restored = restoreEffectsFromLocalStorage();
          if (restored) {
            // Only retry if restoration actually added displayable pets
            var petCount = extractPetDataFromCache().length;
            if (petCount > 0) {
              console.log('✅ Restoration successful, reloading with', petCount, 'pets');
              showEmptyState.restorationAttempted = false; // Reset for next time
              loadSavedPets();
              return;
            } else {
              console.log('⚠️ Restoration returned data but no displayable pets, showing empty state');
            }
          }
          
          contentEl.style.display = 'none';
          selectedEl.style.display = 'none';
          emptyEl.style.display = 'flex';
          // Hide header description to avoid redundant links
          var descriptionEl = document.getElementById('pet-selector-description-' + sectionId);
          if (descriptionEl) {
            descriptionEl.style.display = 'none';
          }
          
          // Make the entire empty state clickable
          initEmptyStateInteraction();
        }
        
        // Initialize empty state interactions with double-click prevention
        function initEmptyStateInteraction() {
          var emptyCompact = document.querySelector('#pet-selector-empty-' + sectionId + '.ks-pet-selector__empty-compact');
          if (!emptyCompact) return;
          
          var isNavigating = false; // Prevent double-clicks
          
          // Track impressions for analytics
          if (window.analytics) {
            window.analytics.track('empty_selector_viewed', {
              variant: 'compact_horizontal',
              device: /Mobi/.test(navigator.userAgent) ? 'mobile' : 'desktop',
              section_id: sectionId,
              height_saved: '164px'
            });
          }
          
          // Keyboard navigation support
          emptyCompact.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              if (!isNavigating) {
                isNavigating = true;
                emptyCompact.classList.add('loading');
                window.location.href = '/pages/custom-image-processing';
              }
            }
          });
          
          // Whole card clickable with double-click prevention
          emptyCompact.addEventListener('click', function(e) {
            // Don't navigate if clicking the button directly or if already navigating
            if (isNavigating) return;
            
            if (!e.target.classList.contains('ks-pet-selector__btn-compact') && 
                !e.target.closest('.ks-pet-selector__btn-compact')) {
              
              // Track whole-card clicks
              if (window.analytics) {
                window.analytics.track('empty_selector_card_clicked', {
                  variant: 'compact_horizontal',
                  click_type: 'card_area',
                  section_id: sectionId
                });
              }
              
              isNavigating = true;
              emptyCompact.classList.add('loading');
              // Validate URL before navigation
              var targetUrl = '/pages/custom-image-processing';
              if (targetUrl.indexOf('/pages/') === 0) {
                window.location.href = targetUrl;
              }
            }
          });
          
          // Track button clicks separately
          var compactBtn = emptyCompact.querySelector('.ks-pet-selector__btn-compact');
          if (compactBtn) {
            compactBtn.addEventListener('click', function(e) {
              if (isNavigating) {
                e.preventDefault();
                return;
              }
              if (window.analytics) {
                window.analytics.track('empty_selector_cta_clicked', {
                  variant: 'compact_horizontal',
                  click_type: 'button',
                  section_id: sectionId
                });
              }
              isNavigating = true;
              emptyCompact.classList.add('loading');
            });
          }
          
          // Haptic feedback and touch interactions for mobile
          if ('vibrate' in navigator && /Mobi/.test(navigator.userAgent)) {
            // Combined touchstart handler for haptic and visual feedback
            emptyCompact.addEventListener('touchstart', function() {
              navigator.vibrate(10); // Subtle 10ms vibration
              this.style.transform = 'scale(0.98)';
              this.style.transition = 'transform 0.1s ease';
            }, { passive: true });
            
            emptyCompact.addEventListener('touchend', function() {
              this.style.transform = 'scale(1)';
              this.style.transition = 'transform 0.2s ease';
            }, { passive: true });
          }
        }
      }
      
      // Convert all blob URLs in pet data to data URLs
      function convertPetDataUrls(petData) {
        var promises = petData.map(function(pet) {
          var effectPromises = [];
          pet.effects.forEach(function(url, effectName) {
            effectPromises.push(
              convertBlobToDataUrl(url).then(function(dataUrl) {
                return { effectName: effectName, dataUrl: dataUrl };
              })
            );
          });
          
          return Promise.all(effectPromises).then(function(results) {
            var convertedEffects = new Map();
            results.forEach(function(result) {
              convertedEffects.set(result.effectName, result.dataUrl);
            });
            
            return {
              sessionKey: pet.sessionKey,
              name: pet.name,
              uploadTime: pet.uploadTime,
              effects: convertedEffects
            };
          });
        });
        
        return Promise.all(promises);
      }
      
      // REFACTORED: Extract pet data directly from PetStorage (no Map)
      function extractPetDataFromStorage() {
        console.log('🔄 Extracting pets directly from PetStorage');
        return window.PetStorage.getAllForDisplay();
      }
      
      // DEPRECATED: Old Map-based extraction (kept for backward compatibility)
      function extractPetDataFromCache() {
        const pets = new Map();
        
        // Get list of deleted pets to exclude from recovery
        var deletedPets = [];
        try {
          var deletedData = localStorage.getItem('perkieDeletedPets');
          if (deletedData) {
            var parsed = JSON.parse(deletedData);
            deletedPets = parsed.map(function(p) { return p.sessionKey; });
            console.log('🗑️ Excluding', deletedPets.length, 'deleted pets from recovery');
          }
        } catch (e) {}
        
        // Check for multi-pet data from pet processor
        let processedPetsList = [];
        let petNamesMap = {};
        let possibleKeys = [];
        
        // Check localStorage for multi-pet session data
        // Try multiple possible session keys since sectionId might vary
        try {
          // Check common session keys
          possibleKeys = ['pet_session_pet-bg-remover', 'pet_session_template--17206362407105__a87bbcf5-f48d-4e65-9322-aeaa2c1e6cc5'];
          let sessionFound = false;
          
          // Also check for any pet_session_ keys
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('pet_session_')) {
              possibleKeys.push(key);
            }
          }
          
          for (let i = 0; i < possibleKeys.length && !sessionFound; i++) {
            const sessionData = localStorage.getItem(possibleKeys[i]);
            if (sessionData) {
              const parsed = JSON.parse(sessionData);
              if (parsed.processedPets && parsed.processedPets.length > 0) {
                processedPetsList = parsed.processedPets;
                petNamesMap = parsed.petNames || {};
                sessionFound = true;
                console.log('Loaded multi-pet session from:', possibleKeys[i], 'with', processedPetsList.length, 'pets');
                
                // Attempt to recover missing effects from localStorage backups
                console.log('🔄 Attempting to recover missing pet effects...');
                processedPetsList.forEach(function(sessionKey) {
                  // Skip deleted pets (check both tracking systems)
                  if (deletedPets.indexOf(sessionKey) !== -1) {
                    // Check if this pet has valid effects data that's newer than deletion
                    var hasValidEffects = petHasEffects(sessionKey);
                    
                    if (hasValidEffects) {
                      console.log('✅ Recovering pet with valid effects despite deletion flag:', sessionKey);
                      // Remove from deleted pets list
                      try {
                        var deletedData = localStorage.getItem('perkieDeletedPets');
                        if (deletedData) {
                          var parsed = JSON.parse(deletedData);
                          var filtered = parsed.filter(function(p) { return p.sessionKey !== sessionKey; });
                          localStorage.setItem('perkieDeletedPets', JSON.stringify(filtered));
                          // Update local deletedPets array
                          var index = deletedPets.indexOf(sessionKey);
                          if (index > -1) {
                            deletedPets.splice(index, 1);
                          }
                          console.log('🧹 Removed recovered pet from deletion list:', sessionKey);
                        }
                      } catch (e) {
                        console.warn('Failed to update deleted pets list:', e);
                      }
                    } else {
                      return;
                    }
                  }
                  
                  // Check timestamp-based deletion locks
                  if (window.petDeletionLocks && window.petDeletionLocks[sessionKey]) {
                    var lock = window.petDeletionLocks[sessionKey];
                    var lockAge = Date.now() - lock.timestamp;
                    if (lockAge < lock.timeout) {
                      console.log('⏩ Skipping pet with active deletion lock:', sessionKey);
                      return;
                    } else {
                      // Lock expired, clean it up
                      delete window.petDeletionLocks[sessionKey];
                    }
                  }
                  
                  // Check if effects exist
                  let hasEffects = petHasEffects(sessionKey);
                  
                  if (!hasEffects) {
                    // Check if this pet is currently being deleted
                    if (window.petDeletionInProgress && window.petDeletionInProgress.has(sessionKey)) {
                      console.log('⚠️ Skipping recovery for pet being deleted:', sessionKey);
                      return; // Skip this pet entirely
                    }
                    
                    console.log('⚠️ Missing effects for:', sessionKey, '- attempting recovery');
                    
                    // Try comprehensive backup first
                    var allEffectsBackup = localStorage.getItem('perkieAllEffects_backup');
                    if (allEffectsBackup) {
                      try {
                        var allEffectsData = JSON.parse(allEffectsBackup);
                        var recoveredCount = 0;
                        
                        Object.keys(allEffectsData).forEach(function(key) {
                          if (key.startsWith(sessionKey + '_')) {
                            setPetEffect(key, allEffectsData[key]);
                            recoveredCount++;
                          }
                        });
                        
                        if (recoveredCount > 0) {
                          console.log('✅ Recovered', recoveredCount, 'effects for', sessionKey, 'from comprehensive backup');
                          hasEffects = true;
                        }
                      } catch (e) {
                        console.warn('Failed to parse comprehensive backup:', e);
                      }
                    }
                    
                    // Fallback: Try to recover from individual localStorage items
                    if (!hasEffects) {
                      for (let j = 0; j < localStorage.length; j++) {
                        const storageKey = localStorage.key(j);
                        
                        // Check for direct storage
                        if (storageKey && storageKey.startsWith(sessionKey + '_')) {
                          try {
                            const data = localStorage.getItem(storageKey);
                            if (data && (data.startsWith('data:image') || data.startsWith('blob:'))) {
                              setPetEffect(storageKey, data);
                              console.log('✅ Recovered effect:', storageKey);
                              hasEffects = true;
                            }
                          } catch (e) {
                            console.log('Failed to recover:', storageKey, e);
                          }
                        }
                        
                        // Check for new backup format (pet_effect_backup_*)
                        if (storageKey && storageKey.startsWith('pet_effect_backup_' + sessionKey + '_')) {
                          try {
                            const backupData = JSON.parse(localStorage.getItem(storageKey));
                            if (backupData && backupData.dataUrl) {
                              const effectKey = storageKey.replace('pet_effect_backup_', '');
                              setPetEffect(effectKey, backupData.dataUrl);
                              console.log('✅ Recovered from backup:', effectKey);
                              hasEffects = true;
                            }
                          } catch (e) {
                            console.log('Failed to recover from backup:', storageKey, e);
                          }
                        }
                      }
                    }
                  }
                });
              }
            }
          }
          
          if (!sessionFound) {
            console.log('No multi-pet session data found');
          }
        } catch (e) {
          console.log('Could not load multi-pet session data:', e);
        }
        
        // Group effects by session key
        forEachPetEffect(function(imageUrl, key, sessionKey, effect) {
          if (effect && effect !== 'metadata') {
            
            if (!pets.has(sessionKey)) {
              // Priority for pet name resolution:
              // 1. User-entered name from session
              // 2. Metadata stored with effects
              // 3. Extracted from filename
              let petName = petNamesMap[sessionKey];
              
              // Check metadata if no session name
              if (!petName) {
                const metadataKey = sessionKey + '_metadata';
                const metadataRaw = getPetEffect(metadataKey);
                if (metadataRaw) {
                  try {
                    const metadata = typeof metadataRaw === 'string' ? JSON.parse(metadataRaw) : metadataRaw;
                    if (metadata && (metadata.name || metadata.petName)) {
                      petName = metadata.name || metadata.petName;
                    }
                  } catch (e) {
                    console.warn('Failed to parse metadata for pet name:', e);
                  }
                }
              }
              
              // Final fallback to filename extraction
              if (!petName) {
                petName = extractPetName(sessionKey);
              }
              
              pets.set(sessionKey, {
                sessionKey,
                name: petName,
                effects: new Map()
              });
            }
            
            pets.get(sessionKey).effects.set(effect, imageUrl);
          }
        });
        
        // Order pets according to processedPets list if available
        if (processedPetsList.length > 0) {
          const orderedPets = [];
          const validSessionPets = [];
          
          // First pass: collect all pets (including those without effects)
          processedPetsList.forEach(sessionKey => {
            // Skip deleted pets (check both tracking systems)
            if (deletedPets.indexOf(sessionKey) !== -1) {
              // Check if this pet has valid effects data that's newer than deletion
              var hasValidEffects = petHasEffects(sessionKey);
              
              if (hasValidEffects) {
                console.log('✅ Recovering pet with valid effects despite deletion flag:', sessionKey);
                // Remove from deleted pets list
                try {
                  var deletedData = localStorage.getItem('perkieDeletedPets');
                  if (deletedData) {
                    var parsed = JSON.parse(deletedData);
                    var filtered = parsed.filter(function(p) {
                      return p.sessionKey !== sessionKey;
                    });
                    localStorage.setItem('perkieDeletedPets', JSON.stringify(filtered));
                    console.log('🧹 Removed recovered pet from deletion list:', sessionKey);
                  }
                } catch (e) {
                  console.warn('Failed to update deleted pets list:', e);
                }
              } else {
                console.log('⏩ Skipping deleted pet from session list:', sessionKey);
                return;
              }
            }
            
            // Check timestamp-based deletion locks
            if (window.petDeletionLocks && window.petDeletionLocks[sessionKey]) {
              var lock = window.petDeletionLocks[sessionKey];
              var lockAge = Date.now() - lock.timestamp;
              if (lockAge < lock.timeout) {
                console.log('⏩ Skipping pet with active deletion lock:', sessionKey);
                return;
              } else {
                // Lock expired, clean it up
                delete window.petDeletionLocks[sessionKey];
              }
            }
            
            if (pets.has(sessionKey)) {
              orderedPets.push(pets.get(sessionKey));
              validSessionPets.push(sessionKey);
            } else {
              console.log('⚠️ Pet in session but not in effects:', sessionKey);
              // Try to recover from individual localStorage items or show with available data
              if (petNamesMap[sessionKey]) {
                console.log('📝 Attempting recovery for:', sessionKey, 'with name:', petNamesMap[sessionKey]);
                
                // Try to find ANY effect for this pet in localStorage
                let foundAnyEffect = false;
                const recoveredEffects = new Map();
                
                // Check for any effect pattern in localStorage
                for (let i = 0; i < localStorage.length; i++) {
                  const key = localStorage.key(i);
                  // Check for both direct keys and backup keys with pet_effect_backup_ prefix
                  if (key && (key.startsWith(sessionKey + '_') || key.startsWith('pet_effect_backup_' + sessionKey + '_'))) {
                    // Handle both regular effects and thumbnail keys
                    let effectType = key
                      .replace('pet_effect_backup_', '') // Remove backup prefix if present
                      .replace(sessionKey + '_', ''); // Remove session key
                    // Check if this is a thumbnail key and strip the _thumb suffix
                    if (effectType.endsWith('_thumb')) {
                      effectType = effectType.replace('_thumb', '');
                    }
                    effectType = effectType.split('_')[0];
                    if (['enhancedblackwhite', 'popart', 'dithering', 'color'].includes(effectType)) {
                      const data = localStorage.getItem(key);
                      // Handle both direct data URLs and backup format with JSON
                      let dataUrl = data;
                      if (data && data.startsWith('{')) {
                        try {
                          const parsed = JSON.parse(data);
                          if (parsed.dataUrl) {
                            dataUrl = parsed.dataUrl;
                          }
                        } catch (e) {
                          console.log('Failed to parse backup data:', e);
                        }
                      }
                      if (dataUrl && dataUrl.startsWith('data:')) {
                        recoveredEffects.set(effectType, dataUrl);
                        foundAnyEffect = true;
                        console.log('✅ Recovered effect from localStorage:', key);
                      }
                    }
                  }
                }
                
                // Also check if thumbnails exist in window.perkieEffects (restored from thumbnails backup)
                if (!foundAnyEffect) {
                  ['enhancedblackwhite', 'popart', 'dithering', 'color'].forEach(effectType => {
                    const effectKey = sessionKey + '_' + effectType;
                    const effectData = getPetEffect(effectKey);
                    if (effectData && effectData.startsWith('data:')) {
                      recoveredEffects.set(effectType, effectData);
                      foundAnyEffect = true;
                      console.log('✅ Found thumbnail for effect:', effectKey);
                    }
                  });
                }
                
                // Create pet with recovered effects or empty effects
                const petData = {
                  sessionKey,
                  name: petNamesMap[sessionKey],
                  effects: recoveredEffects,
                  hasNoEffects: !foundAnyEffect
                };
                
                orderedPets.push(petData);
                validSessionPets.push(sessionKey);
                
                if (!foundAnyEffect) {
                  console.log('❌ No effects found for pet - effects may have been lost during navigation');
                }
              }
            }
          });
          
          // Add any pets not in the list (for backwards compatibility)
          pets.forEach((pet, key) => {
            if (!processedPetsList.includes(key)) {
              orderedPets.push(pet);
              console.log('📌 Found pet not in session list:', key);
              // Update session to include this pet
              validSessionPets.push(key);
            }
          });
          
          // Update session with valid pets only
          if (validSessionPets.length !== processedPetsList.length) {
            console.log('🔧 Updating session with valid pets:', validSessionPets);
            try {
              for (let i = 0; i < possibleKeys.length; i++) {
                const sessionData = localStorage.getItem(possibleKeys[i]);
                if (sessionData) {
                  const parsed = JSON.parse(sessionData);
                  if (parsed.processedPets) {
                    parsed.processedPets = validSessionPets;
                    localStorage.setItem(possibleKeys[i], JSON.stringify(parsed));
                    console.log('✅ Updated session:', possibleKeys[i]);
                    break;
                  }
                }
              }
            } catch (e) {
              console.log('Failed to update session:', e);
            }
          }
          
          console.log('🐕 Returning', orderedPets.length, 'ordered pets from', processedPetsList.length, 'session pets');
          return orderedPets;
        }
        
        console.log('🐕 No session list, returning', pets.size, 'pets from effects map');
        return Array.from(pets.values());
      }
      
      // Extract readable pet name from session key
      function extractPetName(sessionKey) {
        // Remove file extension and technical data, keep readable part
        const parts = sessionKey.split('_');
        if (parts.length > 0) {
          let name = parts[0].replace(/\.[^/.]+$/, ""); // Remove extension
          name = name.replace(/[_-]/g, ' '); // Replace underscores/dashes with spaces
          return name.charAt(0).toUpperCase() + name.slice(1); // Capitalize
        }
        return 'My Pet';
      }
      
      // Render pet selection grid
      function renderPets(petData) {
        console.log('🐕 renderPets called with:', petData.length, 'pets', petData);

        const contentEl = document.getElementById(`pet-selector-content-${sectionId}`);
        const selectedEl = document.getElementById(`pet-selector-selected-${sectionId}`);
        const emptyEl = document.getElementById(`pet-selector-empty-${sectionId}`);
        const descriptionEl = document.getElementById(`pet-selector-description-${sectionId}`);

        // Defensive: Hide empty state only if element exists
        if (emptyEl) {
          emptyEl.style.display = 'none';
        }
        
        // Update header for pets state
        updateHeaderState(true);
        
        const petsHtml = `
          <div class="ks-pet-selector__pets">
            ${petData.map(pet => {
              // Use enhancedblackwhite as default, fallback to any available effect
              const defaultImage = pet.effects.get('enhancedblackwhite') || 
                                   pet.effects.get('color') || 
                                   pet.effects.values().next().value || 
                                   'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; // 1x1 transparent GIF fallback
              
              // Escape HTML to prevent XSS
              const escapedName = (pet.name || '').replace(/[<>"']/g, (char) => {
                const escapeMap = {'<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'};
                return escapeMap[char] || char;
              });
              const escapedKey = (pet.sessionKey || '').replace(/[<>"']/g, (char) => {
                const escapeMap = {'<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'};
                return escapeMap[char] || char;
              });
              
              return `
                <div class="ks-pet-selector__pet ${pet.hasNoEffects ? 'ks-pet-selector__pet--no-effects' : ''}" 
                     data-session-key="${escapedKey}"
                     data-pet-name="${escapedName}"
                     style="position: relative;">
                  ${pet.hasNoEffects ? `
                    <div class="ks-pet-selector__no-effects-notice" style="position: absolute; bottom: 0; left: 0; right: 0; background: rgba(255, 200, 0, 0.9); padding: 4px; text-align: center; font-size: 11px; color: #333;">
                      <span>⚠️ Please re-upload this pet</span>
                    </div>
                  ` : ''}
                  <button type="button" 
                          class="ks-pet-selector__delete-btn" 
                          data-delete-key="${escapedKey}"
                          aria-label="Remove ${escapedName} from collection"
                          style="position: absolute; top: 4px; right: 4px; background: rgba(108, 117, 125, 0.9); color: white; border: 2px solid white; border-radius: 50%; width: 32px; height: 32px; min-width: 32px; min-height: 32px; cursor: pointer; z-index: 25; font-size: 16px; font-weight: normal; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15); transform: scale(0.9); transition: all 0.2s ease;"
                          title="Remove ${escapedName}">✕</button>
                  <img src="${defaultImage || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'}" 
                       alt="${escapedName}" 
                       class="ks-pet-selector__pet-image"
                       data-no-track="true"
                       data-analytics-skip="true"
                       loading="lazy"
                       onerror="this.style.display='none'">
                  <div class="ks-pet-selector__pet-info">
                    <p class="ks-pet-selector__pet-name">${escapedName}</p>
                  </div>
                </div>
              `;
            }).join('')}
          </div>
        `;
        
        contentEl.innerHTML = petsHtml;
        contentEl.style.display = 'block';

        // Update pet counter after rendering
        if (typeof updatePetCounter === 'function') {
          updatePetCounter();
        }

        // Show edit button when pets exist
        if (petData.length > 0 && editButton) {
          editButton.style.display = 'inline-block';

          // Add edit button click handler (remove existing first)
          editButton.removeEventListener('click', toggleEditMode);
          editButton.addEventListener('click', toggleEditMode);
        } else if (editButton) {
          editButton.style.display = 'none';
          // Reset edit mode if no pets
          if (isEditMode) {
            toggleEditMode();
          }
        }
        
        // Add click handlers after DOM is created (safer than inline onclick)
        contentEl.querySelectorAll('.ks-pet-selector__pet').forEach(petEl => {
          petEl.addEventListener('click', function() {
            const sessionKey = this.getAttribute('data-session-key');
            const petName = this.getAttribute('data-pet-name');
            selectPet(sessionKey, petName);
          });
        });
        
        // Add delete button handlers with event stopping to prevent selection
        contentEl.querySelectorAll('.ks-pet-selector__delete-btn').forEach(deleteBtn => {
          deleteBtn.addEventListener('click', function(event) {
            event.stopPropagation(); // Critical: Prevent click from bubbling to parent
            event.preventDefault();
            const sessionKey = this.getAttribute('data-delete-key');
            if (sessionKey) {
              window.deletePet(sessionKey);
            }
          });
        });
        
        // Add mobile long-press detection for delete button
        setupMobileLongPress();
      }
      
      // Mobile long-press detection for delete button
      function setupMobileLongPress() {
        var longPressDelay = 500; // 500ms
        
        document.querySelectorAll('.ks-pet-selector__pet').forEach(function(petEl) {
          var longPressTimer = null;
          var touchStarted = false;
          
          // Long press start
          petEl.addEventListener('touchstart', function(e) {
            var element = this;
            touchStarted = true;
            
            // Only if not already showing delete
            if (!element.classList.contains('show-delete')) {
              longPressTimer = setTimeout(function() {
                if (touchStarted) {
                  element.classList.add('show-delete');
                  // Haptic feedback if available
                  if (navigator.vibrate) {
                    navigator.vibrate(50);
                  }
                }
              }, longPressDelay);
            }
          });
          
          // Cancel long press on touch end or move
          petEl.addEventListener('touchend', function(e) {
            touchStarted = false;
            if (longPressTimer) {
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }
          });
          
          petEl.addEventListener('touchmove', function(e) {
            touchStarted = false;
            if (longPressTimer) {
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }
          });
          
          petEl.addEventListener('touchcancel', function(e) {
            touchStarted = false;
            if (longPressTimer) {
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }
          });
        });
        
        // Hide delete buttons when clicking elsewhere
        document.addEventListener('touchstart', function(e) {
          if (!e.target.closest('.ks-pet-selector__pet') && !e.target.closest('.ks-pet-selector__delete-btn')) {
            document.querySelectorAll('.ks-pet-selector__pet.show-delete').forEach(function(el) {
              el.classList.remove('show-delete');
            });
          }
        });
      }
      
      // Delete a pet from the collection - COMPREHENSIVE VERSION
      window.deletePet = function(sessionKey) {
        // Get pet name for personalized confirmation
        var petElement = document.querySelector('[data-session-key="' + sessionKey + '"]');
        var petName = petElement ? petElement.getAttribute('data-pet-name') : 'this pet';
        
        if (confirm('Remove ' + petName + ' from your collection?')) {
          console.log('🗑️ Deleting pet:', sessionKey);
          
          // Show loading state
          var deleteButton = document.querySelector(`[data-delete-key="${sessionKey}"]`);
          if (deleteButton) {
            deleteButton.disabled = true;
            deleteButton.innerHTML = '⏳';
          }
          
          // Simple deletion using PetStorage
          if (window.PetStorage) {
            window.PetStorage.delete(sessionKey);
            console.log('✅ Deleted from PetStorage');
          }
          
          // Clean up display Map
          if (hasPetEffects()) {
            var keysToDelete = [];
            forEachPetEffect(function(value, key, extractedSessionKey) {
              if (extractedSessionKey === sessionKey || key === sessionKey) {
                keysToDelete.push(key);
              }
            });
            
            deletePetEffects(keysToDelete);
            console.log('✅ Cleaned up display Map');
          }
          
          // Immediately remove the pet card from DOM for instant feedback  
          var petCard = document.querySelector('[data-session-key="' + sessionKey + '"]');
          if (petCard) {
            // Animate removal
            petCard.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
            petCard.style.opacity = '0';
            petCard.style.transform = 'scale(0.8)';
            
            setTimeout(function() {
              // Remove from DOM
              if (petCard.parentNode) {
                petCard.parentNode.removeChild(petCard);
              }
              
              // Check if we need to show empty state
              var remainingPets = document.querySelectorAll('.ks-pet-selector__pet');
              if (remainingPets.length === 0) {
                var contentEl = document.getElementById('ks-pet-selector-content-' + sectionId);
                if (contentEl) {
                  contentEl.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">No pets saved yet. <a href="/pages/custom-image-processing">Add your first pet</a></div>';
                }
              }
              
              console.log('✅ Pet removed from UI successfully');
            }, 300);
          } else {
            console.error('Could not find pet card with session key:', sessionKey);
            // Fallback: reload all pets
            loadSavedPets();
          }
        }
      };
      
      // Track multiple pet selections  
      var selectedPetsData = [];
      
      // Edit mode state
      var isEditMode = false;
      var editButton = document.getElementById('pet-edit-btn-' + sectionId);
      var petSelectorContainer = document.getElementById('pet-selector-' + sectionId);
      
      // Toggle edit mode for pet deletion
      function toggleEditMode() {
        isEditMode = !isEditMode;
        
        // Update container class
        if (isEditMode) {
          petSelectorContainer.classList.add('edit-mode');
          editButton.textContent = 'Done';
          editButton.classList.add('edit-mode');
          
          // Hide selected pet info during edit
          var selectedEl = document.getElementById('pet-selector-selected-' + sectionId);
          if (selectedEl && selectedEl.style.display === 'block') {
            selectedEl.setAttribute('data-was-visible', 'true');
            selectedEl.style.display = 'none';
          }
        } else {
          petSelectorContainer.classList.remove('edit-mode');
          editButton.textContent = 'Edit';
          editButton.classList.remove('edit-mode');
          
          // Restore selected pet info
          var selectedEl = document.getElementById('pet-selector-selected-' + sectionId);
          if (selectedEl && selectedEl.getAttribute('data-was-visible') === 'true') {
            selectedEl.style.display = 'block';
            selectedEl.removeAttribute('data-was-visible');
          }
        }
        
        petSelectorContainer.setAttribute('data-edit-mode', isEditMode.toString());
      }
      
      // Calculate and update pricing based on selected pets
      function updatePetPricing() {
        var pricingContainer = document.getElementById('pet-pricing-' + sectionId);
        var basePriceEl = document.getElementById('base-price-' + sectionId);
        var feeElement = document.getElementById('pet-fee-display-' + sectionId);
        var totalElement = document.getElementById('total-price-' + sectionId);

        // MODIFIED: Use pet name count OR selected pet count, whichever is higher
        var selectedCount = selectedPetsData.length;
        var petNameInput = document.getElementById('pet-name-input-' + sectionId);
        var nameCount = 0;

        if (petNameInput && petNameInput.value.trim()) {
          var petNames = petNameInput.value.trim().split(',')
            .map(function(n) { return n.trim(); })
            .filter(function(n) { return n.length > 0; });
          nameCount = petNames.length;
        }

        // Use the higher of the two counts (in case user enters names before selecting pets)
        var effectiveCount = Math.max(selectedCount, nameCount);

        console.log('💰 updatePetPricing:', {
          selectedCount: selectedCount,
          nameCount: nameCount,
          effectiveCount: effectiveCount
        });

        var basePrice = parseFloat(petSelector.dataset.productPrice) / 100; // Convert from cents
        var additionalFee = 0;

        // Only show pricing when there's an additional charge (2+ pets)
        if (effectiveCount <= 1) {
          // Single pet or no pets - no additional fee, hide pricing entirely
          feeElement.style.display = 'none';
          additionalFee = 0;
        } else if (effectiveCount === 2) {
          additionalFee = 5.00;
          feeElement.textContent = '+ $5.00 (additional pet)';
          feeElement.style.display = 'inline';
        } else if (effectiveCount >= 3) {
          additionalFee = 10.00;
          feeElement.textContent = '+ $10.00 (2 additional pets)';
          feeElement.style.display = 'inline';
        } else {
          feeElement.style.display = 'none';
        }

        var total = basePrice + additionalFee;
        totalElement.textContent = '$' + total.toFixed(2);

        // Only show pricing when there's an additional charge (2+ pets)
        if (effectiveCount >= 2) {
          pricingContainer.style.display = 'block';

          // Apply compact layout for cleaner display
          pricingContainer.classList.add('multiple-pets');
          pricingContainer.classList.remove('single-pet');
        } else {
          // Hide pricing for 0 or 1 pet (no additional charge)
          pricingContainer.style.display = 'none';
          pricingContainer.classList.remove('single-pet', 'multiple-pets');
        }

        // Update product variant based on pet count (for actual fee charging)
        updateVariantForPetCount(effectiveCount);
      }
      
      // Automatically select the correct product variant based on pet count
      function updateVariantForPetCount(petCount) {
        console.log('🔥 updateVariantForPetCount called with:', petCount);
        
        // Prevent infinite loop when variant sync triggers pet selection
        if (window.variantSyncDisabled) {
          console.log('⏸️ Variant update skipped (sync in progress)');
          return;
        }
        console.log('✅ Sync lock check passed');
        
        console.log('🔄 Updating variant for pet count:', petCount);
        
        // Determine target variant text based on pet count
        var targetVariantText = '';
        if (petCount === 0 || petCount === 1) {
          targetVariantText = '1 Pet';
        } else if (petCount === 2) {
          targetVariantText = '2 Pets';
        } else if (petCount >= 3) {
          targetVariantText = '3 Pets';
        }
        
        console.log('🎯 Looking for variant:', targetVariantText);
        
        // Method 1: Work with Shopify's variant-selects custom element
        var variantSelectsElement = document.querySelector('variant-selects');
        if (variantSelectsElement) {
          console.log('📦 Found variant-selects element');
          
          // Find the radio input for pet variants
          var variantRadios = variantSelectsElement.querySelectorAll('input[type="radio"]');
          var found = false;
          
          variantRadios.forEach(function(radio) {
            var label = variantSelectsElement.querySelector('label[for="' + radio.id + '"]');
            if (label) {
              var labelText = label.textContent.trim();
              console.log('  Checking radio label:', labelText);
              
              // Check if label starts with target text (handles "Variant sold out" suffix)
              // Also handle exact match for normal cases
              var labelLower = labelText.toLowerCase();
              var targetLower = targetVariantText.toLowerCase();
              
              if (labelLower === targetLower || labelLower.indexOf(targetLower) === 0) {
                console.log('  ✅ Found matching variant radio:', labelText);
                radio.checked = true;
                radio.click(); // Use click to ensure all handlers fire
                radio.dispatchEvent(new Event('change', { bubbles: true }));
                found = true;
              }
            }
          });
          
          if (found) {
            console.log('✅ Variant updated via variant-selects element');
            return;
          }
        }
        
        // Method 2: Try option-based variant selection (Dawn theme pattern)
        var optionSelects = document.querySelectorAll('.product-form__input select');
        optionSelects.forEach(function(select) {
          var options = select.querySelectorAll('option');
          options.forEach(function(option) {
            var optionText = option.textContent.trim();
            var optionLower = optionText.toLowerCase();
            var targetLower = targetVariantText.toLowerCase();
            
            if (optionLower === targetLower || optionLower.indexOf(targetLower) === 0) {
              console.log('✅ Found matching option:', optionText);
              select.value = option.value;
              select.dispatchEvent(new Event('change', { bubbles: true }));
              
              // Also trigger on the form if needed
              var form = select.closest('form');
              if (form) {
                form.dispatchEvent(new Event('change', { bubbles: true }));
              }
            }
          });
        });
        
        // Method 3: Direct variant ID selection fallback
        var variantIdSelectors = document.querySelectorAll('select[name="id"], input[name="id"][type="radio"]');
        variantIdSelectors.forEach(function(selector) {
          if (selector.tagName === 'SELECT') {
            var options = selector.querySelectorAll('option');
            options.forEach(function(option) {
              if (option.textContent.toLowerCase().includes(targetVariantText.toLowerCase())) {
                selector.value = option.value;
                selector.dispatchEvent(new Event('change', { bubbles: true }));
                console.log('✅ Updated via direct variant select');
              }
            });
          } else if (selector.type === 'radio') {
            var label = document.querySelector('label[for="' + selector.id + '"]');
            if (label && label.textContent.toLowerCase().includes(targetVariantText.toLowerCase())) {
              selector.checked = true;
              selector.click();
              console.log('✅ Updated via direct variant radio');
            }
          }
        });
        
        // Log what we found for debugging
        console.log('🔍 Variant selection complete for:', targetVariantText);
      }
      
      // Expose function globally for debugging and external calls
      window.updateVariantForPetCount = updateVariantForPetCount;
      
      // Initialize variant-to-pet synchronization
      function initVariantPetSync() {
        // Find all variant selectors (radio buttons and select elements)
        // Look for radio buttons in the product form that control pet variants
        var variantSelectors = document.querySelectorAll(
          'input[type="radio"][id*="Pet"], fieldset input[type="radio"]'
        );
        
        variantSelectors.forEach(function(selector) {
          selector.addEventListener('change', function() {
            handleVariantSelectionChange(this);
          });
        });
        
        console.log('✅ Variant-to-pet sync initialized with ' + variantSelectors.length + ' selectors');
      }
      
      // Handle variant selection and update pet selection accordingly
      function handleVariantSelectionChange(variantElement) {
        var variantText = '';
        
        // Handle different input types
        if (variantElement.tagName === 'SELECT') {
          var selectedOption = variantElement.options[variantElement.selectedIndex];
          variantText = selectedOption ? selectedOption.textContent.toLowerCase() : '';
        } else if (variantElement.type === 'radio' && variantElement.checked) {
          var label = document.querySelector('label[for="' + variantElement.id + '"]');
          variantText = label ? label.textContent.toLowerCase() : '';
        }
        
        // Extract pet count from variant text
        var targetPetCount = 1; // Default to 1 pet
        if (variantText.includes('2 pet')) {
          targetPetCount = 2;
        } else if (variantText.includes('3 pet')) {
          targetPetCount = 3;
        }
        
        console.log('Variant changed to:', variantText, '→ Target pet count:', targetPetCount);
        
        // Update pet selection to match variant
        updatePetSelectionForVariant(targetPetCount);
      }
      
      // Update pet selection to match the selected variant
      function updatePetSelectionForVariant(targetCount) {
        var currentCount = selectedPetsData.length;
        
        // No change needed
        if (currentCount === targetCount) {
          console.log('✅ Pet selection already matches variant (' + targetCount + ' pets)');
          return;
        }
        
        console.log('Updating pet selection from', currentCount, 'to', targetCount, 'pets');
        
        // Need to select more pets
        if (currentCount < targetCount) {
          selectAdditionalPets(targetCount - currentCount);
        }
        
        // Need to deselect pets  
        if (currentCount > targetCount) {
          deselectExcessPets(currentCount - targetCount);
        }
      }
      
      // Automatically select additional pets to reach target count
      function selectAdditionalPets(additionalCount) {
        var availablePets = document.querySelectorAll('.ks-pet-selector__pet:not(.selected):not(.ks-pet-selector__pet--no-effects)');
        var petsToSelect = Math.min(additionalCount, availablePets.length);
        
        for (var i = 0; i < petsToSelect; i++) {
          var petElement = availablePets[i];
          var sessionKey = petElement.getAttribute('data-session-key');
          var petName = petElement.getAttribute('data-pet-name') || 'Pet';
          
          if (sessionKey) {
            // Temporarily disable variant updates to prevent recursion
            window.variantSyncDisabled = true;
            selectPet(sessionKey, petName);
            window.variantSyncDisabled = false;
          }
        }
        
        // Show message if not enough pets available
        if (petsToSelect < additionalCount) {
          var shortfall = additionalCount - petsToSelect;
          showPetSelectionMessage('Need ' + shortfall + ' more pet(s). Please add more pets in the Pet Processor.');
        }
      }
      
      // Automatically deselect excess pets to reach target count
      function deselectExcessPets(excessCount) {
        var selectedPets = document.querySelectorAll('.ks-pet-selector__pet.selected');
        
        // Deselect from the end of the list (LIFO - last selected first)
        for (var i = selectedPets.length - 1; i >= selectedPets.length - excessCount && i >= 0; i--) {
          var petElement = selectedPets[i];
          var sessionKey = petElement.getAttribute('data-session-key');
          var petName = petElement.getAttribute('data-pet-name') || 'Pet';
          
          if (sessionKey) {
            // Temporarily disable variant updates to prevent recursion
            window.variantSyncDisabled = true;
            selectPet(sessionKey, petName); // This will deselect since pet is already selected
            window.variantSyncDisabled = false;
          }
        }
      }
      
      // Show user feedback for pet selection changes
      function showPetSelectionMessage(message) {
        var messageEl = document.getElementById('pet-selection-message-' + sectionId);
        
        if (!messageEl) {
          messageEl = document.createElement('div');
          messageEl.id = 'pet-selection-message-' + sectionId;
          messageEl.className = 'pet-selection-message';
          messageEl.style.cssText = 'padding: 8px 12px; background: #f0f8ff; border: 1px solid #4a90e2; border-radius: 4px; margin: 8px 0; font-size: 14px; color: #2c5aa0;';
          
          var petSelector = document.getElementById('pet-selector-' + sectionId);
          if (petSelector) {
            petSelector.appendChild(messageEl);
          }
        }
        
        messageEl.textContent = message;
        messageEl.style.display = 'block';
        
        // Auto-hide after 4 seconds
        setTimeout(function() {
          if (messageEl) {
            messageEl.style.display = 'none';
          }
        }, 4000);
      }
      
      // Select a pet and update UI (supports multiple selection)
      const selectPet = function(sessionKey, petName) {
        const maxPets = parseInt(petSelector.dataset.maxPets) || 3;
        const selectedPetEl = document.querySelector(`[data-session-key="${sessionKey}"]`);
        
        // Check if this pet has no effects
        if (selectedPetEl && selectedPetEl.classList.contains('ks-pet-selector__pet--no-effects')) {
          console.log('Cannot select pet without effects:', sessionKey);
          alert('This pet\'s effects were lost. Please reprocess the pet in the Pet Processor.');
          return;
        }
        
        // Check if this pet is already selected
        const existingIndex = selectedPetsData.findIndex(p => p.sessionKey === sessionKey);
        
        if (existingIndex !== -1) {
          // Deselect if already selected
          selectedPetsData.splice(existingIndex, 1);
          if (selectedPetEl) {
            selectedPetEl.classList.remove('selected');
            selectedPetEl.querySelector('.ks-pet-selector__selected-badge')?.remove();
          }
        } else {
          // Check if we've reached max pets
          if (selectedPetsData.length >= maxPets) {
            alert(`You can select up to ${maxPets} pets per product.`);
            return;
          }
          
          // Add to selection
          var petData = {
            sessionKey: sessionKey,
            name: petName,  // Changed from petName to name for consistency
            petName: petName,  // Keep both for backward compatibility
            effects: {}
          };
          
          // Get all effects for this pet
          if (hasPetEffects()) {
            forEachPetEffect(function(imageUrl, key, extractedSessionKey, effect) {
              if (extractedSessionKey === sessionKey && effect) {
                petData.effects[effect] = imageUrl;
              }
            });
          }
          
          // Set processedImage and originalImage from effects
          // Note: enhancedblackwhite is the actual key, not just blackwhite
          petData.originalImage = petData.effects.original || petData.effects.enhancedblackwhite || '';
          petData.processedImage = petData.effects.enhancedblackwhite || petData.effects.popart || petData.effects.dithering || petData.effects['8bit'] || petData.effects.original || '';
          petData.effect = petData.effects.enhancedblackwhite ? 'enhancedblackwhite' : 
                          petData.effects.popart ? 'popart' : 
                          petData.effects.dithering ? 'dithering' : 
                          petData.effects['8bit'] ? '8bit' : 'original';
          
          selectedPetsData.push(petData);
          
          // Mark as selected
          if (selectedPetEl) {
            selectedPetEl.classList.add('selected');
            const badge = document.createElement('div');
            badge.className = 'ks-pet-selector__selected-badge';
            badge.textContent = selectedPetsData.length;
            selectedPetEl.appendChild(badge);
          }
        }
        
        // Update displayed pet names
        updateSelectedDisplay();
        
        // Update pricing
        updatePetPricing();
        
        // Store for external access
        selectedPetData = selectedPetsData.length === 1 ? selectedPetsData[0] : selectedPetsData;
        
        // Dispatch selection event for cart integration
        var petDataForCart = selectedPetsData.length > 0 ? {
          // Pass ALL pet names comma-separated for multi-pet support
          name: selectedPetsData.map(function(pet) { return pet.name; }).join(','),
          processedImage: selectedPetsData[0].processedImage,
          effect: selectedPetsData[0].effect,
          originalImage: selectedPetsData[0].originalImage,

          // NEW: Add GCS URLs and artist notes from PetStorage metadata
          sessionKey: selectedPetsData[0].sessionKey,
          gcsUrl: (function() {
            if (window.PetStorage) {
              var metadata = window.PetStorage.getMetadata(selectedPetsData[0].sessionKey);
              return metadata ? metadata.gcsUrl : '';
            }
            return '';
          })(),
          originalUrl: (function() {
            if (window.PetStorage) {
              var metadata = window.PetStorage.getMetadata(selectedPetsData[0].sessionKey);
              return metadata ? metadata.originalUrl : '';
            }
            return '';
          })(),
          artistNote: (function() {
            if (window.PetStorage) {
              var metadata = window.PetStorage.getMetadata(selectedPetsData[0].sessionKey);
              return metadata ? metadata.artistNote : '';
            }
            return '';
          })(),

          // Include full array for multi-pet support
          pets: selectedPetsData,
          totalFee: selectedPetsData.length > 1 ? (selectedPetsData.length === 2 ? 5 : 10) : 0
        } : null;
        
        // Dispatch with correct event name for cart integration
        if (petDataForCart) {
          var event = new CustomEvent('pet:selected', {
            detail: petDataForCart
          });
          document.dispatchEvent(event);
          console.log('Pet selected for cart integration:', petDataForCart);
        } else if (selectedPetsData.length === 0) {
          // Dispatch pet:removed when no pets selected
          var removeEvent = new CustomEvent('pet:removed', {
            detail: {}
          });
          document.dispatchEvent(removeEvent);
          console.log('All pets deselected');
        }
        
        console.log('Pets selected:', selectedPetsData);
      };
      
      // Update selected pet display
      function updateSelectedDisplay() {
        const selectedEl = document.getElementById(`pet-selector-selected-${sectionId}`);
        const petNameEl = document.getElementById(`selected-pet-name-${sectionId}`);

        if (selectedPetsData.length > 0) {
          if (petNameEl) {
            const petNames = selectedPetsData.map(p => p.petName).join(', ');
            const petText = selectedPetsData.length === 1
              ? `${petNames} selected`
              : `${selectedPetsData.length} pets: ${petNames}`;
            petNameEl.textContent = petText;
          }
          selectedEl.style.display = 'block';
        } else {
          selectedEl.style.display = 'none';
        }

        // Update pet counter display
        updatePetCounter();
      }

      // Update pet counter UI showing X/Y pets selected (mobile-optimized inline version)
      function updatePetCounter() {
        const maxPets = parseInt(petSelector.dataset.maxPets) || 1;
        const currentCount = selectedPetsData.length;

        // Only show counter if multiple pets are allowed
        if (maxPets <= 1) {
          // Remove counter if it exists
          const existingCounter = document.getElementById(`pet-counter-${sectionId}`);
          if (existingCounter) {
            existingCounter.remove();
          }
          return;
        }

        // Find or create title group wrapper and counter
        const headerTop = document.querySelector(`#pet-selector-header-${sectionId} .ks-pet-selector__header-top`);
        const title = headerTop?.querySelector('.ks-pet-selector__title');

        if (!title) return;

        // Create title group wrapper if it doesn't exist
        let titleGroup = headerTop.querySelector('.ks-pet-selector__title-group');
        if (!titleGroup) {
          titleGroup = document.createElement('div');
          titleGroup.className = 'ks-pet-selector__title-group';

          // Wrap title in the group
          title.parentElement.insertBefore(titleGroup, title);
          titleGroup.appendChild(title);
        }

        // Find or create counter within title group
        let counterEl = titleGroup.querySelector('.ks-pet-selector__counter-inline');
        if (!counterEl) {
          counterEl = document.createElement('div');
          counterEl.id = `pet-counter-${sectionId}`;
          counterEl.className = 'ks-pet-selector__counter-inline';
          titleGroup.appendChild(counterEl);
        }

        // Update counter content with ARIA labels for accessibility
        counterEl.innerHTML = `
          <span class="counter-text"
                aria-label="Pet selection progress: ${currentCount} of ${maxPets} pets selected">
            (${currentCount}/${maxPets})
          </span>
        `;

        // Update add button state if exists
        const addButton = document.querySelector('.ks-pet-selector__add-btn');
        if (addButton) {
          if (currentCount >= maxPets) {
            addButton.disabled = true;
            addButton.textContent = maxPets === 1 ? 'Pet Selected' : 'Maximum Pets Reached';
          } else {
            addButton.disabled = false;
            addButton.textContent = 'Add Another Pet';
          }
        }
      }
      
      // Initialize when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initPetSelector);
      } else {
        initPetSelector();
      }
      
      // Save effects when page becomes hidden (user navigating away)
      document.addEventListener('visibilitychange', function() {
        if (document.visibilityState === 'hidden') {
          saveEffectsToLocalStorage();
        }
      });
      
      // Save effects before page unload
      window.addEventListener('beforeunload', function() {
        saveEffectsToLocalStorage();
      });
      
      // Export for external access
      window.petSelectorInstances = window.petSelectorInstances || {};
      window.petSelectorInstances[sectionId] = {
        getSelectedPet: () => selectedPetData,
        refresh: loadSavedPets,
        saveEffectsToLocalStorage: saveEffectsToLocalStorage,
        restoreEffectsFromLocalStorage: restoreEffectsFromLocalStorage
      };
      
    })();
  </script>
  
  {% comment %} Social Sharing Script - Removed: Should only load on pet processor page, not product pages
  <script src="{{ 'pet-social-sharing.js' | asset_url }}" defer></script>
  {% endcomment %}

  {% comment %} Quick Upload Handler - Express Checkout (Scenario 3) {% endcomment %}
  <script src="{{ 'quick-upload-handler.js' | asset_url }}" defer></script>

  {% comment %} Returning Customer Toggle Script {% endcomment %}
  <script>
  (function() {
    'use strict';

    document.addEventListener('DOMContentLoaded', function() {
      var checkbox = document.querySelector('[data-returning-toggle]');
      var fields = document.getElementById('repeat-customer-fields-{{ section.id }}');
      var orderTypeField = document.getElementById('order-type-{{ section.id }}');

      if (checkbox && fields) {
        checkbox.addEventListener('change', function() {
          fields.style.display = checkbox.checked ? 'block' : 'none';
          if (orderTypeField) {
            orderTypeField.value = checkbox.checked ? 'returning' : 'standard';
          }

          // Fire event to trigger cart-pet-integration.js
          var orderNumberInput = document.getElementById('previous-order-{{ section.id }}');
          var eventName = checkbox.checked ? 'returning-customer:selected' : 'returning-customer:deselected';

          var returningEvent = new CustomEvent(eventName, {
            detail: {
              isReturning: checkbox.checked,
              orderType: checkbox.checked ? 'returning' : 'standard',
              previousOrderNumber: orderNumberInput ? orderNumberInput.value : '',
              sectionId: '{{ section.id }}'
            }
          });
          document.dispatchEvent(returningEvent);
          console.log('🔔 Returning customer:', eventName, checkbox.checked);
        });

        // Listen for order number changes
        var orderNumberInput = document.getElementById('previous-order-{{ section.id }}');
        if (orderNumberInput) {
          orderNumberInput.addEventListener('input', function() {
            if (checkbox.checked) {
              var updateEvent = new CustomEvent('returning-customer:updated', {
                detail: {
                  isReturning: true,
                  orderType: 'returning',
                  previousOrderNumber: orderNumberInput.value,
                  sectionId: '{{ section.id }}'
                }
              });
              document.dispatchEvent(updateEvent);
            }
          });
        }
      }
    });
  })();
  </script>

{% endif %}
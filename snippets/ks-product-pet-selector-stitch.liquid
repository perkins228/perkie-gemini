{% comment %}
  Pet Selector - Stitch UI Pattern
  Simplified, modern pet selector based on Stitch reference design
  Max 3 pets, global style/font selection, per-pet upload
{% endcomment %}

{% comment %} Get max pets from product metafield (default: 1) {% endcomment %}
{% assign max_pets_from_metafield = product.metafields.custom.max_pets | default: 1 %}
{% assign max_pets_per_product = max_pets_from_metafield | plus: 0 %}

{% comment %} Ensure max_pets is within valid range (1-3) {% endcomment %}
{% if max_pets_per_product < 1 %}
  {% assign max_pets_per_product = 1 %}
{% elsif max_pets_per_product > 3 %}
  {% assign max_pets_per_product = 3 %}
{% endif %}

{% comment %} Only show for products with "custom" tag {% endcomment %}
{% assign has_custom_tag = false %}
{% for tag in product.tags %}
  {% if tag contains 'custom' or tag contains 'Custom' or tag contains 'CUSTOM' %}
    {% assign has_custom_tag = true %}
    {% break %}
  {% endif %}
{% endfor %}

{% if has_custom_tag %}
<div class="pet-selector-stitch"
     data-max-pets="{{ max_pets_per_product }}"
     data-product-id="{{ product.id }}"
     style="--pet-selector-primary: {{ scheme_button }}; --pet-selector-primary-text: {{ scheme_button_label }}; --pet-selector-text: {{ scheme_text }}; --pet-selector-background: {{ scheme_background }};">


  {% comment %} Pet Count Selector {% endcomment %}
  <div class="pet-selector__section">
    <h2 class="pet-selector__section-heading">Number of Pets</h2>
    <div class="pet-selector__count-grid">
      {% for i in (1..max_pets_per_product) %}
      <label class="pet-count-btn">
        <span>{{ i }}</span>
        <input type="radio"
               name="pet-count"
               value="{{ i }}"
               data-pet-count-radio>
      </label>
      {% endfor %}
    </div>
  </div>

  {% comment %} Pet Details Section {% endcomment %}
  <div class="pet-selector__section">
    <h2 class="pet-selector__section-heading">Pet Details</h2>

    {% comment %} Dynamic pet sections (1-3 based on selection) - All hidden initially {% endcomment %}
    <div class="pet-details-container" data-pet-details-container>
      {% for i in (1..3) %}
      <div class="pet-detail"
           data-pet-index="{{ i }}"
           style="display: none;">

        {% comment %} Combined Pet Section - Name and Photo together {% endcomment %}
        <div class="pet-detail__section pet-detail__combined-section">
          {% comment %} Pet's Name {% endcomment %}
          <div class="pet-detail__name-group">
            <h4 class="pet-detail__section-heading">
              {% if i == 1 %}Pet's Name{% else %}Pet {{ i }}'s Name{% endif %}
            </h4>
            <input type="text"
                   class="pet-detail__name-input"
                   name="properties[Pet {{ i }} Name]"
                   placeholder="Enter name"
                   data-pet-name-input="{{ i }}">
          </div>

          {% comment %} Pet's Photo {% endcomment %}
          <div class="pet-detail__photo-group">
            <h4 class="pet-detail__section-heading">
              Pet's Photo
            </h4>

            <div class="pet-detail__image-actions">
              <div class="pet-detail__upload-row">
                <button type="button"
                        class="pet-detail__upload-btn"
                        data-pet-upload-btn="{{ i }}">
                  Upload
                </button>

                {% comment %} Use Existing Print checkbox next to Upload button {% endcomment %}
                <label class="pet-detail__checkbox-label">
                  <input type="checkbox"
                         class="pet-detail__checkbox"
                         data-existing-print-checkbox="{{ i }}">
                  <span>Use Existing Perkie Print</span>
                </label>
              </div>

              {% comment %} Native Shopify file upload - files uploaded to CDN on form submit {% endcomment %}
              <input type="file"
                     name="properties[Pet {{ i }} Images]"
                     accept="image/*"
                     multiple
                     style="display: none;"
                     data-pet-file-input="{{ i }}"
                     data-max-files="3"
                     aria-label="Upload pet {{ i }} photo(s)">

              {% comment %} File upload status - shown after files selected {% endcomment %}
              <div class="pet-detail__upload-status"
                   data-upload-status="{{ i }}"
                   style="display: none;"></div>

              <button type="button"
                      class="pet-detail__preview-btn"
                      data-pet-preview-btn="{{ i }}"
                      style="opacity: 0; visibility: hidden;">
                Preview
              </button>
            </div>
          </div>
        </div>

        <div class="pet-detail__order-input"
             data-order-number-input="{{ i }}"
             style="display: none;">
          <input type="text"
                 class="pet-detail__order-number"
                 placeholder="Enter previous order number"
                 name="properties[Pet {{ i }} Order Number]"
                 data-order-number-field="{{ i }}">
        </div>

      </div>
      {% endfor %}
    </div>
  </div>

  {% comment %} Style Selector {% endcomment %}
  <div class="pet-selector__section">
    <h2 class="pet-selector__section-heading">Choose Style</h2>
    <div class="style-selector__grid">

      {% comment %} B&W Style {% endcomment %}
      <label class="style-card">
        <input type="radio"
               name="properties[Style]"
               value="enhancedblackwhite"
               data-style-radio="enhancedblackwhite">
        <div class="style-card__content">
          <div class="style-card__image-wrapper">
            {% if block.settings.style_preview_bw != blank %}
              <img src="{{ block.settings.style_preview_bw | image_url: width: 320 }}"
                   alt="Black & White style preview"
                   class="style-card__image">
            {% else %}
              <img src="{{ 'pet-bw-preview.jpg' | asset_url }}"
                   alt="Black & White style preview"
                   class="style-card__image">
            {% endif %}
          </div>
          <p class="style-card__label">Black & White</p>
        </div>
        {% comment %}
        <div class="style-card__tooltip">
          A striking black and white conversion that highlights your pet's features.
        </div>
        {% endcomment %}
      </label>

      {% comment %} Color Style {% endcomment %}
      <label class="style-card">
        <input type="radio"
               name="properties[Style]"
               value="color"
               data-style-radio="color">
        <div class="style-card__content">
          <div class="style-card__image-wrapper">
            {% if block.settings.style_preview_color != blank %}
              <img src="{{ block.settings.style_preview_color | image_url: width: 320 }}"
                   alt="Color style preview"
                   class="style-card__image">
            {% else %}
              <img src="{{ 'pet-color-preview.jpg' | asset_url }}"
                   alt="Color style preview"
                   class="style-card__image">
            {% endif %}
          </div>
          <p class="style-card__label">Color</p>
        </div>
        {% comment %}
        <div class="style-card__tooltip">
          Your pet's photo is used as is, preserving the original colors and lighting.
        </div>
        {% endcomment %}
      </label>

      {% comment %} Modern (Ink Wash) Style {% endcomment %}
      <label class="style-card">
        <input type="radio"
               name="properties[Style]"
               value="modern"
               data-style-radio="modern">
        <div class="style-card__content">
          <div class="style-card__image-wrapper">
            {% if block.settings.style_preview_modern != blank %}
              <img src="{{ block.settings.style_preview_modern | image_url: width: 320 }}"
                   alt="Modern style preview"
                   class="style-card__image">
            {% else %}
              <img src="{{ 'pet-modern-preview.jpg' | asset_url }}"
                   alt="Modern style preview"
                   class="style-card__image">
            {% endif %}
          </div>
          <p class="style-card__label">Modern</p>
        </div>
        {% comment %}
        <div class="style-card__tooltip">
          A clean, contemporary Asian ink wash style with flowing brushstrokes.
        </div>
        {% endcomment %}
      </label>

      {% comment %} Sketch (Pen & Marker) Style {% endcomment %}
      <label class="style-card">
        <input type="radio"
               name="properties[Style]"
               value="sketch"
               data-style-radio="sketch">
        <div class="style-card__content">
          <div class="style-card__image-wrapper">
            {% if block.settings.style_preview_sketch != blank %}
              <img src="{{ block.settings.style_preview_sketch | image_url: width: 320 }}"
                   alt="Sketch style preview"
                   class="style-card__image">
            {% else %}
              <img src="{{ 'pet-sketch-preview.jpg' | asset_url }}"
                   alt="Sketch style preview"
                   class="style-card__image">
            {% endif %}
          </div>
          <p class="style-card__label">Sketch</p>
        </div>
        {% comment %}
        <div class="style-card__tooltip">
          Contemporary pen and marker illustration with bold lines and vibrant colors.
        </div>
        {% endcomment %}
      </label>

    </div>
  </div>

  {% comment %} Font Selector - Only show if product supports font styles {% endcomment %}
  {% if product.metafields.custom.supports_font_styles == true %}
  <div class="pet-selector__section">
    <h2 class="pet-selector__section-heading">Choose Font</h2>
    <div class="font-selector__grid">

      {% comment %} No Text Option {% endcomment %}
      <label class="font-card">
        <input type="radio"
               name="properties[Font]"
               value="no-text"
               data-font-radio="no-text">
        <div class="font-card__content">
          <p class="font-card__title">No Text</p>
          <div class="font-card__preview font-card__preview--icon">
            <svg class="font-card__no-text-icon" viewBox="0 0 24 24">
              <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
            </svg>
          </div>
        </div>
      </label>

      {% comment %} Preppy Font (with borders) {% endcomment %}
      <label class="font-card">
        <input type="radio"
               name="properties[Font]"
               value="preppy"
               data-font-radio="preppy">
        <div class="font-card__content">
          <p class="font-card__title">Preppy</p>
          <p class="font-card__preview font-card__preview--preppy" data-font-preview>
            <span class="font-preview-text"></span>
          </p>
        </div>
      </label>

      {% comment %} Classic Font {% endcomment %}
      <label class="font-card">
        <input type="radio"
               name="properties[Font]"
               value="classic"
               data-font-radio="classic">
        <div class="font-card__content">
          <p class="font-card__title">Classic</p>
          <p class="font-card__preview font-card__preview--classic" data-font-preview>
            <span class="font-preview-text"></span>
          </p>
        </div>
      </label>

      {% comment %} Playful Font {% endcomment %}
      <label class="font-card">
        <input type="radio"
               name="properties[Font]"
               value="playful"
               data-font-radio="playful">
        <div class="font-card__content">
          <p class="font-card__title">Playful</p>
          <p class="font-card__preview font-card__preview--playful" data-font-preview>
            <span class="font-preview-text"></span>
          </p>
        </div>
      </label>

      {% comment %} Elegant Font {% endcomment %}
      <label class="font-card">
        <input type="radio"
               name="properties[Font]"
               value="elegant"
               data-font-radio="elegant">
        <div class="font-card__content">
          <p class="font-card__title">Elegant</p>
          <p class="font-card__preview font-card__preview--elegant" data-font-preview>
            <span class="font-preview-text"></span>
          </p>
        </div>
      </label>

      {% comment %} Trend Font {% endcomment %}
      <label class="font-card">
        <input type="radio"
               name="properties[Font]"
               value="trend"
               data-font-radio="trend">
        <div class="font-card__content">
          <p class="font-card__title">Trend</p>
          <p class="font-card__preview font-card__preview--trend" data-font-preview>
            <span class="font-preview-text"></span>
          </p>
        </div>
      </label>

    </div>
  </div>
  {% endif %}

  {% comment %} Hidden order properties for upload tracking {% endcomment %}
  {% for i in (1..3) %}
    <input type="hidden" id="order-type-{{ i }}" name="properties[Pet {{ i }} Order Type]" value="">
    <input type="hidden" id="processing-state-{{ i }}" name="properties[Pet {{ i }} Processing State]" value="">
    <input type="hidden" id="upload-timestamp-{{ i }}" name="properties[Pet {{ i }} Upload Timestamp]" value="">
  {% endfor %}

</div>

{% comment %} Get color scheme from block settings {% endcomment %}
{% assign scheme_id = block.settings.color_scheme | default: 'scheme-1' %}
{% assign scheme = settings.color_schemes[scheme_id].settings %}

{% comment %} Extract color values with fallbacks {% endcomment %}
{% assign scheme_background = scheme.background | default: '#ffffff' %}
{% assign scheme_text = scheme.text | default: '#000000' %}
{% assign scheme_button = scheme.button | default: '#ebff7a' %}
{% assign scheme_button_label = scheme.button_label | default: '#461312' %}

<style>
/* Google Fonts Import for Font Selector */
@import url('https://fonts.googleapis.com/css2?family=Graduate&family=Merriweather:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Rampart+One&family=Ms+Madi&family=Fascinate&display=swap');

/* Pet Selector - Stitch Pattern Styles */
/* Color variables set via inline style on container for instant theme editor updates */

.pet-selector-stitch {
  /* Theme color variables are set via inline style attribute above */
  /* Static gray scale variables defined here */
  --pet-selector-gray-50: #f9fafb;
  --pet-selector-gray-100: #f3f4f6;
  --pet-selector-gray-200: #e5e7eb;
  --pet-selector-gray-300: #d1d5db;
  --pet-selector-gray-400: #9ca3af;
  --pet-selector-gray-500: #6b7280;
  --pet-selector-gray-600: #4b5563;
  --pet-selector-gray-700: #374151;
  --pet-selector-gray-800: #1f2937;
  --pet-selector-gray-900: #111827;
}

.pet-selector-stitch {
  max-width: 960px;
  margin: 0 auto;
  padding: 1rem 1rem 1rem 0;
  color: var(--pet-selector-text);
}

.pet-selector__section {
  margin-bottom: 1rem;
  padding: 1.5rem;
  border: 1px solid var(--pet-selector-gray-200);
  border-radius: 0.75rem;
  background-color: var(--pet-selector-background);
}

/* Unified section heading style - all section headers use this */
.pet-selector__section-heading {
  font-size: 1.125rem;
  font-weight: 700;
  color: var(--pet-selector-text);
  margin: 0 0 0.75rem 0;
  line-height: 1.3;
}

/* DEPRECATED: Use .pet-selector__section-heading instead */
.pet-selector__label {
  display: block;
  font-size: 1.125rem;
  font-weight: 700;
  color: var(--pet-selector-text);
  margin-bottom: 0.75rem;
}

/* DEPRECATED: Use .pet-selector__section-heading instead */
.pet-selector__heading {
  font-size: 1.375rem;
  font-weight: 700;
  color: var(--pet-selector-text);
  margin: 0 0 1.5rem 0;
}

/* Pet Count Selector */
.pet-selector__count-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 0.5rem;
}

.pet-count-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 3.5rem;
  cursor: pointer;
  border-radius: 0.5rem;
  background-color: var(--pet-selector-gray-100);
  color: var(--pet-selector-gray-500);
  font-size: 1rem;
  font-weight: 600;
  transition: all 0.2s;
  border: 2px solid transparent;
}

.pet-count-btn input {
  position: absolute;
  opacity: 0;
  width: 0;
  height: 0;
}

.pet-count-btn--active,
.pet-count-btn:has(input:checked) {
  background-color: var(--pet-selector-background);
  color: var(--pet-selector-text);
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  border-color: #ff5964;
}

/* Pet Details */
.pet-details-container {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.pet-detail {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.pet-detail__name-input {
  width: 100%;
  height: 3rem;
  padding: 0 0.75rem;
  border: 1px solid var(--pet-selector-gray-300);
  border-radius: 0;
  font-size: 0.875rem;
  color: var(--pet-selector-text);
  background-color: var(--pet-selector-background);
}

.pet-detail__name-input:focus {
  outline: none;
  border-color: #ff5964;
  box-shadow: 0 0 0 2px rgba(255, 89, 100, 0.2);
}

.pet-detail__upload-btn,
.pet-detail__preview-btn {
  position: relative;
  width: 100%;
  max-width: 300px;
  height: 3rem;
  padding: 0 1.25rem;
  margin: 0 auto;
  background-color: var(--pet-selector-gray-100);
  border: none;
  border-radius: 40px;
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--pet-selector-gray-700);
  cursor: pointer;
  transition: background-color 0.2s;
}

.pet-detail__upload-btn:hover,
.pet-detail__preview-btn:hover {
  background-color: var(--pet-selector-gray-200);
}

.pet-detail__file-input {
  position: absolute;
  inset: 0;
  opacity: 0;
  cursor: pointer;
}

.pet-detail__checkbox-row {
  margin-top: 0.5rem;
}

.pet-detail__checkbox-label {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  cursor: pointer;
  font-size: 0.875rem;
  font-weight: 500;
  color: var(--pet-selector-gray-700);
}

.pet-detail__checkbox {
  width: 1rem;
  height: 1rem;
  accent-color: #ff5964;
}

.pet-detail__order-input {
  margin-top: 0.5rem;
}

.pet-detail__order-number {
  width: 100%;
  height: 3rem;
  padding: 0 0.75rem;
  border: 1px solid var(--pet-selector-gray-300);
  border-radius: 0;
  font-size: 0.875rem;
  color: var(--pet-selector-text);
  background-color: var(--pet-selector-background);
}

.pet-detail__order-number:focus {
  outline: none;
  border-color: #ff5964;
  box-shadow: 0 0 0 2px rgba(255, 89, 100, 0.2);
}

/* Style Selector */
.style-selector__grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 1rem;
}

@media (min-width: 640px) {
  .style-selector__grid {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (min-width: 1024px) {
  .style-selector__grid {
    grid-template-columns: repeat(4, 1fr);
  }
}

.style-card {
  position: relative;
  cursor: pointer;
  display: block;
}

.style-card input {
  position: absolute;
  opacity: 0;
  width: 0;
  height: 0;
}

.style-card__content {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  width: 100%;
}

.style-card--active .style-card__content .style-card__image-wrapper,
.style-card:has(input:checked) .style-card__content .style-card__image-wrapper {
  border-color: #ff5964;
}

.style-card__image-wrapper {
  position: relative;
  width: 100%;
  aspect-ratio: 1;
  border: 2px solid transparent;
  border-radius: 0.5rem;
  overflow: hidden;
  transition: all 0.2s;
}

.style-card__image {
  width: 100%;
  height: 100%;
  object-fit: cover;
  transition: opacity 0.2s, filter 0.2s;
}

/* Gray-out non-selected styles */
.style-card:not(.style-card--active):not(:has(input:checked)) .style-card__image {
  opacity: 0.5;
  filter: grayscale(30%);
}

.style-card:not(.style-card--active):not(:has(input:checked)) .style-card__label {
  opacity: 0.6;
}

/* Restore full color/opacity on hover */
.style-card:not(.style-card--active):not(:has(input:checked)):hover .style-card__image {
  opacity: 0.8;
  filter: grayscale(0%);
}

.style-card:not(.style-card--active):not(:has(input:checked)):hover .style-card__label {
  opacity: 1;
}

.style-card__label {
  font-size: 0.875rem;
  font-weight: 600;
  color: #000000;
  text-align: center;
  margin: 0;
  padding: 0;
  transition: opacity 0.2s;
}

/* Tooltip styles commented out
.style-card__tooltip {
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  margin-bottom: 0.5rem;
  padding: 0.5rem 0.75rem;
  background-color: #ffffff;
  color: #000000;
  font-size: 0.875rem;
  border-radius: 0.375rem;
  border: 1px solid #e5e7eb;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s;
  max-width: 16rem;
  white-space: normal;
}

.style-card:hover .style-card__tooltip {
  opacity: 1;
}
*/

/* Font Selector */
.font-selector__grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 1rem;
}

@media (min-width: 640px) {
  .font-selector__grid {
    grid-template-columns: repeat(3, 1fr);
  }
}

@media (min-width: 1024px) {
  .font-selector__grid {
    grid-template-columns: repeat(3, 1fr);
  }
}

.font-card {
  cursor: pointer;
  display: block;
}

.font-card input {
  position: absolute;
  opacity: 0;
  width: 0;
  height: 0;
}

.font-card__content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
  padding: 1rem;
  background-color: var(--pet-selector-background);
  border: 1px solid var(--pet-selector-gray-200);
  border-radius: 0.5rem;
  transition: all 0.2s;
  min-height: 7rem;
}

.font-card--active .font-card__content,
.font-card:has(input:checked) .font-card__content {
  border-color: #ff5964;
  box-shadow: 0 0 0 2px rgba(255, 89, 100, 0.3);
}

.font-card__title {
  font-size: 1rem;
  font-weight: 600;
  color: var(--pet-selector-gray-800);
  margin: 0;
}

.font-card__preview {
  font-size: 1.5rem;
  color: var(--pet-selector-gray-500);
  margin: 0;
  text-align: center;
  overflow: hidden;
  text-overflow: ellipsis;
}

.font-card__preview--icon {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 2.25rem;
}

.font-card__no-text-icon {
  width: 2rem;
  height: 2rem;
  fill: var(--pet-selector-gray-400);
}

/* Font-specific styles */
.font-card__preview--preppy {
  font-family: 'Graduate', serif;
  text-decoration: underline overline;
  text-decoration-color: rgba(0, 0, 0, 0.5);
  text-decoration-thickness: 2px;
  text-underline-offset: 4px;
}

.font-card__preview--classic {
  font-family: 'Merriweather', serif;
}

.font-card__preview--playful {
  font-family: 'Rampart One', cursive;
}

.font-card__preview--elegant {
  font-family: 'Ms Madi', 'Sacramento', cursive;
}

.font-card__preview--trend {
  font-family: 'Fascinate', 'Rampart One', cursive;
}

/* === Pet Detail Section Containers === */

/* Base section styling for combined pet section */
.pet-detail__section {
  margin-bottom: 0.5rem;
  padding: 1rem;
  border-radius: 0.5rem;
  background-color: var(--pet-selector-background);
  border: 1px solid var(--pet-selector-gray-100);
}

/* Combined section contains both name and photo */
.pet-detail__combined-section {
  /* Uses base .pet-detail__section styles */
}

/* Name group within combined section */
.pet-detail__name-group {
  margin-bottom: 1rem;        /* Space between name and photo groups */
}

/* Photo group within combined section */
.pet-detail__photo-group {
  /* No additional styling needed */
}

/* Section headings (not bold) */
.pet-detail__section-heading {
  font-size: 1.125rem;        /* 18px */
  font-weight: 400;           /* Normal weight (not bold) */
  color: var(--pet-selector-text);
  margin: 0 0 0.75rem 0;      /* 12px bottom spacing */
  line-height: 1.3;
}

/* Image actions container (vertical stack layout) */
.pet-detail__image-actions {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.75rem;               /* 12px between elements */
}

/* Upload row - Upload button + checkbox side by side */
.pet-detail__upload-row {
  display: flex;
  align-items: center;
  gap: 0.75rem;               /* 12px between button and checkbox */
  width: 100%;
  max-width: 300px;
}

/* Upload button when in row with checkbox - narrower width */
.pet-detail__upload-row .pet-detail__upload-btn {
  width: auto;                /* Auto width instead of 100% */
  margin: 0;                  /* Remove auto centering */
  flex-shrink: 0;             /* Don't shrink */
}

/* Checkbox label when in upload row */
.pet-detail__upload-row .pet-detail__checkbox-label {
  font-size: 0.8125rem;       /* Slightly smaller text */
  white-space: nowrap;        /* Prevent wrapping */
  flex-shrink: 1;             /* Allow shrinking if needed */
}

/* === Preview Button Progressive Disclosure === */

/* Preview button - hidden until files uploaded */
.pet-detail__preview-btn {
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0.3s;
}

.pet-detail__preview-btn.visible {
  opacity: 1;
  visibility: visible;
}

/* Upload button with uploads indicator */
.pet-detail__upload-btn.has-uploads {
  background-color: #22c55e;
  color: white;
  font-weight: 600;
}

.pet-detail__upload-btn.has-uploads:hover {
  background-color: #16a34a;
}

/* Upload status display below pet name */
.pet-detail__upload-status {
  width: 100%;
  max-width: 300px;
  margin: 0 auto;
  padding: 0.5rem;
  background-color: #f0fdf4;
  border-radius: 0.5rem;
  border: 1px solid #86efac;
}

.pet-detail__upload-status__file {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.25rem 0;
  font-size: 0.8125rem;
  color: #166534;
}

.pet-detail__upload-status__file-icon {
  flex-shrink: 0;
  font-size: 1rem;
}

.pet-detail__upload-status__file-name {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  font-weight: 500;
}

.pet-detail__upload-status__file-size {
  flex-shrink: 0;
  color: #16a34a;
  font-size: 0.75rem;
}

.pet-detail__upload-status__file-delete {
  flex-shrink: 0;

  /* VISUAL SIZE: Keep 24px for design consistency */
  width: 1.5rem;        /* 24px */
  height: 1.5rem;       /* 24px */

  /* Enable pseudo-element positioning */
  position: relative;

  /* Visual styling (unchanged) */
  border-radius: 50%;
  border: 1px solid #dc2626;
  background-color: white;
  color: #dc2626;
  font-size: 1rem;
  line-height: 1;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
  padding: 0;

  /* INCREASED SPACING: More room for fat-finger taps */
  margin-left: 0.75rem;  /* Was 0.25rem, now 0.75rem */

  /* Touch device optimization */
  -webkit-tap-highlight-color: rgba(220, 38, 38, 0.2);
  touch-action: manipulation;  /* Prevents double-tap zoom */
}

/* INVISIBLE TAP AREA EXPANSION: 44√ó44px for accessibility */
.pet-detail__upload-status__file-delete::before {
  content: '';
  position: absolute;

  /* CENTER the 44√ó44px tap area over 24√ó24px button */
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);

  /* MINIMUM TOUCH TARGET: 44√ó44px (WCAG 2.1 AAA) */
  width: 2.75rem;   /* 44px */
  height: 2.75rem;  /* 44px */

  /* Make it tappable but invisible */
  border-radius: 50%;

  /* DEBUG: Uncomment to visualize tap area during development */
  /* background-color: rgba(220, 38, 38, 0.1); */
  /* border: 1px dashed #dc2626; */
}

/* HOVER STATE: Desktop only (not touch devices) */
@media (hover: hover) and (pointer: fine) {
  .pet-detail__upload-status__file-delete:hover {
    background-color: #dc2626;
    color: white;
    transform: scale(1.1);
  }
}

/* ACTIVE STATE: Enhanced for touch devices */
.pet-detail__upload-status__file-delete:active {
  transform: scale(0.95);
  background-color: #dc2626;
  color: white;

  /* Haptic feedback hint (Safari iOS) */
  -webkit-tap-highlight-color: rgba(220, 38, 38, 0.4);
}

/* FOCUS STATE: Keyboard accessibility */
.pet-detail__upload-status__file-delete:focus {
  outline: 2px solid #dc2626;
  outline-offset: 2px;
}

/* MOBILE-SPECIFIC: Extra spacing on small screens */
@media (max-width: 640px) {
  .pet-detail__upload-status__file-delete {
    margin-left: 1rem;  /* Even more space on mobile */
  }
}

/* Processor Modal Styles */
.pet-processor-modal {
  position: fixed;
  inset: 0;
  z-index: 10000;
  display: flex;
  align-items: center;
  justify-content: center;
}

.pet-processor-modal__overlay {
  position: absolute;
  inset: 0;
  background-color: rgba(0, 0, 0, 0.75);
  backdrop-filter: blur(4px);
}

.pet-processor-modal__content {
  position: relative;
  width: 95%;
  max-width: 1200px;
  height: 90vh;
  background-color: white;
  border-radius: 1rem;
  box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.pet-processor-modal__close {
  position: absolute;
  top: 1rem;
  right: 1rem;
  width: 3rem;
  height: 3rem;
  border-radius: 50%;
  border: none;
  background-color: rgba(0, 0, 0, 0.5);
  color: white;
  font-size: 2rem;
  line-height: 1;
  cursor: pointer;
  transition: all 0.2s;
  z-index: 10;
  display: flex;
  align-items: center;
  justify-content: center;
}

.pet-processor-modal__close:hover {
  background-color: rgba(0, 0, 0, 0.8);
  transform: scale(1.1);
}

.pet-processor-modal__header {
  padding: 2rem;
  border-bottom: 1px solid var(--pet-selector-gray-200);
  background-color: var(--pet-selector-background);
}

.pet-processor-modal__header h2 {
  margin: 0 0 0.5rem 0;
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--pet-selector-text);
}

.pet-processor-modal__header p {
  margin: 0;
  font-size: 0.875rem;
  color: var(--pet-selector-gray-600);
}

.pet-processor-modal__body {
  flex: 1;
  overflow: hidden;
  background-color: var(--pet-selector-gray-50);
}

.pet-processor-modal__iframe {
  width: 100%;
  height: 100%;
  border: none;
}

/* Mobile Responsiveness */
@media (max-width: 639px) {
  .pet-processor-modal__content {
    width: 100%;
    height: 100vh;
    max-width: none;
    border-radius: 0;
  }

  .pet-processor-modal__header {
    padding: 1.5rem 1rem;
  }

  .pet-processor-modal__close {
    top: 0.5rem;
    right: 0.5rem;
    width: 2.5rem;
    height: 2.5rem;
    font-size: 1.5rem;
  }
}
</style>

<script>
// Pet Selector Stitch - JavaScript
(function() {
  const container = document.querySelector('.pet-selector-stitch');
  if (!container) return;

  const maxPets = parseInt(container.dataset.maxPets) || 1;
  const petDetailsContainer = container.querySelector('[data-pet-details-container]');
  const countRadios = container.querySelectorAll('[data-pet-count-radio]');
  const fontPreviews = container.querySelectorAll('[data-font-preview]');

  // Update visible pet sections based on count
  function updatePetSections(count) {
    const petDetails = petDetailsContainer.querySelectorAll('.pet-detail');
    petDetails.forEach((detail, index) => {
      if (index < count) {
        detail.style.display = '';
      } else {
        detail.style.display = 'none';
      }
    });

    // Update pet count buttons
    const countBtns = container.querySelectorAll('.pet-count-btn');
    countBtns.forEach((btn) => {
      btn.classList.remove('pet-count-btn--active');
      if (btn.querySelector('input').checked) {
        btn.classList.add('pet-count-btn--active');
      }
    });

    updateFontPreviews();
  }

  // Update font previews with ampersand formatting (matches old font-selector)
  function updateFontPreviews() {
    const visiblePets = [...petDetailsContainer.querySelectorAll('.pet-detail')]
      .filter(detail => detail.style.display !== 'none');

    const petNames = visiblePets.map(detail => {
      const input = detail.querySelector('[data-pet-name-input]');
      return input.value.trim() || `Pet ${detail.dataset.petIndex}`;
    });

    // Format names with ampersand logic (matches PetNameFormatter)
    let previewText = '';
    if (petNames.length === 0) {
      previewText = '';
    } else if (petNames.length === 1) {
      previewText = petNames[0];
    } else if (petNames.length === 2) {
      // 2 pets: "Sam & Buddy"
      previewText = petNames[0] + ' & ' + petNames[1];
    } else {
      // 3+ pets: "Sam, Buddy & Max" (no Oxford comma)
      const lastPet = petNames[petNames.length - 1];
      const otherPets = petNames.slice(0, -1);
      previewText = otherPets.join(', ') + ' & ' + lastPet;
    }

    fontPreviews.forEach(preview => {
      const textSpan = preview.querySelector('.font-preview-text');
      if (textSpan) {
        textSpan.textContent = previewText;
      }
    });
  }

  // Pet count change listener
  countRadios.forEach(radio => {
    radio.addEventListener('change', (e) => {
      const count = parseInt(e.target.value);
      updatePetSections(count);
      savePetSelectorStateImmediate(); // Save immediately on selection
    });
  });

  // Pet name input listeners
  const nameInputs = container.querySelectorAll('[data-pet-name-input]');
  nameInputs.forEach(input => {
    input.addEventListener('input', () => {
      updateFontPreviews();
      savePetSelectorState(); // Save with debounce on typing
    });
  });

  // Existing Perkie Print checkbox listeners
  for (let i = 1; i <= 3; i++) {
    const checkbox = container.querySelector(`[data-existing-print-checkbox="${i}"]`);
    const orderInput = container.querySelector(`[data-order-number-input="${i}"]`);

    if (checkbox && orderInput) {
      checkbox.addEventListener('change', () => {
        orderInput.style.display = checkbox.checked ? '' : 'none';
      });
    }
  }

  // Style card click handler
  const styleCards = container.querySelectorAll('.style-card');
  styleCards.forEach(card => {
    card.addEventListener('click', () => {
      styleCards.forEach(c => c.classList.remove('style-card--active'));
      card.classList.add('style-card--active');
      savePetSelectorStateImmediate(); // Save immediately on selection
    });
  });

  // Font card click handler
  const fontCards = container.querySelectorAll('.font-card');
  fontCards.forEach(card => {
    card.addEventListener('click', () => {
      fontCards.forEach(c => c.classList.remove('font-card--active'));
      card.classList.add('font-card--active');
      savePetSelectorStateImmediate(); // Save immediately on selection
    });
  });

  // Upload button handlers - Native Shopify file upload (files uploaded to CDN)
  // Track uploaded files per pet (persistent across multiple uploads)
  const petFiles = {
    1: [],
    2: [],
    3: []
  };

  for (let i = 1; i <= 3; i++) {
    const uploadBtn = container.querySelector(`[data-pet-upload-btn="${i}"]`);
    const fileInput = container.querySelector(`[data-pet-file-input="${i}"]`);

    if (uploadBtn && fileInput) {
      const maxFiles = parseInt(fileInput.dataset.maxFiles) || 3;

      // Click upload button triggers file input
      uploadBtn.addEventListener('click', (e) => {
        e.preventDefault();
        fileInput.click();
      });

      // Handle file selection (additive - doesn't replace existing files)
      fileInput.addEventListener('change', (e) => {
        const newFiles = Array.from(e.target.files);

        // Validation 1: File count
        if (newFiles.length === 0) {
          return; // User cancelled
        }

        // Check if adding new files would exceed max
        const currentCount = petFiles[i].length;
        const totalCount = currentCount + newFiles.length;

        if (totalCount > maxFiles) {
          alert(`You can only upload ${maxFiles} photo(s) total for this pet. You already have ${currentCount} file(s).`);
          fileInput.value = ''; // Clear selection
          return;
        }

        // Validation 2: File size (max 50MB per Shopify)
        for (let j = 0; j < newFiles.length; j++) {
          if (newFiles[j].size > 50 * 1024 * 1024) {
            alert(`${newFiles[j].name} is too large. Max 50MB per file.`);
            fileInput.value = '';
            return;
          }
        }

        // Validation 3: File type (must be image)
        for (let j = 0; j < newFiles.length; j++) {
          if (!newFiles[j].type.startsWith('image/')) {
            alert(`${newFiles[j].name} is not an image file. Please select JPG, PNG, or HEIC.`);
            fileInput.value = '';
            return;
          }
        }

        // Validation 4: Check for duplicates
        let duplicatesSkipped = 0;
        const filesToAdd = [];

        for (let j = 0; j < newFiles.length; j++) {
          const isDuplicate = petFiles[i].some(existingFile =>
            existingFile.name === newFiles[j].name && existingFile.size === newFiles[j].size
          );

          if (!isDuplicate) {
            filesToAdd.push(newFiles[j]);
          } else {
            duplicatesSkipped++;
          }
        }

        if (duplicatesSkipped > 0) {
          alert(`${duplicatesSkipped} duplicate file(s) skipped.`);
        }

        // Add new files to persistent storage
        petFiles[i].push(...filesToAdd);

        // Clear file input to allow re-uploading same files if deleted
        fileInput.value = '';

        // All validations passed - update UI
        const count = petFiles[i].length;
        uploadBtn.textContent = `Upload (${count}/${maxFiles})`;
        uploadBtn.classList.add('has-uploads');

        // Show uploaded file names below pet name
        displayUploadedFiles(i, petFiles[i]);

        // Populate order properties and update file input with all files
        updateFileInputWithAllFiles(i, petFiles[i]);
        populateOrderProperties(i, petFiles[i]);

        // Save state after file upload
        savePetSelectorStateImmediate();

        // Show Preview button now that files are uploaded
        previewBtn.classList.add('visible');

        // Store first file in localStorage for preview modal
        if (petFiles[i].length > 0) {
          const reader = new FileReader();
          reader.onload = (event) => {
            const previewData = [{
              name: petFiles[i][0].name,
              data: event.target.result, // Base64 for preview only
              size: petFiles[i][0].size,
              type: petFiles[i][0].type
            }];
            localStorage.setItem(`pet_${i}_images`, JSON.stringify(previewData));
          };
          reader.readAsDataURL(petFiles[i][0]);

          // NEW: Save complete file metadata (all files, no base64)
          const fileMetadata = petFiles[i].map(file => ({
            name: file.name,
            size: file.size,
            type: file.type
          }));
          localStorage.setItem(`pet_${i}_file_metadata`, JSON.stringify(fileMetadata));
          console.log(`üíæ Saved ${fileMetadata.length} file metadata entries for Pet ${i}`);
        }
      });

      // Display uploaded file names with sizes and delete buttons
      function displayUploadedFiles(petIndex, files) {
        const statusContainer = container.querySelector(`[data-upload-status="${petIndex}"]`);
        if (!statusContainer) return;

        if (files.length === 0) {
          statusContainer.style.display = 'none';
          statusContainer.innerHTML = '';
          return;
        }

        // Build HTML for file list
        let html = '';
        for (let j = 0; j < files.length; j++) {
          const fileName = files[j].name;
          const fileSize = formatFileSize(files[j].size);

          html += `
            <div class="pet-detail__upload-status__file" data-file-index="${j}">
              <span class="pet-detail__upload-status__file-icon">‚úì</span>
              <span class="pet-detail__upload-status__file-name">${escapeHtml(fileName)}</span>
              <span class="pet-detail__upload-status__file-size">${fileSize}</span>
              <button type="button"
                      class="pet-detail__upload-status__file-delete"
                      data-pet-index="${petIndex}"
                      data-file-index="${j}"
                      aria-label="Delete ${escapeHtml(fileName)}">√ó</button>
            </div>
          `;
        }

        statusContainer.innerHTML = html;
        statusContainer.style.display = 'block';

        // Attach delete button handlers
        const deleteButtons = statusContainer.querySelectorAll('.pet-detail__upload-status__file-delete');
        deleteButtons.forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            const petIdx = parseInt(btn.dataset.petIndex);
            const fileIdx = parseInt(btn.dataset.fileIndex);
            removeFile(petIdx, fileIdx);
          });
        });
      }

      // Remove a file from the uploaded files list
      function removeFile(petIndex, fileIndex) {
        // Remove from petFiles array
        if (fileIndex < 0 || fileIndex >= petFiles[petIndex].length) {
          return;
        }

        petFiles[petIndex].splice(fileIndex, 1);

        // Update UI
        const count = petFiles[petIndex].length;
        if (count === 0) {
          uploadBtn.textContent = 'Upload';
          uploadBtn.classList.remove('has-uploads');
        } else {
          uploadBtn.textContent = `Upload (${count}/${maxFiles})`;
        }

        // Re-render file list
        displayUploadedFiles(petIndex, petFiles[petIndex]);

        // Update file input with remaining files
        updateFileInputWithAllFiles(petIndex, petFiles[petIndex]);
        populateOrderProperties(petIndex, petFiles[petIndex]);

        // Save state after file deletion
        savePetSelectorStateImmediate();

        // Update preview if first file was removed
        if (petFiles[petIndex].length > 0) {
          const reader = new FileReader();
          reader.onload = (event) => {
            const previewData = [{
              name: petFiles[petIndex][0].name,
              data: event.target.result,
              size: petFiles[petIndex][0].size,
              type: petFiles[petIndex][0].type
            }];
            localStorage.setItem(`pet_${petIndex}_images`, JSON.stringify(previewData));
          };
          reader.readAsDataURL(petFiles[petIndex][0]);

          // NEW: Update file metadata in localStorage after deletion
          const fileMetadata = petFiles[petIndex].map(file => ({
            name: file.name,
            size: file.size,
            type: file.type
          }));
          localStorage.setItem(`pet_${petIndex}_file_metadata`, JSON.stringify(fileMetadata));
          console.log(`üíæ Updated metadata after deletion: ${fileMetadata.length} files for Pet ${petIndex}`);
        } else {
          localStorage.removeItem(`pet_${petIndex}_images`);
          // NEW: Remove metadata when no files remain
          localStorage.removeItem(`pet_${petIndex}_file_metadata`);
          console.log(`üóëÔ∏è Removed metadata for Pet ${petIndex} (no files remaining)`);

          // Hide Preview button when all files are deleted
          previewBtn.classList.remove('visible');
        }
      }

      // Update file input with all current files using DataTransfer API
      function updateFileInputWithAllFiles(petIndex, files) {
        const fileInput = container.querySelector(`[data-pet-file-input="${petIndex}"]`);
        if (!fileInput) return;

        try {
          // Check if DataTransfer is supported
          const dataTransfer = new DataTransfer();

          // Add all files to DataTransfer
          for (let j = 0; j < files.length; j++) {
            dataTransfer.items.add(files[j]);
          }

          // Update file input with new FileList
          fileInput.files = dataTransfer.files;
        } catch (e) {
          console.warn('DataTransfer API not supported, file input may not update correctly:', e);
        }
      }

      // Format file size for display
      function formatFileSize(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
      }

      // Escape HTML to prevent XSS
      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      // Populate hidden order properties for tracking
      function populateOrderProperties(petIndex, files) {
        const orderTypeField = document.getElementById(`order-type-${petIndex}`);
        const processingStateField = document.getElementById(`processing-state-${petIndex}`);
        const uploadTimestampField = document.getElementById(`upload-timestamp-${petIndex}`);

        if (orderTypeField) {
          orderTypeField.value = 'express_upload';
        }

        if (processingStateField) {
          processingStateField.value = 'uploaded_only';
        }

        if (uploadTimestampField) {
          uploadTimestampField.value = new Date().toISOString();
        }

        // Note: Shopify file input automatically handles the file upload when form submits
        // Files are attached to properties[Pet X Images] and uploaded to Shopify CDN
      }
    }
  }

  // Preview button handlers - Show modal with image processor
  for (let i = 1; i <= 3; i++) {
    const previewBtn = container.querySelector(`[data-pet-preview-btn="${i}"]`);

    if (previewBtn) {
      previewBtn.addEventListener('click', (e) => {
        e.preventDefault();

        // Get uploaded images for this pet
        const storedImages = localStorage.getItem(`pet_${i}_images`);
        const images = storedImages ? JSON.parse(storedImages) : [];

        if (images.length === 0) {
          alert('Please upload at least one image first');
          return;
        }

        // Open modal with first image and processor
        openProcessorModal(images[0].data, i);
      });
    }
  }

  // Create and show processor modal
  function openProcessorModal(imageDataUrl, petIndex) {
    // Image data already stored in localStorage by file upload handler (line 1273)
    // Store return URL and scroll position for back navigation
    sessionStorage.setItem('pet_selector_return_url', window.location.href);
    sessionStorage.setItem('pet_selector_scroll_position', window.scrollY.toString());

    // Store which pet index user clicked Preview on (for multiple pet handling)
    sessionStorage.setItem('pet_selector_active_index', petIndex.toString());

    // Navigate to processor page - it will read from localStorage automatically
    window.location.href = '/pages/custom-image-processing#processor';
  }

  // === STATE PERSISTENCE MODULE ===
  // Saves and restores pet selector state across page navigation

  /**
   * Get current product ID from container
   */
  function getProductId() {
    // Try to get from URL first
    const urlMatch = window.location.pathname.match(/\/products\/[^\/]+/);
    if (urlMatch) {
      // Use URL as product identifier (more reliable than dataset)
      return urlMatch[0];
    }
    // Fallback to timestamp-based key (per-session)
    return 'current';
  }

  /**
   * Collect current pet selector state
   * @returns {Object} Serializable state object
   */
  function collectPetSelectorState() {
    const productId = getProductId();

    // Get current pet count
    const selectedCountRadio = container.querySelector('[data-pet-count-radio]:checked');
    const petCount = selectedCountRadio ? parseInt(selectedCountRadio.value) : 0;

    // Collect per-pet data
    const pets = {};
    for (let i = 1; i <= 3; i++) {
      const nameInput = container.querySelector(`[data-pet-name-input="${i}"]`);

      if (nameInput) {
        pets[i] = {
          name: nameInput.value.trim(),
          fileCount: (petFiles[i] || []).length
        };
      }
    }

    // Get global selections
    const selectedStyle = container.querySelector('[data-style-radio]:checked');
    const selectedFont = container.querySelector('[data-font-radio]:checked');

    return {
      productId: productId,
      timestamp: Date.now(),
      petCount: petCount,
      pets: pets,
      style: selectedStyle ? selectedStyle.value : '',
      font: selectedFont ? selectedFont.value : ''
    };
  }

  let saveStateTimer;

  /**
   * Save pet selector state to localStorage (debounced)
   */
  function savePetSelectorState() {
    clearTimeout(saveStateTimer);

    saveStateTimer = setTimeout(() => {
      try {
        const state = collectPetSelectorState();
        const key = `perkie_pet_selector_${state.productId}`;

        localStorage.setItem(key, JSON.stringify(state));
        console.log('üíæ Saved pet selector state');
      } catch (error) {
        console.error('‚ùå Failed to save state:', error);

        if (error.name === 'QuotaExceededError') {
          cleanupOldPetSelectorStates();
        }
      }
    }, 300); // 300ms debounce
  }

  /**
   * Save state immediately (no debounce)
   */
  function savePetSelectorStateImmediate() {
    try {
      const state = collectPetSelectorState();
      const key = `perkie_pet_selector_${state.productId}`;

      localStorage.setItem(key, JSON.stringify(state));
      console.log('üíæ Saved pet selector state (immediate)');
    } catch (error) {
      console.error('‚ùå Failed to save state:', error);
    }
  }

  /**
   * Clean up old pet selector states (7+ days old)
   */
  function cleanupOldPetSelectorStates() {
    try {
      const keys = Object.keys(localStorage);
      const petSelectorKeys = keys.filter(k => k.startsWith('perkie_pet_selector_'));
      const MAX_AGE = 7 * 24 * 60 * 60 * 1000; // 7 days

      petSelectorKeys.forEach(key => {
        try {
          const state = JSON.parse(localStorage.getItem(key));
          const age = Date.now() - (state.timestamp || 0);

          if (age > MAX_AGE) {
            localStorage.removeItem(key);
            console.log('üßπ Cleaned up old state:', key);
          }
        } catch (e) {
          localStorage.removeItem(key);
        }
      });
    } catch (error) {
      console.error('‚ùå Cleanup failed:', error);
    }
  }

  /**
   * Load pet selector state from localStorage
   * @returns {Object|null} State object or null if not found/invalid
   */
  function loadPetSelectorState() {
    try {
      const productId = getProductId();
      const key = `perkie_pet_selector_${productId}`;
      const stored = localStorage.getItem(key);

      if (!stored) {
        console.log('üîç No saved state found');
        return null;
      }

      const state = JSON.parse(stored);

      // Check expiration (24 hours)
      const age = Date.now() - (state.timestamp || 0);
      const MAX_AGE = 24 * 60 * 60 * 1000;

      if (age > MAX_AGE) {
        console.log('‚è∞ State expired, clearing');
        localStorage.removeItem(key);
        return null;
      }

      // Validate structure
      if (!state || typeof state.petCount !== 'number' || !state.pets) {
        console.warn('‚ö†Ô∏è Invalid state structure');
        localStorage.removeItem(key);
        return null;
      }

      console.log('‚úÖ Loaded valid state');
      return state;

    } catch (error) {
      console.error('‚ùå Failed to load state:', error);
      return null;
    }
  }

  /**
   * Apply state to UI elements
   * @param {Object} state - State object to apply
   */
  function applyStateToUI(state) {
    try {
      console.log('üîÑ Restoring pet selector state...');

      // 1. Restore pet count
      if (state.petCount > 0) {
        const countRadio = container.querySelector(`[data-pet-count-radio][value="${state.petCount}"]`);
        if (countRadio) {
          countRadio.checked = true;
          updatePetSections(state.petCount);
        }
      }

      // 2. Restore per-pet data
      for (const [index, pet] of Object.entries(state.pets)) {
        const i = parseInt(index);

        // Restore name
        const nameInput = container.querySelector(`[data-pet-name-input="${i}"]`);
        if (nameInput && pet.name) {
          nameInput.value = pet.name;
        }

        // Restore upload button state
        if (pet.fileCount > 0) {
          const uploadBtn = container.querySelector(`[data-pet-upload-btn="${i}"]`);
          const fileInput = container.querySelector(`[data-pet-file-input="${i}"]`);

          if (uploadBtn && fileInput) {
            const maxFiles = parseInt(fileInput.dataset.maxFiles) || 3;
            uploadBtn.textContent = `Upload (${pet.fileCount}/${maxFiles})`;
            uploadBtn.classList.add('has-uploads');

            // NEW: Restore from file metadata (complete list, not just preview)
            const storedMetadata = localStorage.getItem(`pet_${i}_file_metadata`);
            if (storedMetadata) {
              try {
                const fileMetadata = JSON.parse(storedMetadata);

                // Reconstruct petFiles array with mock File objects for UI display
                // Note: These are not real File objects (can't be re-uploaded)
                // but have enough data (.name, .size, .type) for UI display
                petFiles[i] = fileMetadata.map(meta => ({
                  name: meta.name,
                  size: meta.size,
                  type: meta.type
                }));

                // Display files in UI (will now show all files, not just first)
                displayUploadedFiles(i, petFiles[i]);

                // Show Preview button since files were restored
                const previewBtn = container.querySelector(`[data-pet-preview-btn="${i}"]`);
                if (previewBtn) {
                  previewBtn.classList.add('visible');
                }

                console.log(`‚úÖ Restored ${petFiles[i].length} files for Pet ${i} from metadata`);
              } catch (error) {
                console.error(`‚ùå Failed to restore files for Pet ${i}:`, error);
              }
            }
          }
        }
      }

      // 3. Restore style selection
      if (state.style) {
        const styleRadio = container.querySelector(`[data-style-radio="${state.style}"]`);
        if (styleRadio) {
          styleRadio.checked = true;

          const styleCard = styleRadio.closest('.style-card');
          if (styleCard) {
            container.querySelectorAll('.style-card').forEach(c => c.classList.remove('style-card--active'));
            styleCard.classList.add('style-card--active');
          }
        }
      }

      // 4. Restore font selection
      if (state.font) {
        const fontRadio = container.querySelector(`[data-font-radio="${state.font}"]`);
        if (fontRadio) {
          fontRadio.checked = true;

          const fontCard = fontRadio.closest('.font-card');
          if (fontCard) {
            container.querySelectorAll('.font-card').forEach(c => c.classList.remove('font-card--active'));
            fontCard.classList.add('font-card--active');
          }
        }
      }

      // 5. Update font previews
      updateFontPreviews();

      // 6. Check if user returned from processor
      const returnUrl = sessionStorage.getItem('pet_selector_return_url');
      if (returnUrl === window.location.href) {
        // Restore scroll position
        const scrollPos = parseInt(sessionStorage.getItem('pet_selector_scroll_position') || '0');
        setTimeout(() => window.scrollTo(0, scrollPos), 100);

        // Clear markers
        sessionStorage.removeItem('pet_selector_return_url');
        sessionStorage.removeItem('pet_selector_scroll_position');

        console.log('üîô User returned from processor');
      }

      console.log('‚úÖ State restoration complete');

    } catch (error) {
      console.error('‚ùå Failed to restore state:', error);
    }
  }

  /**
   * Restore state on page load
   */
  function restorePetSelectorState() {
    const state = loadPetSelectorState();
    if (state) {
      applyStateToUI(state);
    }
  }

  // === END STATE PERSISTENCE MODULE ===

  // Initialize - No default selections
  // User must actively select pet count, style, and font
  // Pet sections remain hidden until count is selected

  // CRITICAL: Setup form submission handler
  // Move file inputs into form before submission so Shopify can process them
  setupFormSubmitHandler();

  function setupFormSubmitHandler() {
    // Find the product form (cart add form)
    const form = container.closest('form[action*="/cart/add"]');
    if (!form) {
      console.warn('Pet Selector: Could not find cart form');
      return;
    }

    form.addEventListener('submit', function(e) {
      // Move all file inputs INTO the form before submission
      // This is CRITICAL - Shopify only processes file inputs inside <form> tags
      for (let i = 1; i <= 3; i++) {
        const fileInput = container.querySelector(`[data-pet-file-input="${i}"]`);

        if (fileInput && fileInput.files && fileInput.files.length > 0) {
          // Remove from current parent
          if (fileInput.parentNode) {
            fileInput.parentNode.removeChild(fileInput);
          }

          // Append to form so Shopify can upload files to CDN
          form.appendChild(fileInput);

          console.log(`üìé Pet Selector: Moved ${fileInput.files.length} file(s) for Pet ${i} into form for submission`);
        }
      }
    });
  }

  // === RESTORE STATE ON PAGE LOAD ===
  // Wait for DOM to be fully ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', restorePetSelectorState);
  } else {
    restorePetSelectorState();
  }

  // Also handle pageshow (for mobile back/forward cache)
  window.addEventListener('pageshow', (e) => {
    if (e.persisted) {
      console.log('üìÑ Page loaded from cache, reloading state...');
      restorePetSelectorState();
    }
  });
})();
</script>

{% endif %}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Upload Button Warming Integration Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: #718096;
            margin-bottom: 30px;
            font-style: italic;
        }

        .test-section {
            margin: 25px 0;
            padding: 20px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            background: #f8fafc;
        }

        .test-section h2 {
            color: #2d3748;
            margin-top: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .config-section {
            background: #edf2f7;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .input-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 15px 0;
        }

        .input-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-weight: 600;
            color: #4a5568;
            font-size: 14px;
        }

        input[type="text"], input[type="number"], select {
            padding: 8px;
            border: 2px solid #cbd5e0;
            border-radius: 6px;
            font-size: 14px;
        }

        input[type="text"]:focus, input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin: 5px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
        }

        .upload-simulation {
            border: 3px dashed #cbd5e0;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            margin: 20px 0;
            background: #f7fafc;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-simulation:hover {
            border-color: #667eea;
            background: #edf2f7;
        }

        .upload-simulation.warming {
            border-color: #ed8936;
            background: #fffaf0;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .upload-icon {
            font-size: 3em;
            color: #a0aec0;
            margin-bottom: 15px;
        }

        .warming .upload-icon {
            color: #ed8936;
        }

        .test-log {
            background: #1a1a1a;
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            margin: 15px 0;
            border: 2px solid #4a5568;
        }

        .metrics-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .metric-card {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #667eea;
            margin: 5px 0;
        }

        .metric-label {
            color: #718096;
            font-weight: 600;
            font-size: 0.9em;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-unknown { background: #a0aec0; }
        .status-healthy { background: #48bb78; }
        .status-warming { background: #ed8936; }
        .status-error { background: #f56565; }

        .results {
            background: #f0fff4;
            border: 2px solid #9ae6b4;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }

        .error {
            background: #fed7d7;
            border: 2px solid #feb2b2;
            color: #c53030;
        }

        @media (max-width: 768px) {
            .input-group {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 20px;
                margin: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ Upload Button Warming Integration Test</h1>
        <p class="subtitle">Testing the actual frontend warming implementation with simulated user interactions</p>

        <!-- Configuration -->
        <div class="test-section">
            <h2>‚öôÔ∏è Configuration</h2>
            <div class="config-section">
                <div class="input-group">
                    <div class="input-field">
                        <label for="apiUrl">API Base URL:</label>
                        <input type="text" id="apiUrl" value="https://inspirenet-bg-removal-api-725543555429.us-central1.run.app">
                    </div>
                    <div class="input-field">
                        <label for="cooldownTime">Cooldown Time (s):</label>
                        <input type="number" id="cooldownTime" value="30" min="10" max="120">
                    </div>
                </div>
                <div class="input-group">
                    <div class="input-field">
                        <label for="testIterations">Test Iterations:</label>
                        <input type="number" id="testIterations" value="3" min="1" max="10">
                    </div>
                    <div class="input-field">
                        <label for="rateLimitTest">Test Rate Limiting:</label>
                        <select id="rateLimitTest">
                            <option value="true">Yes</option>
                            <option value="false">No</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>

        <!-- Test Controls -->
        <div class="test-section">
            <h2>üéÆ Test Controls</h2>
            <button class="btn" onclick="runIntegrationTest()">üöÄ Run Integration Test</button>
            <button class="btn btn-secondary" onclick="testUploadButtonClick()">üì§ Test Upload Click</button>
            <button class="btn btn-secondary" onclick="testRateLimiting()">‚è∞ Test Rate Limiting</button>
            <button class="btn btn-secondary" onclick="testErrorHandling()">‚ö†Ô∏è Test Error Handling</button>
            <button class="btn btn-danger" onclick="resetTest()">üîÑ Reset</button>
        </div>

        <!-- Upload Button Simulation -->
        <div class="test-section">
            <h2>üì§ Upload Button Simulation</h2>
            <div class="upload-simulation" id="uploadSim" onclick="simulateUploadClick()">
                <div class="upload-icon">üì∑</div>
                <h3>Click to Upload Photo</h3>
                <p>This simulates the actual upload button behavior</p>
                <p id="uploadStatus">Ready</p>
            </div>
        </div>

        <!-- Live Metrics -->
        <div class="test-section">
            <h2>üìä Live Metrics</h2>
            <div class="metrics-display">
                <div class="metric-card">
                    <div class="metric-label">API Status</div>
                    <div class="metric-value" id="apiStatus">
                        <span class="status-indicator status-unknown"></span>Unknown
                    </div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Warming Count</div>
                    <div class="metric-value" id="warmingCount">0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Rate Limited</div>
                    <div class="metric-value" id="rateLimitedCount">0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Success Rate</div>
                    <div class="metric-value" id="successRate">--</div>
                </div>
            </div>
        </div>

        <!-- Test Results -->
        <div class="test-section">
            <h2>üìã Test Results</h2>
            <div class="results" id="testResults"></div>
        </div>

        <!-- Live Console Log -->
        <div class="test-section">
            <h2>üìù Test Log</h2>
            <div class="test-log" id="testLog"></div>
        </div>
    </div>

    <script>
        // Frontend Warming Integration Tester
        class FrontendWarmingTester {
            constructor() {
                this.apiUrl = '';
                this.metrics = {
                    warmingAttempts: 0,
                    rateLimitedAttempts: 0,
                    successfulWarmings: 0,
                    errors: 0
                };
                this.isRunning = false;
                this.warmingConfig = {
                    cooldownPeriod: 30000,    // 30 seconds between warming attempts
                    healthCheckTimeout: 10000, // 10 seconds for health check
                    lightweightTimeout: 30000  // 30 seconds for lightweight warming
                };
                this.lastUploadWarming = 0;
                this.isWarmingUp = false;
                this.warmingPromise = null;
                this.apiHealthStatus = 'unknown';
            }

            log(message, type = 'info') {
                const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
                const logElement = document.getElementById('testLog');
                const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
                
                logElement.textContent += `[${timestamp}] ${prefix} ${message}\n`;
                logElement.scrollTop = logElement.scrollHeight;
                
                console.log(`[Frontend Warming Test] ${message}`);
            }

            updateMetrics() {
                document.getElementById('warmingCount').textContent = this.metrics.warmingAttempts;
                document.getElementById('rateLimitedCount').textContent = this.metrics.rateLimitedAttempts;
                
                const total = this.metrics.warmingAttempts + this.metrics.rateLimitedAttempts;
                const successRate = total > 0 ? ((this.metrics.successfulWarmings / total) * 100).toFixed(1) + '%' : '--';
                document.getElementById('successRate').textContent = successRate;
            }

            async checkApiStatus() {
                try {
                    const response = await fetch(`${this.apiUrl}/health`, {
                        method: 'GET',
                        signal: AbortSignal.timeout(10000)
                    });
                    
                    if (response.ok) {
                        const health = await response.json();
                        const status = health.status || 'unknown';
                        const modelReady = health.model?.ready || false;
                        
                        this.apiHealthStatus = modelReady && status === 'healthy' ? 'healthy' : 'cold';
                        
                        const statusElement = document.getElementById('apiStatus');
                        if (modelReady && status === 'healthy') {
                            statusElement.innerHTML = '<span class="status-indicator status-healthy"></span>Healthy';
                        } else if (status === 'warming') {
                            statusElement.innerHTML = '<span class="status-indicator status-warming"></span>Warming';
                        } else {
                            statusElement.innerHTML = '<span class="status-indicator status-unknown"></span>Cold';
                        }
                        
                        return health;
                    }
                } catch (error) {
                    document.getElementById('apiStatus').innerHTML = '<span class="status-indicator status-error"></span>Error';
                    this.log(`API status check failed: ${error.message}`, 'error');
                }
                return null;
            }

            // Replicate the exact frontend warming logic from ks-pet-bg-remover.js
            triggerUploadButtonWarming() {
                // Rate limiting: don't warm up more than once every 30 seconds
                const now = Date.now();
                const cooldownPeriod = this.warmingConfig.cooldownPeriod;
                
                if (this.lastUploadWarming && (now - this.lastUploadWarming) < cooldownPeriod) {
                    this.log('‚è≥ Upload warming skipped - cooldown period active');
                    this.metrics.rateLimitedAttempts++;
                    this.updateMetrics();
                    return false;
                }
                
                // Skip if API is already healthy or currently warming
                if (this.apiHealthStatus === 'healthy' || this.isWarmingUp || window.inspirenetModelLoaded) {
                    this.log('‚ö° Upload warming skipped - API already warm');
                    return false;
                }
                
                this.lastUploadWarming = now;
                this.metrics.warmingAttempts++;
                this.log('üéØ Upload button warming triggered - starting container boot...');
                
                // Perform lightweight warming asynchronously without blocking UI
                this.performUploadWarming().catch(error => {
                    // Fail silently - don't affect user experience, but log for debugging
                    this.log(`Upload warming failed silently: ${error.message}`, 'warning');
                    this.metrics.errors++;
                }).finally(() => {
                    this.updateMetrics();
                });
                
                return true;
            }

            async performUploadWarming() {
                // Use promise-based mutex to prevent race conditions
                if (this.warmingPromise) {
                    this.log('‚è≥ Upload warming already in progress - waiting for completion');
                    return this.warmingPromise;
                }
                
                // Create the warming promise
                this.warmingPromise = this._executeUploadWarming();
                
                try {
                    return await this.warmingPromise;
                } finally {
                    this.warmingPromise = null;
                }
            }

            async _executeUploadWarming() {
                if (this.isWarmingUp) return;
                
                this.isWarmingUp = true;
                
                try {
                    // Use health endpoint first - lighter weight than full processing
                    this.log('üîç Checking API health status for warming decision...');
                    
                    const controller = new AbortController();
                    const timeout = setTimeout(() => controller.abort(), this.warmingConfig.healthCheckTimeout);
                    
                    const healthResponse = await fetch(`${this.apiUrl}/health`, {
                        method: 'GET',
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeout);
                    
                    // If health check fails or is slow, trigger full warming
                    if (!healthResponse.ok || healthResponse.status === 503) {
                        this.log('üî• Health check indicates cold start - triggering full warm-up...');
                        await this.performLightweightWarming();
                    } else {
                        const healthData = await healthResponse.json();
                        if (healthData.model?.ready) {
                            this.log('‚úÖ API already healthy from upload warming');
                            this.apiHealthStatus = 'healthy';
                            window.inspirenetModelLoaded = true;
                            this.metrics.successfulWarmings++;
                        } else {
                            this.log('üî• Model not ready - triggering full warm-up...');
                            await this.performLightweightWarming();
                        }
                    }
                } catch (error) {
                    // If health check fails, try lightweight warming
                    this.log('üî• Health check failed - attempting lightweight warm-up...');
                    await this.performLightweightWarming();
                } finally {
                    this.isWarmingUp = false;
                }
            }

            async performLightweightWarming() {
                let canvas = null;
                let controller = null;
                let timeout = null;
                
                try {
                    // Create minimal test image for warming
                    canvas = document.createElement('canvas');
                    canvas.width = canvas.height = 1;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, 1, 1);
                    
                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                    
                    const formData = new FormData();
                    formData.append('file', blob, 'upload_warmup.png');
                    formData.append('effects', 'enhancedblackwhite');
                    formData.append('session_id', 'upload_warmup_' + Date.now());
                    
                    controller = new AbortController();
                    timeout = setTimeout(() => controller.abort(), this.warmingConfig.lightweightTimeout);
                    
                    const response = await fetch(`${this.apiUrl}/api/v2/process-with-effects`, {
                        method: 'POST',
                        body: formData,
                        signal: controller.signal
                    });
                    
                    if (response.ok) {
                        window.inspirenetModelLoaded = true;
                        this.apiHealthStatus = 'healthy';
                        this.metrics.successfulWarmings++;
                        this.log('‚úÖ Upload warming completed - API ready for user image');
                    } else {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                } catch (error) {
                    // Silent failure - don't affect UX, but log for debugging
                    this.log(`Lightweight warming failed: ${error.message}`, 'warning');
                    this.metrics.errors++;
                } finally {
                    // Proper cleanup to prevent memory leaks
                    if (timeout) clearTimeout(timeout);
                    if (canvas) {
                        canvas.width = canvas.height = 0; // Clear canvas memory
                        canvas = null;
                    }
                    controller = null;
                }
            }

            async simulateUserUploadClick() {
                const uploadSim = document.getElementById('uploadSim');
                const uploadStatus = document.getElementById('uploadStatus');
                
                this.log('üëÜ Simulating user upload button click...');
                
                // Visual feedback
                uploadSim.classList.add('warming');
                uploadStatus.textContent = 'Warming up...';
                
                try {
                    const wasTriggered = this.triggerUploadButtonWarming();
                    
                    if (wasTriggered) {
                        // Wait for warming to complete
                        while (this.isWarmingUp) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                        
                        uploadStatus.textContent = 'Ready for upload!';
                        this.log('‚úÖ Upload button warming simulation completed');
                    } else {
                        uploadStatus.textContent = 'Warming skipped';
                        this.log('‚è≠Ô∏è Upload button warming was skipped (rate limited or already warm)');
                    }
                } catch (error) {
                    uploadStatus.textContent = 'Error occurred';
                    this.log(`‚ùå Upload button warming simulation failed: ${error.message}`, 'error');
                } finally {
                    uploadSim.classList.remove('warming');
                    
                    // Reset status after delay
                    setTimeout(() => {
                        uploadStatus.textContent = 'Ready';
                    }, 3000);
                }
            }

            async testRateLimitingBehavior() {
                this.log('üïê Testing rate limiting behavior...');
                
                const results = {
                    attempts: 0,
                    triggered: 0,
                    rateLimited: 0
                };
                
                // Make 5 rapid clicks to test rate limiting
                for (let i = 0; i < 5; i++) {
                    this.log(`   Click attempt ${i + 1}/5`);
                    results.attempts++;
                    
                    const wasTriggered = this.triggerUploadButtonWarming();
                    if (wasTriggered) {
                        results.triggered++;
                        // Wait for warming to complete before next attempt
                        while (this.isWarmingUp) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                    } else {
                        results.rateLimited++;
                    }
                    
                    // Small delay between attempts
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                this.log(`Rate limiting test completed:`, 'success');
                this.log(`   Attempts: ${results.attempts}`);
                this.log(`   Triggered: ${results.triggered}`);
                this.log(`   Rate Limited: ${results.rateLimited}`);
                
                // Validate rate limiting is working (should have at least some rate limited attempts)
                if (results.rateLimited > 0) {
                    this.log('‚úÖ Rate limiting is working correctly');
                } else {
                    this.log('‚ö†Ô∏è Rate limiting may not be working as expected', 'warning');
                }
                
                return results;
            }

            async testErrorHandlingBehavior() {
                this.log('‚ö†Ô∏è Testing error handling behavior...');
                
                // Save original API URL
                const originalUrl = this.apiUrl;
                
                try {
                    // Set invalid API URL to trigger errors
                    this.apiUrl = 'https://invalid-url-for-testing.com';
                    this.log('   Using invalid API URL to trigger errors');
                    
                    // Reset rate limiting to allow test
                    this.lastUploadWarming = 0;
                    
                    // Attempt warming with invalid URL
                    const wasTriggered = this.triggerUploadButtonWarming();
                    
                    if (wasTriggered) {
                        // Wait for warming attempt to complete
                        while (this.isWarmingUp) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                        
                        this.log('‚úÖ Error handling test completed - errors were handled gracefully');
                    } else {
                        this.log('‚ö†Ô∏è Warming was not triggered during error test', 'warning');
                    }
                    
                } finally {
                    // Restore original API URL
                    this.apiUrl = originalUrl;
                    this.log('   Restored original API URL');
                }
            }

            async waitForCooldown(seconds) {
                this.log(`‚è≥ Waiting ${seconds}s for cooldown period...`);
                
                for (let i = 0; i < seconds; i++) {
                    if (i % 5 === 0) {
                        this.log(`   Cooldown: ${seconds - i}s remaining`);
                    }
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                this.log('Cooldown completed');
            }

            generateIntegrationReport() {
                let report = 'üéØ FRONTEND WARMING INTEGRATION TEST REPORT\n';
                report += '=' .repeat(60) + '\n\n';
                
                report += 'üìä TEST METRICS:\n';
                report += '-' .repeat(40) + '\n';
                report += `Total Warming Attempts: ${this.metrics.warmingAttempts}\n`;
                report += `Successful Warmings: ${this.metrics.successfulWarmings}\n`;
                report += `Rate Limited Attempts: ${this.metrics.rateLimitedAttempts}\n`;
                report += `Errors: ${this.metrics.errors}\n\n`;
                
                const totalAttempts = this.metrics.warmingAttempts + this.metrics.rateLimitedAttempts;
                if (totalAttempts > 0) {
                    const successRate = (this.metrics.successfulWarmings / totalAttempts) * 100;
                    report += `Overall Success Rate: ${successRate.toFixed(1)}%\n`;
                    report += `Rate Limiting Effectiveness: ${((this.metrics.rateLimitedAttempts / totalAttempts) * 100).toFixed(1)}%\n\n`;
                }
                
                report += 'üéØ INTEGRATION ASSESSMENT:\n';
                report += '-' .repeat(40) + '\n';
                
                if (this.metrics.successfulWarmings > 0) {
                    report += '‚úÖ Frontend warming integration is working\n';
                    report += '   - Upload button clicks trigger warming\n';
                    report += '   - API warming requests are successful\n';
                } else {
                    report += '‚ùå Frontend warming integration has issues\n';
                    report += '   - No successful warming attempts detected\n';
                }
                
                if (this.metrics.rateLimitedAttempts > 0) {
                    report += '‚úÖ Rate limiting is functioning correctly\n';
                    report += '   - Prevents excessive warming requests\n';
                } else {
                    report += '‚ö†Ô∏è Rate limiting may not be working\n';
                    report += '   - All attempts were processed\n';
                }
                
                if (this.metrics.errors === 0) {
                    report += '‚úÖ Error handling is robust\n';
                    report += '   - No errors occurred during testing\n';
                } else {
                    report += '‚ö†Ô∏è Some errors occurred during testing\n';
                    report += `   - ${this.metrics.errors} error(s) logged\n`;
                }
                
                report += '\nüìÖ Test completed: ' + new Date().toISOString();
                
                return report;
            }

            displayResults(content) {
                const resultsDiv = document.getElementById('testResults');
                resultsDiv.textContent = content;
                resultsDiv.className = 'results';
            }

            displayError(content) {
                const resultsDiv = document.getElementById('testResults');
                resultsDiv.textContent = content;
                resultsDiv.className = 'results error';
            }

            clearResults() {
                document.getElementById('testResults').textContent = '';
                document.getElementById('testLog').textContent = '';
                this.metrics = {
                    warmingAttempts: 0,
                    rateLimitedAttempts: 0,
                    successfulWarmings: 0,
                    errors: 0
                };
                this.lastUploadWarming = 0;
                this.updateMetrics();
            }
        }

        // Initialize tester
        const frontendTester = new FrontendWarmingTester();

        // Event handlers
        async function runIntegrationTest() {
            if (frontendTester.isRunning) {
                alert('Test is already running!');
                return;
            }

            frontendTester.isRunning = true;
            frontendTester.apiUrl = document.getElementById('apiUrl').value.trim();
            const iterations = parseInt(document.getElementById('testIterations').value) || 3;
            const cooldownTime = parseInt(document.getElementById('cooldownTime').value) || 30;
            const testRateLimit = document.getElementById('rateLimitTest').value === 'true';
            
            if (!frontendTester.apiUrl) {
                alert('Please enter API URL');
                frontendTester.isRunning = false;
                return;
            }

            frontendTester.clearResults();
            frontendTester.log('üöÄ Starting frontend warming integration test...');
            frontendTester.log(`Configuration: ${iterations} iterations, ${cooldownTime}s cooldown`);
            
            try {
                // Initial API status check
                frontendTester.log('üîç Initial API status check...');
                await frontendTester.checkApiStatus();
                
                // Run upload button simulation iterations
                for (let i = 1; i <= iterations; i++) {
                    frontendTester.log(`\nüîÑ ========== ITERATION ${i}/${iterations} ==========`);
                    
                    // Simulate user upload button click
                    frontendTester.log(`Simulating upload button click ${i}...`);
                    await frontendTester.simulateUserUploadClick();
                    
                    // Wait for cooldown if not last iteration
                    if (i < iterations) {
                        await frontendTester.waitForCooldown(cooldownTime);
                    }
                    
                    // Update status
                    await frontendTester.checkApiStatus();
                }
                
                // Test rate limiting if enabled
                if (testRateLimit) {
                    frontendTester.log('\nüïê ========== RATE LIMITING TEST ==========');
                    await frontendTester.testRateLimitingBehavior();
                }
                
                // Test error handling
                frontendTester.log('\n‚ö†Ô∏è ========== ERROR HANDLING TEST ==========');
                await frontendTester.testErrorHandlingBehavior();
                
                // Generate final report
                frontendTester.log('\nüìä Generating integration test report...');
                const report = frontendTester.generateIntegrationReport();
                frontendTester.displayResults(report);
                
                frontendTester.log('‚úÖ Frontend warming integration test completed!', 'success');
                
            } catch (error) {
                frontendTester.log(`‚ùå Integration test failed: ${error.message}`, 'error');
                frontendTester.displayError(`Integration test failed: ${error.message}`);
            } finally {
                frontendTester.isRunning = false;
            }
        }

        async function testUploadButtonClick() {
            frontendTester.apiUrl = document.getElementById('apiUrl').value.trim();
            
            if (!frontendTester.apiUrl) {
                alert('Please enter API URL');
                return;
            }

            await frontendTester.simulateUserUploadClick();
        }

        async function testRateLimiting() {
            frontendTester.apiUrl = document.getElementById('apiUrl').value.trim();
            
            if (!frontendTester.apiUrl) {
                alert('Please enter API URL');
                return;
            }

            const results = await frontendTester.testRateLimitingBehavior();
            
            let report = 'RATE LIMITING TEST RESULTS\n';
            report += '=' .repeat(40) + '\n\n';
            report += `Total Attempts: ${results.attempts}\n`;
            report += `Warming Triggered: ${results.triggered}\n`;
            report += `Rate Limited: ${results.rateLimited}\n\n`;
            
            if (results.rateLimited > 0) {
                report += '‚úÖ Rate limiting is working correctly\n';
            } else {
                report += '‚ö†Ô∏è Rate limiting may not be working as expected\n';
            }
            
            frontendTester.displayResults(report);
        }

        async function testErrorHandling() {
            frontendTester.apiUrl = document.getElementById('apiUrl').value.trim();
            
            if (!frontendTester.apiUrl) {
                alert('Please enter API URL');
                return;
            }

            await frontendTester.testErrorHandlingBehavior();
            
            let report = 'ERROR HANDLING TEST RESULTS\n';
            report += '=' .repeat(40) + '\n\n';
            report += 'Error handling test completed successfully.\n';
            report += 'Check the test log for detailed error handling behavior.\n\n';
            report += '‚úÖ Errors were handled gracefully without affecting UX\n';
            
            frontendTester.displayResults(report);
        }

        function simulateUploadClick() {
            testUploadButtonClick();
        }

        function resetTest() {
            if (frontendTester.isRunning) {
                if (confirm('Test is currently running. Are you sure you want to reset?')) {
                    frontendTester.isRunning = false;
                } else {
                    return;
                }
            }
            
            frontendTester.clearResults();
            frontendTester.log('üîÑ Frontend warming test reset', 'info');
        }

        // Initialize on page load
        window.addEventListener('load', () => {
            frontendTester.log('üéØ Frontend Warming Integration Tester Initialized');
            frontendTester.log('Ready to test upload button warming behavior');
            
            // Set API URL from configuration
            frontendTester.apiUrl = document.getElementById('apiUrl').value;
            
            // Initial status check
            frontendTester.checkApiStatus();
        });

        // Periodic status updates
        setInterval(() => {
            if (!frontendTester.isRunning) {
                frontendTester.checkApiStatus();
            }
        }, 15000); // Update every 15 seconds
    </script>
</body>
</html>
{% comment %}
  Pet Selector - Stitch UI Pattern
  Simplified, modern pet selector based on Stitch reference design
  Max 3 pets, global style/font selection, per-pet upload
{% endcomment %}

{% comment %} Get max pets from product metafield (default: 1) {% endcomment %}
{% assign max_pets_from_metafield = product.metafields.custom.max_pets | default: 1 %}
{% assign max_pets_per_product = max_pets_from_metafield | plus: 0 %}

{% comment %} Ensure max_pets is within valid range (1-3) {% endcomment %}
{% if max_pets_per_product < 1 %}
  {% assign max_pets_per_product = 1 %}
{% elsif max_pets_per_product > 3 %}
  {% assign max_pets_per_product = 3 %}
{% endif %}

{% comment %} Only show for products with "custom" tag {% endcomment %}
{% assign has_custom_tag = false %}
{% for tag in product.tags %}
  {% if tag contains 'custom' or tag contains 'Custom' or tag contains 'CUSTOM' %}
    {% assign has_custom_tag = true %}
    {% break %}
  {% endif %}
{% endfor %}

{% if has_custom_tag %}
<div class="pet-selector-stitch"
     data-max-pets="{{ max_pets_per_product }}"
     data-product-id="{{ product.id }}"
     style="--pet-selector-primary: {{ scheme_button }}; --pet-selector-primary-text: {{ scheme_button_label }}; --pet-selector-text: {{ scheme_text }}; --pet-selector-background: {{ scheme_background }};">


  {% comment %} Pet Count Selector {% endcomment %}
  <div class="pet-selector__section">
    <h2 class="pet-selector__section-heading">Number of Pets</h2>
    <div class="pet-selector__count-grid">
      {% for i in (1..max_pets_per_product) %}
      <label class="pet-count-btn">
        <span class="pet-count-btn__number">{{ i }}</span>
        {% if i == 2 %}
          <span class="pet-count-btn__fee">(+$10)</span>
        {% elsif i == 3 %}
          <span class="pet-count-btn__fee">(+$15)</span>
        {% endif %}
        <input type="radio"
               name="pet-count"
               value="{{ i }}"
               data-pet-count-radio
               data-fee-variant="{% if i == 2 %}{{ settings.pet_fee_variant_2_pets }}{% elsif i == 3 %}{{ settings.pet_fee_variant_3_pets }}{% endif %}">
      </label>
      {% endfor %}
    </div>
    {% comment %} Hidden input to store selected fee variant ID for cart submission {% endcomment %}
    <input type="hidden" name="pet_fee_variant_id" value="" data-pet-fee-variant-input>
  </div>

  {% comment %} Pet Details Section - Hidden until pet count is selected {% endcomment %}
  <div class="pet-selector__section" data-pet-details-section hidden>
    <h2 class="pet-selector__section-heading">Pet Details</h2>

    {% comment %} Dynamic pet sections (1-3 based on selection) - All hidden initially {% endcomment %}
    <div class="pet-details-container" data-pet-details-container>
      {% for i in (1..3) %}
      <div class="pet-detail"
           data-pet-index="{{ i }}"
           style="display: none;">

        {% comment %} Combined Pet Section - Name and Photo together {% endcomment %}
        <div class="pet-detail__section pet-detail__combined-section">
          {% comment %} Pet's Name {% endcomment %}
          <div class="pet-detail__name-group">
            <h4 class="pet-detail__section-heading">
              {% if i == 1 %}Pet's Name{% else %}Pet {{ i }}'s Name{% endif %}<span class="required-indicator" aria-hidden="true">*</span>
            </h4>
            <input type="text"
                   class="pet-detail__name-input"
                   name="properties[Pet {{ i }} Name]"
                   placeholder="Enter name"
                   required
                   aria-required="true"
                   form="{{ product_form_id }}"
                   data-pet-name-input="{{ i }}">
          </div>

          {% comment %} Pet's Photo {% endcomment %}
          <div class="pet-detail__photo-group">
            <h4 class="pet-detail__section-heading">
              Pet's Photo
            </h4>

            {% comment %} Session Pet Gallery - Shows previously processed pets {% endcomment %}
            <div class="session-pet-gallery" data-session-gallery="{{ i }}" style="display: none;">
              <div class="session-pet-gallery__header">
                <span class="session-pet-gallery__label">Use a recent pet</span>
                <button type="button" class="session-pet-gallery__toggle" data-gallery-toggle="{{ i }}" aria-expanded="true">
                  <svg class="session-pet-gallery__toggle-icon" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6 9 12 15 18 9"></polyline>
                  </svg>
                </button>
              </div>
              <div class="session-pet-gallery__pets" data-gallery-pets="{{ i }}">
                {% comment %} Pets populated via JavaScript from PetStorage.getRecentPets() {% endcomment %}
              </div>
              <div class="session-pet-gallery__divider">
                <span>or upload new</span>
              </div>
            </div>

            <div class="pet-detail__image-actions">
              {% comment %} Upload Zone - Clickable area for file selection {% endcomment %}
              <div class="pet-detail__upload-zone"
                   data-upload-zone="{{ i }}"
                   tabindex="0"
                   role="button"
                   aria-label="Click or drag to upload pet {{ i }} photo(s)">
                <svg class="pet-detail__upload-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                  <polyline points="17 8 12 3 7 8"></polyline>
                  <line x1="12" y1="3" x2="12" y2="15"></line>
                </svg>
                <span class="pet-detail__upload-text" data-upload-text="{{ i }}">
                  Click or drag to upload
                </span>
              </div>

              {% comment %} Use Existing Print checkbox below upload zone {% endcomment %}
              <label class="pet-detail__checkbox-label">
                <input type="checkbox"
                       class="pet-detail__checkbox"
                       data-existing-print-checkbox="{{ i }}">
                <span>Use Existing Perkie Print</span>
              </label>

              {% comment %} Native Shopify file upload - files uploaded to CDN on form submit {% endcomment %}
              {% comment %} HIDDEN FROM CUSTOMERS: Underscore prefix hides from cart/checkout {% endcomment %}
              <input type="file"
                     name="properties[_pet_{{ i }}_images]"
                     accept="image/*"
                     style="display: none;"
                     form="{{ product_form_id }}"
                     data-pet-file-input="{{ i }}"
                     data-max-files="1"
                     aria-label="Upload pet {{ i }} photo">

              {% comment %} Upload Progress Bar - REMOVED per user request {% endcomment %}

              {% comment %} File upload status with Preview button - shown after files selected {% endcomment %}
              <div class="pet-detail__upload-status-wrapper"
                   data-upload-status-wrapper="{{ i }}"
                   style="display: none;">
                <div class="pet-detail__upload-status"
                     data-upload-status="{{ i }}"></div>
                <button type="button"
                        class="pet-detail__preview-btn"
                        data-pet-preview-btn="{{ i }}"
                        disabled
                        aria-label="Preview pet {{ i }} image with effects"
                        aria-describedby="preview-status-{{ i }}">
                  Preview
                </button>
                <span id="preview-status-{{ i }}" class="sr-only" aria-live="polite">Upload image first</span>
              </div>
            </div>
          </div>
        </div>

        <div class="pet-detail__order-input"
             data-order-number-input="{{ i }}"
             style="display: none;">
          {% comment %} HIDDEN FROM CUSTOMERS: Underscore prefix hides from cart/checkout {% endcomment %}
          <input type="text"
                 class="pet-detail__order-number"
                 placeholder="Enter previous order number"
                 name="properties[_pet_{{ i }}_previous_order_number]"
                 form="{{ product_form_id }}"
                 data-order-number-field="{{ i }}">
        </div>

        {% comment %} HIDDEN FROM CUSTOMERS: Fulfillment data for Pet {{ i }} (underscore prefix) {% endcomment %}
        <input type="hidden"
               id="pet-{{ i }}-processed-url"
               name="properties[_pet_{{ i }}_processed_image_url]"
               value=""
               form="{{ product_form_id }}"
               data-pet-processed-url="{{ i }}">
        <input type="hidden"
               id="order-type-{{ i }}"
               name="properties[_pet_{{ i }}_order_type]"
               value=""
               form="{{ product_form_id }}">
        <input type="hidden"
               id="pet-{{ i }}-filename"
               name="properties[_pet_{{ i }}_filename]"
               value=""
               form="{{ product_form_id }}"
               data-pet-filename="{{ i }}">
        <input type="hidden"
               id="artist-notes-field-{{ i }}"
               name="properties[_pet_{{ i }}_artist_notes]"
               value=""
               form="{{ product_form_id }}"
               data-artist-notes="{{ i }}">
        <input type="hidden"
               id="pet-{{ i }}-session-key"
               name="properties[_pet_{{ i }}_session_key]"
               value=""
               form="{{ product_form_id }}"
               data-pet-session-key="{{ i }}">
        <input type="hidden"
               id="pet-{{ i }}-selected-effect"
               name="properties[_pet_{{ i }}_selected_effect]"
               value=""
               form="{{ product_form_id }}"
               data-pet-selected-effect="{{ i }}">
        <input type="hidden"
               id="pet-{{ i }}-original-gcs-url"
               name="properties[_pet_{{ i }}_original_gcs_url]"
               value=""
               form="{{ product_form_id }}"
               data-pet-original-gcs-url="{{ i }}">

      </div>
      {% endfor %}
    </div>
  </div>

  {% comment %} Style Selector - RESTORED: After Pet Details for proper UX flow {% endcomment %}
  <div class="pet-selector__section" data-style-section hidden>
    <h2 class="pet-selector__section-heading">Choose Style<span class="required-indicator" aria-hidden="true">*</span></h2>
    <div class="style-selector__grid">

      {% comment %} B&W Style {% endcomment %}
      <label class="style-card">
        <input type="radio"
               name="properties[Style]"
               value="Black & White"
               required
               form="{{ product_form_id }}"
               data-style-radio="enhancedblackwhite">
        <div class="style-card__content">
          <div class="style-card__image-wrapper">
            {% if block.settings.style_preview_bw != blank %}
              <img src="{{ block.settings.style_preview_bw | image_url: width: 320 }}"
                   alt="Black & White style preview"
                   class="style-card__image"
                   data-style-preview="bw"
                   data-static-src="{{ block.settings.style_preview_bw | image_url: width: 320 }}">
            {% else %}
              <img src="{{ 'pet-bw-preview.jpg' | asset_url }}"
                   alt="Black & White style preview"
                   class="style-card__image"
                   data-style-preview="bw"
                   data-static-src="{{ 'pet-bw-preview.jpg' | asset_url }}">
            {% endif %}
          </div>
          <p class="style-card__label">Black & White</p>
        </div>
      </label>

      {% comment %} Color Style {% endcomment %}
      <label class="style-card">
        <input type="radio"
               name="properties[Style]"
               value="Color"
               form="{{ product_form_id }}"
               data-style-radio="color">
        <div class="style-card__content">
          <div class="style-card__image-wrapper">
            {% if block.settings.style_preview_color != blank %}
              <img src="{{ block.settings.style_preview_color | image_url: width: 320 }}"
                   alt="Color style preview"
                   class="style-card__image"
                   data-style-preview="color"
                   data-static-src="{{ block.settings.style_preview_color | image_url: width: 320 }}">
            {% else %}
              <img src="{{ 'pet-color-preview.jpg' | asset_url }}"
                   alt="Color style preview"
                   class="style-card__image"
                   data-style-preview="color"
                   data-static-src="{{ 'pet-color-preview.jpg' | asset_url }}">
            {% endif %}
          </div>
          <p class="style-card__label">Color</p>
        </div>
      </label>

      {% comment %} Ink Wash (Traditional Asian Ink Painting) Style {% endcomment %}
      <label class="style-card">
        <input type="radio"
               name="properties[Style]"
               value="Ink Wash"
               form="{{ product_form_id }}"
               data-style-radio="ink_wash">
        <div class="style-card__content">
          <div class="style-card__image-wrapper">
            {% if block.settings.style_preview_stencil != blank %}
              <img src="{{ block.settings.style_preview_stencil | image_url: width: 320 }}"
                   alt="Ink Wash style preview"
                   class="style-card__image"
                   data-style-preview="ink_wash"
                   data-static-src="{{ block.settings.style_preview_stencil | image_url: width: 320 }}">
            {% else %}
              <img src="{{ 'pet-stencil-preview.jpg' | asset_url }}"
                   alt="Ink Wash style preview"
                   class="style-card__image"
                   data-style-preview="ink_wash"
                   data-static-src="{{ 'pet-stencil-preview.jpg' | asset_url }}">
            {% endif %}
          </div>
          <p class="style-card__label">Ink Wash</p>
        </div>
      </label>

      {% comment %} Sketch (Pen & Marker) Style {% endcomment %}
      <label class="style-card">
        <input type="radio"
               name="properties[Style]"
               value="Marker"
               form="{{ product_form_id }}"
               data-style-radio="sketch">
        <div class="style-card__content">
          <div class="style-card__image-wrapper">
            {% if block.settings.style_preview_sketch != blank %}
              <img src="{{ block.settings.style_preview_sketch | image_url: width: 320 }}"
                   alt="Marker style preview"
                   class="style-card__image"
                   data-style-preview="sketch"
                   data-static-src="{{ block.settings.style_preview_sketch | image_url: width: 320 }}">
            {% else %}
              <img src="{{ 'pet-sketch-preview.jpg' | asset_url }}"
                   alt="Marker style preview"
                   class="style-card__image"
                   data-style-preview="sketch"
                   data-static-src="{{ 'pet-sketch-preview.jpg' | asset_url }}">
            {% endif %}
          </div>
          <p class="style-card__label">Marker</p>
        </div>
      </label>

    </div>
  </div>

  {% comment %} Font Selector - Hidden until pet count is selected {% endcomment %}
  {% if product.metafields.custom.supports_font_styles == true %}
  <div class="pet-selector__section" data-font-section hidden>
    <h2 class="pet-selector__section-heading">Choose Font<span class="required-indicator" aria-hidden="true">*</span></h2>
    <div class="font-selector__grid">

      {% comment %} No Text Option {% endcomment %}
      <label class="font-card">
        <input type="radio"
               name="properties[Font]"
               value="no-text"
               required
               form="{{ product_form_id }}"
               data-font-radio="no-text">
        <div class="font-card__content">
          <p class="font-card__title">No Text</p>
          <div class="font-card__preview font-card__preview--icon">
            <svg class="font-card__no-text-icon" viewBox="0 0 24 24">
              <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
            </svg>
          </div>
        </div>
      </label>

      {% comment %} Preppy Font {% endcomment %}
      <label class="font-card">
        <input type="radio"
               name="properties[Font]"
               value="preppy"
               form="{{ product_form_id }}"
               data-font-radio="preppy">
        <div class="font-card__content">
          <p class="font-card__title">Preppy</p>
          <p class="font-card__preview font-card__preview--preppy" data-font-preview>
            <span class="font-preview-text"></span>
          </p>
        </div>
      </label>

      {% comment %} Classic Font {% endcomment %}
      <label class="font-card">
        <input type="radio"
               name="properties[Font]"
               value="classic"
               form="{{ product_form_id }}"
               data-font-radio="classic">
        <div class="font-card__content">
          <p class="font-card__title">Classic</p>
          <p class="font-card__preview font-card__preview--classic" data-font-preview>
            <span class="font-preview-text"></span>
          </p>
        </div>
      </label>

      {% comment %} Playful Font {% endcomment %}
      <label class="font-card">
        <input type="radio"
               name="properties[Font]"
               value="playful"
               form="{{ product_form_id }}"
               data-font-radio="playful">
        <div class="font-card__content">
          <p class="font-card__title">Playful</p>
          <p class="font-card__preview font-card__preview--playful" data-font-preview>
            <span class="font-preview-text"></span>
          </p>
        </div>
      </label>

      {% comment %} Elegant Font {% endcomment %}
      <label class="font-card">
        <input type="radio"
               name="properties[Font]"
               value="elegant"
               form="{{ product_form_id }}"
               data-font-radio="elegant">
        <div class="font-card__content">
          <p class="font-card__title">Elegant</p>
          <p class="font-card__preview font-card__preview--elegant" data-font-preview>
            <span class="font-preview-text"></span>
          </p>
        </div>
      </label>

      {% comment %} Trend Font {% endcomment %}
      <label class="font-card">
        <input type="radio"
               name="properties[Font]"
               value="trend"
               form="{{ product_form_id }}"
               data-font-radio="trend">
        <div class="font-card__content">
          <p class="font-card__title">Trend</p>
          <p class="font-card__preview font-card__preview--trend" data-font-preview>
            <span class="font-preview-text"></span>
          </p>
        </div>
      </label>

    </div>
  </div>
  {% endif %}

</div>

{% comment %} Get color scheme from block settings {% endcomment %}
{% assign scheme_id = block.settings.color_scheme | default: 'scheme-1' %}
{% assign scheme = settings.color_schemes[scheme_id].settings %}

{% comment %} Extract color values with fallbacks {% endcomment %}
{% assign scheme_background = scheme.background | default: '#ffffff' %}
{% assign scheme_text = scheme.text | default: '#000000' %}
{% assign scheme_button = scheme.button | default: '#ebff7a' %}
{% assign scheme_button_label = scheme.button_label | default: '#461312' %}

<style>
/* Google Fonts Import for Font Selector */
@import url('https://fonts.googleapis.com/css2?family=Graduate&family=Merriweather:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Rampart+One&family=Ms+Madi&family=Fascinate&display=swap');

/* Pet Selector - Stitch Pattern Styles */
/* Color variables set via inline style on container for instant theme editor updates */

.pet-selector-stitch {
  /* Theme color variables are set via inline style attribute above */
  /* Static gray scale variables defined here */
  --pet-selector-gray-50: #f9fafb;
  --pet-selector-gray-100: #f3f4f6;
  --pet-selector-gray-200: #e5e7eb;
  --pet-selector-gray-300: #d1d5db;
  --pet-selector-gray-400: #9ca3af;
  --pet-selector-gray-500: #6b7280;
  --pet-selector-gray-600: #4b5563;
  --pet-selector-gray-700: #374151;
  --pet-selector-gray-800: #1f2937;
  --pet-selector-gray-900: #111827;
}

.pet-selector-stitch {
  max-width: 960px;
  margin: 0 auto;
  padding: 1rem 1rem 1rem 0;
  color: var(--pet-selector-text);
  /* MOBILE SCROLL FIX: Prevent automatic scroll anchoring during DOM changes */
  /* Supported by Chrome/Android, ignored by Safari (we handle iOS separately in JS) */
  overflow-anchor: none;
}

.pet-selector__section {
  margin-bottom: 1rem;
  padding: 1.5rem;
  border: 1px solid var(--pet-selector-gray-200);
  border-radius: 0.75rem;
  background-color: var(--pet-selector-background);
}

/* Unified section heading style - all section headers use this */
.pet-selector__section-heading {
  font-size: 1.125rem;
  font-weight: 700;
  color: var(--pet-selector-text);
  margin: 0 0 0.75rem 0;
  line-height: 1.3;
}

/* DEPRECATED: Use .pet-selector__section-heading instead */
.pet-selector__label {
  display: block;
  font-size: 1.125rem;
  font-weight: 700;
  color: var(--pet-selector-text);
  margin-bottom: 0.75rem;
}

/* DEPRECATED: Use .pet-selector__section-heading instead */
.pet-selector__heading {
  font-size: 1.375rem;
  font-weight: 700;
  color: var(--pet-selector-text);
  margin: 0 0 1.5rem 0;
}

/* Pet Count Selector */
.pet-selector__count-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 0.5rem;
}

.pet-count-btn {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 3.5rem;
  cursor: pointer;
  border-radius: 0.5rem;
  background-color: var(--pet-selector-gray-100);
  color: var(--pet-selector-gray-500);
  font-size: 1rem;
  font-weight: 600;
  transition: all 0.2s;
  border: 2px solid transparent;
  gap: 0.125rem;
}

.pet-count-btn__number {
  line-height: 1;
}

.pet-count-btn__fee {
  display: block;
  font-size: 0.65rem;
  color: #6b7280;
  font-weight: 400;
  line-height: 1;
}

.pet-count-btn:has(input:checked) .pet-count-btn__fee {
  color: var(--pet-selector-primary);
}

.pet-count-btn input {
  position: absolute;
  opacity: 0;
  width: 0;
  height: 0;
  /* MOBILE SCROLL FIX: Prevent browser scroll-into-view on focus */
  scroll-margin: 0;
  /* iOS-specific: prevent zoom on focus which triggers scroll */
  font-size: 16px;
}

.pet-count-btn--active,
.pet-count-btn:has(input:checked) {
  background-color: var(--pet-selector-background);
  color: var(--pet-selector-text);
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  border-color: #ff5964;
}

/* Pet Details */
.pet-details-container {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.pet-detail {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.pet-detail__name-input {
  width: 100%;
  height: 3rem;
  padding: 0 0.75rem;
  border: 1px solid var(--pet-selector-gray-300);
  border-radius: 0;
  font-size: 0.875rem;
  color: var(--pet-selector-text);
  background-color: var(--pet-selector-background);
}

.pet-detail__name-input:focus {
  outline: none;
  border-color: #ff5964;
  box-shadow: 0 0 0 2px rgba(255, 89, 100, 0.2);
}

.pet-detail__preview-btn {
  position: relative;
  width: 100%;
  height: 3rem;
  padding: 0 1.25rem;
  background-color: var(--pet-selector-gray-100);
  border: none;
  border-radius: 40px;
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--pet-selector-gray-700);
  cursor: pointer;
  transition: background-color 0.2s;
}

.pet-detail__preview-btn:hover {
  background-color: var(--pet-selector-gray-200);
}

.pet-detail__file-input {
  position: absolute;
  inset: 0;
  opacity: 0;
  cursor: pointer;
}

.pet-detail__checkbox-row {
  margin-top: 0.5rem;
}

.pet-detail__checkbox-label {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  cursor: pointer;
  font-size: 0.875rem;
  font-weight: 500;
  color: var(--pet-selector-gray-700);
}

.pet-detail__checkbox {
  width: 1.15rem;
  height: 1.15rem;
  accent-color: #ff5964;
}

.pet-detail__order-input {
  margin-top: 0.5rem;
}

.pet-detail__order-number {
  width: 100%;
  height: 3rem;
  padding: 0 0.75rem;
  border: 1px solid var(--pet-selector-gray-300);
  border-radius: 0;
  font-size: 0.875rem;
  color: var(--pet-selector-text);
  background-color: var(--pet-selector-background);
}

.pet-detail__order-number:focus {
  outline: none;
  border-color: #ff5964;
  box-shadow: 0 0 0 2px rgba(255, 89, 100, 0.2);
}

/* Style Selector */
.style-selector__grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 1rem;
}

@media (min-width: 640px) {
  .style-selector__grid {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (min-width: 1024px) {
  .style-selector__grid {
    grid-template-columns: repeat(4, 1fr);
  }
}

.style-card {
  position: relative;
  cursor: pointer;
  display: block;
}

.style-card input {
  position: absolute;
  opacity: 0;
  width: 0;
  height: 0;
  /* MOBILE SCROLL FIX: Prevent browser scroll-into-view on focus */
  scroll-margin: 0;
  /* iOS-specific: prevent zoom on focus which triggers scroll */
  font-size: 16px;
}

.style-card__content {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  width: 100%;
}

.style-card--active .style-card__content .style-card__image-wrapper,
.style-card:has(input:checked) .style-card__content .style-card__image-wrapper {
  border-color: #ff5964;
}

.style-card__image-wrapper {
  position: relative;
  width: 100%;
  aspect-ratio: 1;
  border: 2px solid transparent;
  border-radius: 0.5rem;
  overflow: hidden;
  transition: all 0.2s;
}

.style-card__image {
  width: 100%;
  height: 100%;
  object-fit: cover;
  transition: opacity 0.2s, filter 0.2s;
}

/* Gray-out non-selected styles */
.style-card:not(.style-card--active):not(:has(input:checked)) .style-card__image {
  opacity: 0.5;
  filter: grayscale(30%);
}

.style-card:not(.style-card--active):not(:has(input:checked)) .style-card__label {
  opacity: 0.6;
}

/* Restore full color/opacity on hover */
.style-card:not(.style-card--active):not(:has(input:checked)):hover .style-card__image {
  opacity: 0.8;
  filter: grayscale(0%);
}

.style-card:not(.style-card--active):not(:has(input:checked)):hover .style-card__label {
  opacity: 1;
}

.style-card__label {
  font-size: 0.875rem;
  font-weight: 600;
  color: #000000;
  text-align: center;
  margin: 0;
  padding: 0;
  transition: opacity 0.2s;
}

/* Tooltip styles commented out
.style-card__tooltip {
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  margin-bottom: 0.5rem;
  padding: 0.5rem 0.75rem;
  background-color: #ffffff;
  color: #000000;
  font-size: 0.875rem;
  border-radius: 0.375rem;
  border: 1px solid #e5e7eb;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s;
  max-width: 16rem;
  white-space: normal;
}

.style-card:hover .style-card__tooltip {
  opacity: 1;
}
*/

/* Font Selector */
.font-selector__grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 1rem;
}

@media (min-width: 640px) {
  .font-selector__grid {
    grid-template-columns: repeat(3, 1fr);
  }
}

@media (min-width: 1024px) {
  .font-selector__grid {
    grid-template-columns: repeat(3, 1fr);
  }
}

.font-card {
  cursor: pointer;
  display: block;
}

.font-card input {
  position: absolute;
  opacity: 0;
  width: 0;
  height: 0;
}

.font-card__content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
  padding: 1rem;
  background-color: var(--pet-selector-background);
  border: 1px solid var(--pet-selector-gray-200);
  border-radius: 0.5rem;
  transition: all 0.2s;
  min-height: 7rem;
}

.font-card--active .font-card__content,
.font-card:has(input:checked) .font-card__content {
  border-color: #ff5964;
  box-shadow: 0 0 0 2px rgba(255, 89, 100, 0.3);
}

.font-card__title {
  font-size: 1rem;
  font-weight: 600;
  color: var(--pet-selector-gray-800);
  margin: 0;
}

.font-card__preview {
  font-size: 1.5rem;
  color: var(--pet-selector-gray-500);
  margin: 0;
  text-align: center;
  overflow: hidden;
  text-overflow: ellipsis;
}

.font-card__preview--icon {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 2.25rem;
}

.font-card__no-text-icon {
  width: 2rem;
  height: 2rem;
  fill: var(--pet-selector-gray-400);
}

/* Font-specific styles */
.font-card__preview--preppy {
  font-family: 'DM Serif Display', serif;
  text-transform: uppercase;
  text-decoration: underline overline;
  text-decoration-color: rgba(0, 0, 0, 0.5);
  text-decoration-thickness: 2px;
  text-underline-offset: 4px;
}

.font-card__preview--classic {
  font-family: 'DM Serif Display', serif;
}

.font-card__preview--playful {
  font-family: 'Notable', cursive;
}

.font-card__preview--elegant {
  font-family: 'Playball', cursive;
}

.font-card__preview--trend {
  font-family: 'Ultra', serif;
}

/* === Pet Detail Section Containers === */

/* Base section styling for combined pet section */
.pet-detail__section {
  margin-bottom: 0.5rem;
  padding: 1rem;
  border-radius: 0.5rem;
  background-color: var(--pet-selector-background);
  border: 1px solid var(--pet-selector-gray-100);
}

/* Combined section contains both name and photo */
.pet-detail__combined-section {
  /* Uses base .pet-detail__section styles */
}

/* Name group within combined section */
.pet-detail__name-group {
  margin-bottom: 1rem;        /* Space between name and photo groups */
}

/* Photo group within combined section */
.pet-detail__photo-group {
  /* No additional styling needed */
}

/* Section headings (not bold) */
.pet-detail__section-heading {
  font-size: 10px;
  font-weight: 400;           /* Normal weight (not bold) */
  color: var(--pet-selector-text);
  margin: 0 0 0.75rem 0;      /* 12px bottom spacing */
  line-height: 1.3;
}

/* Required field indicator (red asterisk) */
.required-indicator {
  color: #ff5964;
  margin-left: 2px;
  font-weight: 400;
}

/* Image actions container (vertical stack layout) */
.pet-detail__image-actions {
  display: flex;
  flex-direction: column;
  align-items: stretch;       /* Changed from center to stretch for full-width children */
  gap: 0.5rem;                /* 8px between elements - tighter grouping with upload zone */
}

/* Upload Zone - Drag and drop area */
.pet-detail__upload-zone {
  width: 100%;
  /* Removed max-width: 300px to match pet name field width */
  padding: 10px 1rem;
  border: 2px dashed var(--pet-selector-gray-300);
  border-radius: 0.5rem;
  background-color: var(--pet-selector-gray-50);
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
  text-align: center;
}

.pet-detail__upload-zone:hover {
  border-color: #ff5964;
  background-color: rgba(255, 89, 100, 0.05);
}

.pet-detail__upload-zone:focus {
  outline: none;
  border-color: #ff5964;
  box-shadow: 0 0 0 3px rgba(255, 89, 100, 0.2);
}

.pet-detail__upload-zone.dragover {
  border-color: #ff5964;
  background-color: rgba(255, 89, 100, 0.1);
}

.pet-detail__upload-zone.has-files {
  border: 2px solid #22c55e;              /* Solid border (not dashed) */
  background-color: rgba(34, 197, 94, 0.08); /* Slightly stronger green tint */
  padding: 5px 1rem;                       /* Reduced vertical padding for selected state */
}

/* Upload icon */
.pet-detail__upload-icon {
  width: 2.5rem;
  height: 2.5rem;
  color: var(--pet-selector-gray-400);
  transition: color 0.2s;
}

.pet-detail__upload-zone:hover .pet-detail__upload-icon,
.pet-detail__upload-zone.dragover .pet-detail__upload-icon {
  color: #ff5964;
}

.pet-detail__upload-zone.has-files .pet-detail__upload-icon {
  color: #22c55e;
}

/* Upload text */
.pet-detail__upload-text {
  font-size: 0.875rem;
  font-weight: 500;
  color: var(--pet-selector-gray-700);
}

.pet-detail__upload-zone.has-files .pet-detail__upload-text {
  font-weight: 600;        /* Semi-bold for "CHANGE IMAGE?" */
  color: #16a34a;          /* Darker green for readability */
}

.pet-detail__upload-hint {
  font-size: 0.75rem;
  color: var(--pet-selector-gray-500);
}

/* Checkbox label below upload zone */
.pet-detail__image-actions > .pet-detail__checkbox-label {
  font-size: 9.5px;
}

/* === Session Pet Gallery === */
/* Shows previously processed pets for quick reuse */

.session-pet-gallery {
  margin-bottom: 1rem;
  border: 1px solid var(--pet-selector-gray-200);
  border-radius: 0.5rem;
  background-color: var(--pet-selector-gray-50);
  overflow: hidden;
}

.session-pet-gallery__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.625rem 0.75rem;
  background-color: var(--pet-selector-background);
  border-bottom: 1px solid var(--pet-selector-gray-200);
}

.session-pet-gallery__label {
  font-size: 0.8125rem;
  font-weight: 600;
  color: var(--pet-selector-gray-700);
}

.session-pet-gallery__toggle {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  padding: 0;
  background: none;
  border: none;
  cursor: pointer;
  color: var(--pet-selector-gray-500);
  transition: transform 0.2s ease, color 0.2s ease;
}

.session-pet-gallery__toggle:hover {
  color: var(--pet-selector-gray-700);
}

.session-pet-gallery__toggle[aria-expanded="false"] .session-pet-gallery__toggle-icon {
  transform: rotate(-90deg);
}

.session-pet-gallery__pets {
  display: flex;
  gap: 0.75rem;
  padding: 0.75rem;
  overflow-x: auto;
  scroll-snap-type: x mandatory;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: thin;
}

.session-pet-gallery__pets::-webkit-scrollbar {
  height: 4px;
}

.session-pet-gallery__pets::-webkit-scrollbar-track {
  background: var(--pet-selector-gray-100);
  border-radius: 2px;
}

.session-pet-gallery__pets::-webkit-scrollbar-thumb {
  background: var(--pet-selector-gray-300);
  border-radius: 2px;
}

.session-pet-gallery__pets.collapsed {
  display: none;
}

/* Individual pet card in gallery */
.session-pet-card {
  flex-shrink: 0;
  width: 80px;
  scroll-snap-align: start;
  cursor: pointer;
  transition: transform 0.15s ease;
}

.session-pet-card:hover {
  transform: scale(1.02);
}

.session-pet-card:active {
  transform: scale(0.98);
}

.session-pet-card__image-wrapper {
  position: relative;
  width: 80px;
  height: 80px;
  border-radius: 0.375rem;
  overflow: hidden;
  border: 2px solid transparent;
  background-color: var(--pet-selector-gray-200);
  transition: border-color 0.2s ease;
}

.session-pet-card:hover .session-pet-card__image-wrapper,
.session-pet-card:focus .session-pet-card__image-wrapper {
  border-color: #ff5964;
}

.session-pet-card__image {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

/* Delete button - corner X with 48px touch target, 20px visual */
.session-pet-card__delete {
  position: absolute;
  top: -8px;
  right: -8px;
  width: 24px;
  height: 24px;
  padding: 0;
  border: none;
  border-radius: 50%;
  background-color: rgba(0, 0, 0, 0.7);
  color: #fff;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transition: opacity 0.15s ease, background-color 0.15s ease, transform 0.15s ease;
  z-index: 2;
}

/* Show delete button on card hover/focus */
.session-pet-card:hover .session-pet-card__delete,
.session-pet-card:focus .session-pet-card__delete,
.session-pet-card:focus-within .session-pet-card__delete {
  opacity: 1;
}

.session-pet-card__delete:hover {
  background-color: #dc2626;
  transform: scale(1.1);
}

.session-pet-card__delete:active {
  transform: scale(0.95);
}

/* Mobile: Always show delete button (no hover state) */
@media (hover: none) {
  .session-pet-card__delete {
    opacity: 1;
    width: 28px;
    height: 28px;
    top: -6px;
    right: -6px;
  }
}

.session-pet-card__badge {
  position: absolute;
  bottom: 4px;
  left: 50%;
  transform: translateX(-50%);
  padding: 2px 6px;
  background-color: rgba(0, 0, 0, 0.75);
  color: #fff;
  font-size: 0.625rem;
  font-weight: 600;
  border-radius: 3px;
  white-space: nowrap;
  text-transform: uppercase;
  letter-spacing: 0.02em;
}

.session-pet-card__meta {
  margin-top: 0.25rem;
  text-align: center;
}

.session-pet-card__age {
  font-size: 0.625rem;
  color: var(--pet-selector-gray-500);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Divider between gallery and upload zone */
.session-pet-gallery__divider {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0 0.75rem 0.625rem;
}

.session-pet-gallery__divider::before,
.session-pet-gallery__divider::after {
  content: '';
  flex: 1;
  height: 1px;
  background-color: var(--pet-selector-gray-300);
}

.session-pet-gallery__divider span {
  font-size: 0.6875rem;
  font-weight: 500;
  color: var(--pet-selector-gray-400);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

/* Mobile optimizations */
@media (max-width: 639px) {
  .session-pet-card {
    width: 72px;
  }

  .session-pet-card__image-wrapper {
    width: 72px;
    height: 72px;
  }

  .session-pet-gallery__pets {
    gap: 0.625rem;
    padding: 0.625rem;
  }
}

/* Touch device optimizations */
@media (hover: none) and (pointer: coarse) {
  .session-pet-card {
    min-width: 44px; /* Minimum touch target */
  }

  .session-pet-card:hover {
    transform: none;
  }

  .session-pet-card:active {
    transform: scale(0.96);
  }
}

/* === Upload Status and Preview Button Wrapper === */

/* Wrapper for upload status and Preview button - positioned side by side */
.pet-detail__upload-status-wrapper {
  display: flex;
  flex-direction: row;
  align-items: flex-start;
  gap: 0.75rem;
  width: 100%;
}

.pet-detail__upload-status-wrapper .pet-detail__upload-status {
  flex: 1;
  min-width: 0;
}

.pet-detail__upload-status-wrapper .pet-detail__preview-btn {
  flex-shrink: 0;
  width: auto;
  min-width: 100px;
}

/* Upload button with uploads indicator */
.pet-detail__upload-btn.has-uploads {
  background-color: #22c55e;
  color: white;
  font-weight: 600;
}

.pet-detail__upload-btn.has-uploads:hover {
  background-color: #16a34a;
}

/* Upload status display below pet name */
.pet-detail__upload-status {
  width: 100%;
  /* Removed max-width to match full-width upload zone */
  padding: 0.5rem;
  background-color: #f0fdf4;
  border-radius: 0.5rem;
  border: 1px solid #86efac;
}

.pet-detail__upload-status__file {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.25rem 0;
  font-size: 0.8125rem;
  color: #166534;
}

.pet-detail__upload-status__file-icon {
  flex-shrink: 0;
  font-size: 1rem;
}

.pet-detail__upload-status__file-name {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  font-weight: 500;
}

.pet-detail__upload-status__file-size {
  flex-shrink: 0;
  color: #16a34a;
  font-size: 0.75rem;
}

.pet-detail__upload-status__file-delete {
  flex-shrink: 0;

  /* VISUAL SIZE: Keep 24px for design consistency */
  width: 1.5rem;        /* 24px */
  height: 1.5rem;       /* 24px */

  /* Enable pseudo-element positioning */
  position: relative;

  /* Visual styling (unchanged) */
  border-radius: 50%;
  border: 1px solid #dc2626;
  background-color: white;
  color: #dc2626;
  font-size: 1rem;
  line-height: 1;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
  padding: 0;

  /* INCREASED SPACING: More room for fat-finger taps */
  margin-left: 0.75rem;  /* Was 0.25rem, now 0.75rem */

  /* Touch device optimization */
  -webkit-tap-highlight-color: rgba(220, 38, 38, 0.2);
  touch-action: manipulation;  /* Prevents double-tap zoom */
}

/* INVISIBLE TAP AREA EXPANSION: 44×44px for accessibility */
.pet-detail__upload-status__file-delete::before {
  content: '';
  position: absolute;

  /* CENTER the 44×44px tap area over 24×24px button */
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);

  /* MINIMUM TOUCH TARGET: 44×44px (WCAG 2.1 AAA) */
  width: 2.75rem;   /* 44px */
  height: 2.75rem;  /* 44px */

  /* Make it tappable but invisible */
  border-radius: 50%;

  /* DEBUG: Uncomment to visualize tap area during development */
  /* background-color: rgba(220, 38, 38, 0.1); */
  /* border: 1px dashed #dc2626; */
}

/* HOVER STATE: Desktop only (not touch devices) */
@media (hover: hover) and (pointer: fine) {
  .pet-detail__upload-status__file-delete:hover {
    background-color: #dc2626;
    color: white;
    transform: scale(1.1);
  }
}

/* ACTIVE STATE: Enhanced for touch devices */
.pet-detail__upload-status__file-delete:active {
  transform: scale(0.95);
  background-color: #dc2626;
  color: white;

  /* Haptic feedback hint (Safari iOS) */
  -webkit-tap-highlight-color: rgba(220, 38, 38, 0.4);
}

/* FOCUS STATE: Keyboard accessibility */
.pet-detail__upload-status__file-delete:focus {
  outline: 2px solid #dc2626;
  outline-offset: 2px;
}

/* MOBILE-SPECIFIC: Extra spacing on small screens */
@media (max-width: 640px) {
  .pet-detail__upload-status__file-delete {
    margin-left: 1rem;  /* Even more space on mobile */
  }
}

/* Processor Modal Styles */
.pet-processor-modal {
  position: fixed;
  inset: 0;
  z-index: 10000;
  display: flex;
  align-items: center;
  justify-content: center;
}

.pet-processor-modal__overlay {
  position: absolute;
  inset: 0;
  background-color: rgba(0, 0, 0, 0.75);
  backdrop-filter: blur(4px);
}

.pet-processor-modal__content {
  position: relative;
  width: 95%;
  max-width: 1200px;
  height: 90vh;
  background-color: white;
  border-radius: 1rem;
  box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.pet-processor-modal__close {
  position: absolute;
  top: 1rem;
  right: 1rem;
  width: 3rem;
  height: 3rem;
  border-radius: 50%;
  border: none;
  background-color: rgba(0, 0, 0, 0.5);
  color: white;
  font-size: 2rem;
  line-height: 1;
  cursor: pointer;
  transition: all 0.2s;
  z-index: 10;
  display: flex;
  align-items: center;
  justify-content: center;
}

.pet-processor-modal__close:hover {
  background-color: rgba(0, 0, 0, 0.8);
  transform: scale(1.1);
}

.pet-processor-modal__header {
  padding: 2rem;
  border-bottom: 1px solid var(--pet-selector-gray-200);
  background-color: var(--pet-selector-background);
}

.pet-processor-modal__header h2 {
  margin: 0 0 0.5rem 0;
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--pet-selector-text);
}

.pet-processor-modal__header p {
  margin: 0;
  font-size: 0.875rem;
  color: var(--pet-selector-gray-600);
}

.pet-processor-modal__body {
  flex: 1;
  overflow: hidden;
  background-color: var(--pet-selector-gray-50);
}

.pet-processor-modal__iframe {
  width: 100%;
  height: 100%;
  border: none;
}

/* Mobile Responsiveness */
@media (max-width: 639px) {
  .pet-processor-modal__content {
    width: 100%;
    height: 100vh;
    max-width: none;
    border-radius: 0;
  }

  .pet-processor-modal__header {
    padding: 1.5rem 1rem;
  }

  .pet-processor-modal__close {
    top: 0.5rem;
    right: 0.5rem;
    width: 2.5rem;
    height: 2.5rem;
    font-size: 1.5rem;
  }

  .pet-detail__upload-progress-wrapper {
    padding: 0.5rem;
  }

  .pet-detail__upload-progress-bar {
    height: 6px;
  }

  .pet-detail__upload-progress-text {
    font-size: 11px;
  }

  .pet-detail__preview-btn {
    min-height: 48px; /* Larger tap target */
    font-size: 18px;
    padding: 14px 28px;
  }
}

/* Upload Progress Bar */
.pet-detail__upload-progress-wrapper {
  margin-top: 0.5rem;
  padding: 0.75rem;
  background: #f8f9fa;
  border-radius: 8px;
}

.pet-detail__upload-progress-bar {
  width: 100%;
  height: 8px;
  background: #e9ecef;
  border-radius: 4px;
  overflow: hidden;
  margin-bottom: 0.5rem;
}

.pet-detail__upload-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #4CAF50, #66BB6A);
  width: 0%;
  transition: width 0.3s ease;
  border-radius: 4px;
}

.pet-detail__upload-progress-text {
  font-size: 12px;
  color: #495057;
  text-align: center;
  font-weight: 500;
}

/* Preview Button States */
.pet-detail__preview-btn {
  transition: all 0.2s ease;
  min-width: 120px;
  min-height: 44px;
  padding: 12px 24px;
  font-size: 16px;
  font-weight: 600;
  border-radius: 8px;
  cursor: pointer;
}

.pet-detail__preview-btn:not([disabled]) {
  background-color: #4CAF50;
  color: white;
  border: none;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.pet-detail__preview-btn:not([disabled]):hover {
  transform: scale(1.02);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.pet-detail__preview-btn:not([disabled]):active {
  transform: scale(0.98);
}

/* Disabled state (uploading or incomplete data) */
.pet-detail__preview-btn[disabled] {
  background-color: #E5E5E5;
  color: #666666;
  border: 1px solid #CCCCCC;
  cursor: not-allowed;
  opacity: 0.6;
  pointer-events: none;
  box-shadow: none;
}

/* Uploading animation */
.pet-detail__preview-btn.uploading::after {
  content: '';
  animation: ellipsis 1.5s infinite;
}

@keyframes ellipsis {
  0% { content: ''; }
  33% { content: '.'; }
  66% { content: '..'; }
  100% { content: '...'; }
}

/* Unlock pulse animation */
.pet-detail__preview-btn.just-unlocked {
  animation: pulse-ready 0.6s ease-in-out 2;
}

@keyframes pulse-ready {
  0%, 100% {
    transform: scale(1);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  50% {
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
  }
}

/* Offline mode indicator */
.pet-detail__preview-btn.offline-mode {
  background-color: #FF9800;
  color: white;
}

/* Screen reader only content */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

</style>

{% comment %} EXIF orientation library for image rotation correction and compression {% endcomment %}
<script src="https://cdn.jsdelivr.net/npm/blueimp-load-image@5.16.0/js/load-image.all.min.js"></script>

{% comment %} Session Pet Gallery - Shows previously processed pets for quick reuse {% endcomment %}
<script src="{{ 'session-pet-gallery.js' | asset_url }}" defer></script>

<script>
// Pet Selector Stitch - JavaScript
(function() {
  const container = document.querySelector('.pet-selector-stitch');
  if (!container) return;

  // ======================================================================
  // DIRECT UPLOAD HANDLER - Eliminates InSPyReNet API proxy bottleneck
  // ======================================================================
  class DirectUploadHandler {
    constructor() {
      this.geminiApiUrl = 'https://gemini-artistic-api-753651513695.us-central1.run.app';
      this.uploadTimeout = 60000; // 60 seconds
    }

    async uploadImage(file, sessionId, onProgress) {
      try {
        // Step 1: Get signed URL (<100ms)
        const signedUrlData = await this.getSignedUrl(sessionId, file.type);

        // Step 2: Direct upload to GCS
        await this.uploadToGCS(file, signedUrlData, onProgress);

        return { success: true, url: signedUrlData.public_url };

      } catch (error) {
        throw error;
      }
    }

    async getSignedUrl(sessionId, fileType) {
      const response = await fetch(`${this.geminiApiUrl}/api/v1/upload/signed-url`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          session_id: sessionId,
          file_type: fileType || 'image/jpeg'
        })
      });

      if (!response.ok) {
        throw new Error(`Failed to get signed URL: ${response.status}`);
      }

      return await response.json();
    }

    async uploadToGCS(file, signedUrlData, onProgress) {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();

        // Progress tracking disabled

        xhr.addEventListener('load', () => {
          if (xhr.status === 200 || xhr.status === 201) {
            resolve();
          } else {
            reject(new Error(`Upload failed: ${xhr.status}`));
          }
        });

        xhr.addEventListener('error', () => reject(new Error('Network error')));
        xhr.addEventListener('timeout', () => reject(new Error('Upload timeout')));

        xhr.open('PUT', signedUrlData.signed_url, true);
        xhr.setRequestHeader('Content-Type', signedUrlData.content_type);
        xhr.timeout = this.uploadTimeout;
        xhr.send(file);
      });
    }
  }

  const directUploadHandler = new DirectUploadHandler();

  // ======================================================================
  // DYNAMIC PET THUMBNAILS FOR STYLE CARDS
  // Updates style selector images with customer's actual pet (V5 pattern)
  // ======================================================================

  /**
   * Update style selection card images with actual processed pet images
   * Follows the proven V5 pattern from pet-processor.js
   * @param {Object} petData - Pet data object containing effects
   */
  function updateProductStyleCardPreviews(petData) {
    if (!petData || !petData.effects) {
      console.warn('[ProductStyleCards] No pet data or effects provided');
      return;
    }

    try {
      // Map effect keys to data-style-preview attribute values
      // Matches V5 pattern exactly
      const styleMap = {
        'enhancedblackwhite': 'bw',
        'color': 'color',
        'ink_wash': 'ink_wash',
        'sketch': 'sketch'
      };

      // Update each style card with the actual processed image
      Object.entries(styleMap).forEach(function([effectKey, previewAttr]) {
        const effectData = petData.effects[effectKey];
        const imgElement = container.querySelector('[data-style-preview="' + previewAttr + '"]');

        if (imgElement && effectData) {
          // Handle both string URLs (v3 format) and object format (legacy)
          let imageUrl;
          if (typeof effectData === 'string') {
            // V3 format: effect is stored as direct URL string
            imageUrl = effectData;
          } else {
            // Legacy format: effect is object with dataUrl/gcsUrl properties
            // For Gemini effects (ink_wash, sketch): prefer dataUrl (transparent version)
            // For BiRefNet effects (color, enhancedblackwhite): prefer gcsUrl (already transparent)
            imageUrl = effectData.dataUrl || effectData.gcsUrl;
          }

          if (imageUrl) {
            imgElement.src = imageUrl;
            imgElement.classList.add('style-card__image--dynamic');
            console.log('[ProductStyleCards] Updated ' + previewAttr + ' with pet image (' + (typeof effectData === 'string' ? 'v3' : 'legacy') + ')');
          }
        }
      });

      console.log('[ProductStyleCards] Style card previews updated with pet images');
    } catch (error) {
      console.error('[ProductStyleCards] Error updating style card previews:', error);
    }
  }

  /**
   * Reset style cards to static placeholder images
   * Called when pet selection is cleared or page loads without pet data
   */
  function resetStyleCardPreviews() {
    try {
      const styleImages = container.querySelectorAll('[data-style-preview]');
      styleImages.forEach(function(img) {
        const staticSrc = img.dataset.staticSrc;
        if (staticSrc) {
          img.src = staticSrc;
          img.classList.remove('style-card__image--dynamic');
        }
      });
      console.log('[ProductStyleCards] Style cards reset to static images');
    } catch (error) {
      console.error('[ProductStyleCards] Error resetting style cards:', error);
    }
  }

  /**
   * Initialize style cards on page load
   * Check if there's existing pet data (session restoration)
   */
  function initializeStyleCardThumbnails() {
    // Check sessionStorage for gallery-selected pet first
    for (var i = 1; i <= 3; i++) {
      var sessionData = sessionStorage.getItem('session_gallery_pet_' + i);
      if (sessionData) {
        try {
          var petData = JSON.parse(sessionData);
          if (petData && petData.effects) {
            console.log('[ProductStyleCards] Restoring thumbnails from session gallery selection');
            updateProductStyleCardPreviews(petData);
            return; // Use first found pet
          }
        } catch (e) {
          console.warn('[ProductStyleCards] Failed to parse session pet data:', e);
        }
      }
    }

    // Fallback: Check PetStorage for recent pets
    if (window.PetStorage && typeof window.PetStorage.getRecentPets === 'function') {
      var recentPets = window.PetStorage.getRecentPets(1);
      if (recentPets && recentPets.length > 0) {
        // Only update if pet was processed recently (within last hour)
        var latestPet = recentPets[0];
        var oneHourAgo = Date.now() - (60 * 60 * 1000);
        if (latestPet.timestamp && latestPet.timestamp > oneHourAgo) {
          console.log('[ProductStyleCards] Initializing thumbnails from recent pet');
          updateProductStyleCardPreviews(latestPet);
        }
      }
    }
  }

  // Listen for session gallery pet selection
  document.addEventListener('sessionPetSelected', function(e) {
    var petData = e.detail && e.detail.petData;
    if (petData && petData.effects) {
      console.log('[ProductStyleCards] Pet selected from session gallery, updating thumbnails');
      updateProductStyleCardPreviews(petData);
    }
  });

  // Listen for inline preview completion
  document.addEventListener('inlinePreviewClosed', function(e) {
    // After modal closes, check if we have updated pet data
    setTimeout(function() {
      if (window.PetStorage && typeof window.PetStorage.getRecentPets === 'function') {
        var recentPets = window.PetStorage.getRecentPets(1);
        if (recentPets && recentPets.length > 0) {
          var latestPet = recentPets[0];
          console.log('[ProductStyleCards] Inline preview completed, updating thumbnails');
          updateProductStyleCardPreviews(latestPet);
        }
      }
    }, 100); // Small delay to ensure PetStorage is updated
  });

  // Listen for selection cleared
  document.addEventListener('sessionPetCleared', function(e) {
    resetStyleCardPreviews();
  });

  // Initialize on DOMContentLoaded (if not already loaded)
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeStyleCardThumbnails);
  } else {
    // DOM already loaded, initialize after a short delay for PetStorage
    setTimeout(initializeStyleCardThumbnails, 200);
  }

  // ======================================================================
  // END DYNAMIC PET THUMBNAILS
  // ======================================================================

  const maxPets = parseInt(container.dataset.maxPets) || 1;
  const petDetailsContainer = container.querySelector('[data-pet-details-container]');
  const countRadios = container.querySelectorAll('[data-pet-count-radio]');
  const fontPreviews = container.querySelectorAll('[data-font-preview]');

  // Update visible pet sections based on count
  function updatePetSections(count) {
    const petDetails = petDetailsContainer.querySelectorAll('.pet-detail');
    petDetails.forEach((detail, index) => {
      if (index < count) {
        detail.style.display = '';
      } else {
        detail.style.display = 'none';
      }
    });

    // Update pet count buttons
    const countBtns = container.querySelectorAll('.pet-count-btn');
    countBtns.forEach((btn) => {
      btn.classList.remove('pet-count-btn--active');
      if (btn.querySelector('input').checked) {
        btn.classList.add('pet-count-btn--active');
      }
    });

    // Show Pet Details section when pet count is selected (progressive disclosure)
    const petDetailsSection = container.querySelector('[data-pet-details-section]');
    if (petDetailsSection) {
      petDetailsSection.hidden = (count === 0);
    }

    updateFontPreviews();
    toggleStyleSection(); // Update style section visibility when pet count changes
    toggleFontSection();  // Update font section visibility (requires pet name)
  }

  // Update font previews with ampersand formatting (matches old font-selector)
  function updateFontPreviews() {
    const visiblePets = [...petDetailsContainer.querySelectorAll('.pet-detail')]
      .filter(detail => detail.style.display !== 'none');

    const petNames = visiblePets.map(detail => {
      const input = detail.querySelector('[data-pet-name-input]');
      return input.value.trim() || `Pet ${detail.dataset.petIndex}`;
    });

    // Format names with ampersand logic (matches PetNameFormatter)
    let previewText = '';
    if (petNames.length === 0) {
      previewText = '';
    } else if (petNames.length === 1) {
      previewText = petNames[0];
    } else if (petNames.length === 2) {
      // 2 pets: "Sam & Buddy"
      previewText = petNames[0] + ' & ' + petNames[1];
    } else {
      // 3+ pets: "Sam, Buddy & Max" (no Oxford comma)
      const lastPet = petNames[petNames.length - 1];
      const otherPets = petNames.slice(0, -1);
      previewText = otherPets.join(', ') + ' & ' + lastPet;
    }

    fontPreviews.forEach(preview => {
      const textSpan = preview.querySelector('.font-preview-text');
      if (textSpan) {
        textSpan.textContent = previewText;
      }
    });
  }

  // Toggle style section visibility based on whether any pet has a name
  function toggleStyleSection() {
    const styleSection = container.querySelector('[data-style-section]');
    if (!styleSection) return;

    // Check if any visible pet has a name entered
    const visiblePets = [...petDetailsContainer.querySelectorAll('.pet-detail')]
      .filter(detail => detail.style.display !== 'none');

    const hasAnyName = visiblePets.some(detail => {
      const input = detail.querySelector('[data-pet-name-input]');
      return input && input.value.trim().length > 0;
    });

    // Show/hide style section based on whether any pet has a name
    if (hasAnyName) {
      styleSection.hidden = false;
      console.log('🎨 Style section shown (pet name entered)');
    } else {
      styleSection.hidden = true;
      console.log('🎨 Style section hidden (no pet names)');
    }
  }

  // Toggle font section visibility based on whether any pet has a name
  // (Only shows after customer enters pet name - progressive disclosure)
  function toggleFontSection() {
    const fontSection = container.querySelector('[data-font-section]');
    if (!fontSection) return;

    // Check if any visible pet has a name entered
    const visiblePets = [...petDetailsContainer.querySelectorAll('.pet-detail')]
      .filter(detail => detail.style.display !== 'none');

    // If no pets are visible (count = 0), keep font section hidden
    if (visiblePets.length === 0) {
      fontSection.hidden = true;
      return;
    }

    const hasAnyName = visiblePets.some(detail => {
      const input = detail.querySelector('[data-pet-name-input]');
      return input && input.value.trim().length > 0;
    });

    // Show/hide font section based on whether any pet has a name
    if (hasAnyName) {
      fontSection.hidden = false;
      console.log('🔤 Font section shown (pet name entered)');
    } else {
      fontSection.hidden = true;
      console.log('🔤 Font section hidden (no pet names)');
    }
  }

  // NEW: Update variant selection based on pet count by triggering Shopify's variant selector
  function updateVariantSelection(petCount) {
    console.log(`🔄 Updating variant for ${petCount} pet(s)`);

    // Determine target variant text
    const petCountText = petCount === 1 ? '1 Pet' : `${petCount} Pets`;

    // CRITICAL FIX: Find Shopify's variant-selects component and trigger its inputs
    // This uses Shopify's built-in pub/sub system instead of manually updating values
    const variantSelectsComponent = document.querySelector('variant-selects');
    if (!variantSelectsComponent) {
      console.warn('⚠️ variant-selects element not found - cannot update variant');
      return;
    }

    // Strategy: Find the radio button or select option that matches our pet count
    // and simulate a user click/change to trigger Shopify's event flow

    // Try radio buttons first (most common)
    const variantRadios = variantSelectsComponent.querySelectorAll('input[type="radio"]');

    let matchingInput = null;
    variantRadios.forEach(radio => {
      // Get the label for this radio to check the text
      const label = variantSelectsComponent.querySelector(`label[for="${radio.id}"]`);
      if (label) {
        const labelText = label.textContent.trim();

        // Check if label text starts with our pet count (e.g., "1 Pet" or "1 Pet / 5" x 7"")
        if (labelText.startsWith(petCountText)) {
          matchingInput = radio;
        }
      }
    });

    // Fallback: Try select dropdowns if no radio button found
    if (!matchingInput) {
      const selectDropdowns = variantSelectsComponent.querySelectorAll('select');

      selectDropdowns.forEach(select => {
        const options = select.querySelectorAll('option');
        options.forEach(option => {
          const optionText = option.textContent.trim();

          if (optionText.startsWith(petCountText)) {
            matchingInput = select;
            select.value = option.value;
          }
        });
      });
    }

    if (!matchingInput) {
      console.warn(`⚠️ No variant input found matching "${petCountText}"`);
      return;
    }

    // CRITICAL: Simulate real user interaction to trigger Shopify's event flow
    // This causes Shopify to:
    // 1. Publish optionValueSelectionChange event
    // 2. product-info subscribes and fetches new HTML
    // 3. Updates price, inventory, etc.
    // 4. Publishes variantChange for other components

    if (matchingInput.tagName === 'INPUT') {
      // For radio buttons: check and trigger click + change events
      matchingInput.checked = true;

      // Dispatch both click and change for maximum compatibility
      const clickEvent = new MouseEvent('click', {
        view: window,
        bubbles: true,
        cancelable: true
      });
      matchingInput.dispatchEvent(clickEvent);

      const changeEvent = new Event('change', {
        bubbles: true,
        cancelable: true
      });
      matchingInput.dispatchEvent(changeEvent);
    } else if (matchingInput.tagName === 'SELECT') {
      // For select dropdowns: trigger change event
      const changeEvent = new Event('change', {
        bubbles: true,
        cancelable: true
      });
      matchingInput.dispatchEvent(changeEvent);
    }

    console.log('✅ Variant selection updated');
  }

  // Store pet fee variant ID based on pet count selection
  function storePetFeeVariant(count, feeVariantId) {
    const feeInput = container.querySelector('[data-pet-fee-variant-input]');
    if (feeInput) {
      // Only store fee variant for 2+ pets
      feeInput.value = count > 1 ? feeVariantId : '';
      console.log(`💰 Pet fee variant ${count > 1 ? 'set to: ' + feeVariantId : 'cleared (1 pet)'}`);
    }
    // Store pet count on container for cart submission logic
    container.setAttribute('data-selected-pet-count', count);
  }

  // Pet count change listener
  countRadios.forEach(radio => {
    radio.addEventListener('change', (e) => {
      const count = parseInt(e.target.value);
      const feeVariantId = e.target.dataset.feeVariant || '';
      updatePetSections(count);
      // REPLACED: updateVariantSelection(count) - fee now handled via separate product line item
      storePetFeeVariant(count, feeVariantId);
      savePetSelectorStateImmediate(); // Save immediately on selection
    });
  });

  // Pet name input listeners
  const nameInputs = container.querySelectorAll('[data-pet-name-input]');
  nameInputs.forEach(input => {
    input.addEventListener('input', () => {
      updateFontPreviews();
      toggleStyleSection(); // Show/hide style section based on pet names
      toggleFontSection();  // Show/hide font section based on pet names
      savePetSelectorState(); // Save with debounce on typing
    });
  });

  // Existing Perkie Print checkbox listeners
  for (let i = 1; i <= 3; i++) {
    const checkbox = container.querySelector(`[data-existing-print-checkbox="${i}"]`);
    const orderInput = container.querySelector(`[data-order-number-input="${i}"]`);

    if (checkbox && orderInput) {
      checkbox.addEventListener('change', () => {
        orderInput.style.display = checkbox.checked ? '' : 'none';

        // Set order type to "Returning" when using existing print
        const orderTypeField = document.getElementById(`order-type-${i}`);
        const processingStateField = document.getElementById(`processing-state-${i}`);
        const uploadTimestampField = document.getElementById(`upload-timestamp-${i}`);

        if (checkbox.checked) {
          // Using existing print - mark as returning customer
          if (orderTypeField) {
            orderTypeField.value = 'Returning';
          }
          if (processingStateField) {
            processingStateField.value = 'existing_print';
          }
          if (uploadTimestampField) {
            uploadTimestampField.value = new Date().toISOString();
          }
        } else {
          // Unchecked - clear the fields (will be set on file upload)
          if (orderTypeField) {
            orderTypeField.value = '';
          }
          if (processingStateField) {
            processingStateField.value = '';
          }
          if (uploadTimestampField) {
            uploadTimestampField.value = '';
          }
        }
      });
    }
  }

  // Style card click handler
  const styleCards = container.querySelectorAll('.style-card');
  styleCards.forEach(card => {
    card.addEventListener('click', () => {
      styleCards.forEach(c => c.classList.remove('style-card--active'));
      card.classList.add('style-card--active');
      savePetSelectorStateImmediate(); // Save immediately on selection

      // Trigger validation to update Add to Cart button
      if (window.CartPetIntegration && typeof window.CartPetIntegration.validateAndUpdateButton === 'function') {
        window.CartPetIntegration.validateAndUpdateButton();
      }
    });
  });

  // Font card click handler
  const fontCards = container.querySelectorAll('.font-card');
  fontCards.forEach(card => {
    card.addEventListener('click', () => {
      fontCards.forEach(c => c.classList.remove('font-card--active'));
      card.classList.add('font-card--active');
      savePetSelectorStateImmediate(); // Save immediately on selection

      // Trigger validation to update Add to Cart button
      if (window.CartPetIntegration && typeof window.CartPetIntegration.validateAndUpdateButton === 'function') {
        window.CartPetIntegration.validateAndUpdateButton();
      }
    });
  });

  // Style radio button change listeners (direct radio clicks)
  const styleRadios = container.querySelectorAll('[data-style-radio]');
  styleRadios.forEach(radio => {
    radio.addEventListener('change', () => {
      // Trigger validation to update Add to Cart button
      if (window.CartPetIntegration && typeof window.CartPetIntegration.validateAndUpdateButton === 'function') {
        window.CartPetIntegration.validateAndUpdateButton();
      }
    });
  });

  // Font radio button change listeners (direct radio clicks)
  const fontRadios = container.querySelectorAll('[data-font-radio]');
  fontRadios.forEach(radio => {
    radio.addEventListener('change', () => {
      // Trigger validation to update Add to Cart button
      if (window.CartPetIntegration && typeof window.CartPetIntegration.validateAndUpdateButton === 'function') {
        window.CartPetIntegration.validateAndUpdateButton();
      }
    });
  });

  // Upload button handlers - Native Shopify file upload (files uploaded to CDN)
  // Track uploaded files per pet (persistent across multiple uploads)
  const petFiles = {
    1: [],
    2: [],
    3: []
  };

  // Generate unique session ID for this page load (used for server uploads)
  const sessionId = 'pet_selector_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

  // Image compression and orientation correction
  // Reduces file size by 85-90% (5-8MB → 500KB-1MB) for faster uploads
  async function correctImageOrientation(file) {
    // Check if library is loaded
    if (typeof loadImage === 'undefined') {
      console.warn('🔄 blueimp-load-image not loaded, uploading original file');
      return file;
    }

    // Skip orientation correction for non-JPEG files (PNG/WebP don't have EXIF)
    if (!file.type.includes('jpeg') && !file.type.includes('jpg')) {
      console.log('🔄 Non-JPEG file, compressing without orientation correction');
      // Still compress non-JPEG files for performance
    }

    return new Promise((resolve, reject) => {
      loadImage(
        file,
        (canvas) => {
          // Check if canvas is valid
          if (canvas.type === 'error') {
            console.warn('🔄 Failed to load image for orientation correction');
            resolve(file); // Return original file on error
            return;
          }

          // Convert canvas to blob then to File
          canvas.toBlob(
            (blob) => {
              if (!blob) {
                console.warn('🔄 Failed to convert canvas to blob');
                resolve(file);
                return;
              }

              // Create new File object with corrected orientation and compression
              const correctedFile = new File([blob], file.name, {
                type: 'image/jpeg',
                lastModified: Date.now()
              });

              const originalSizeMB = (file.size / 1024 / 1024).toFixed(2);
              const compressedSizeMB = (correctedFile.size / 1024 / 1024).toFixed(2);
              const reduction = ((1 - correctedFile.size / file.size) * 100).toFixed(0);

              console.log(`✅ Image optimized: ${originalSizeMB}MB → ${compressedSizeMB}MB (${reduction}% reduction)`);
              resolve(correctedFile);
            },
            'image/jpeg',
            0.95 // 95% quality - imperceptible quality loss, significant size reduction
          );
        },
        {
          orientation: true,  // Auto-orient based on EXIF (fixes rotated iPhone photos)
          canvas: true,       // Return canvas (not img element)
          maxWidth: 3000,     // Limit size to prevent memory issues (good for web)
          maxHeight: 3000
        }
      );
    });
  }

  // Upload progress tracking - REMOVED per user request

  // Update preview button state (disabled/enabled based on conditions)
  function updatePreviewButtonState(petIndex) {
    const previewBtn = container.querySelector(`[data-pet-preview-btn="${petIndex}"]`);
    const uploadZone = container.querySelector(`[data-upload-zone="${petIndex}"]`);
    const statusText = document.getElementById(`preview-status-${petIndex}`);

    if (!previewBtn) return;

    // Check conditions
    const isUploading = uploadZone?.classList.contains('uploading');
    const hasImage = localStorage.getItem(`pet_${petIndex}_image_url`) ||
                     (localStorage.getItem(`pet_${petIndex}_images`) &&
                      JSON.parse(localStorage.getItem(`pet_${petIndex}_images`)).length > 0);

    // State logic
    if (isUploading) {
      previewBtn.disabled = true;
      previewBtn.textContent = 'Uploading...';
      previewBtn.classList.add('uploading');
      if (statusText) statusText.textContent = 'Image is uploading, please wait...';
    } else if (!hasImage) {
      previewBtn.disabled = true;
      previewBtn.textContent = 'Upload Image First';
      previewBtn.classList.remove('uploading');
      if (statusText) statusText.textContent = 'Please upload an image first';
    } else {
      // All conditions met - enable button
      previewBtn.disabled = false;
      previewBtn.textContent = 'Preview';
      previewBtn.classList.remove('uploading');
      if (statusText) statusText.textContent = 'Ready to preview';

      // Add unlock animation (once)
      if (!previewBtn.classList.contains('unlocked-once')) {
        previewBtn.classList.add('just-unlocked', 'unlocked-once');
        setTimeout(() => previewBtn.classList.remove('just-unlocked'), 1200);
      }
    }
  }

  // Server upload function with automatic retry and fallback
  // ======================================================================
  // UPLOAD TO SERVER - Direct GCS upload with InSPyReNet fallback
  // ======================================================================
  async function uploadToServer(file, petIndex, retryCount = 0) {
    const maxRetries = 3;
    const retryDelays = [0, 1000, 3000]; // 0ms, 1s, 3s exponential backoff

    // Try direct GCS upload first (75% faster)
    if (retryCount === 0) {
      try {
        const result = await directUploadHandler.uploadImage(file, sessionId, null);
        return result;
      } catch (error) {
        // Fall through to InSPyReNet fallback below
      }
    }

    // Fallback to InSPyReNet API (original method)
    try {
      console.log(`📤 Fallback: Uploading Pet ${petIndex} via InSPyReNet API (attempt ${retryCount + 1})`);

      const formData = new FormData();
      formData.append('file', file, file.name);
      formData.append('image_type', 'original');
      formData.append('tier', 'temporary');
      formData.append('session_id', sessionId);

      const response = await fetch(
        'https://inspirenet-bg-removal-api-725543555429.us-central1.run.app/store-image',
        {
          method: 'POST',
          body: formData,
          signal: AbortSignal.timeout(30000) // 30 second timeout
        }
      );

      if (!response.ok) {
        throw new Error(`Upload failed: ${response.status}`);
      }

      const result = await response.json();

      if (result.success && result.url) {
        console.log(`✅ InSPyReNet fallback succeeded for Pet ${petIndex}`);
        return { success: true, url: result.url };
      } else {
        throw new Error('No URL in response');
      }

    } catch (error) {
      console.warn(`Upload attempt ${retryCount + 1} failed for Pet ${petIndex}:`, error.message);

      // Retry logic
      if (retryCount < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, retryDelays[retryCount + 1]));
        return uploadToServer(file, petIndex, retryCount + 1);
      }

      // All retries exhausted
      return { success: false, error: error.message };
    }
  }

  for (let i = 1; i <= 3; i++) {
    const uploadZone = container.querySelector(`[data-upload-zone="${i}"]`);
    const uploadText = container.querySelector(`[data-upload-text="${i}"]`);
    const fileInput = container.querySelector(`[data-pet-file-input="${i}"]`);
    const previewBtn = container.querySelector(`[data-pet-preview-btn="${i}"]`);

    if (uploadZone && fileInput) {
      const maxFiles = parseInt(fileInput.dataset.maxFiles) || 3;

      // Click upload zone triggers file input
      uploadZone.addEventListener('click', (e) => {
        e.preventDefault();
        fileInput.click();
      });

      // Keyboard support for upload zone
      uploadZone.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          fileInput.click();
        }
      });

      // Drag and drop support
      uploadZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadZone.classList.add('dragover');
      });

      uploadZone.addEventListener('dragleave', (e) => {
        e.preventDefault();
        uploadZone.classList.remove('dragover');
      });

      uploadZone.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadZone.classList.remove('dragover');

        const files = e.dataTransfer.files;
        if (files.length > 0) {
          // Manually trigger file input change with dropped files
          const dataTransfer = new DataTransfer();
          for (let j = 0; j < files.length; j++) {
            dataTransfer.items.add(files[j]);
          }
          fileInput.files = dataTransfer.files;
          fileInput.dispatchEvent(new Event('change', { bubbles: true }));
        }
      });

      // Handle file selection (replacement - single file only)
      fileInput.addEventListener('change', async (e) => {
        const newFiles = Array.from(e.target.files);

        // Validation 1: File selection
        if (newFiles.length === 0) {
          return; // User cancelled
        }

        // Single file only (file input has no 'multiple' attribute)
        const newFile = newFiles[0];

        // Validation 2: File size (max 50MB per Shopify)
        if (newFile.size > 50 * 1024 * 1024) {
          alert(`${newFile.name} is too large. Max 50MB per file.`);
          fileInput.value = '';
          return;
        }

        // Validation 3: File type (must be image)
        if (!newFile.type.startsWith('image/')) {
          alert(`${newFile.name} is not an image file. Please select JPG, PNG, or HEIC.`);
          fileInput.value = '';
          return;
        }

        // Replace existing file (not additive)
        petFiles[i] = [newFile];

        // Clear file input to allow re-uploading same files if deleted
        fileInput.value = '';

        // OPTIMISTIC UI: Show file immediately (before upload completes)
        uploadText.textContent = 'Uploading...';
        uploadZone.classList.add('has-files', 'uploading');
        updatePreviewButtonState(i); // Disable button during upload

        // Show uploaded file names below pet name
        displayUploadedFiles(i, petFiles[i]);

        // Populate order properties and update file input with all files
        updateFileInputWithAllFiles(i, petFiles[i]);
        populateOrderProperties(i, petFiles[i]);

        // Save state after file upload
        savePetSelectorStateImmediate();

        // COMPRESS IMAGE: Reduce file size before upload (5-8MB → 500KB-1MB)
        const compressionStart = performance.now();
        console.log(`🔄 Compressing image for Pet ${i}...`);
        const compressedFile = await correctImageOrientation(newFile);
        const compressionTime = performance.now() - compressionStart;
        console.log(`⏱️ Compression took ${compressionTime.toFixed(0)}ms`);

        // SERVER UPLOAD: Upload compressed file to server (much faster!)
        const uploadStart = performance.now();
        const uploadResult = await uploadToServer(compressedFile, i);
        const uploadTime = performance.now() - uploadStart;
        console.log(`⏱️ Upload took ${uploadTime.toFixed(0)}ms (${(uploadTime/1000).toFixed(1)}s)`);

        if (uploadResult.success) {
          // SUCCESS: Store GCS URL (100 bytes instead of 3.4MB base64!)
          localStorage.setItem(`pet_${i}_image_url`, uploadResult.url);

          uploadText.textContent = 'CHANGE IMAGE?';
          uploadZone.classList.remove('uploading');

          // Enable preview button with pulse animation
          updatePreviewButtonState(i);

          console.log(`✅ Pet ${i} uploaded to server:`, uploadResult.url);

        } else {
          // FALLBACK: Use localStorage base64 (offline mode)
          console.warn(`⚠️ Server upload failed for Pet ${i}, using offline mode`);

          const reader = new FileReader();
          reader.onload = (event) => {
            const previewData = [{
              name: compressedFile.name,
              data: event.target.result, // Base64 fallback (compressed!)
              size: compressedFile.size,
              type: compressedFile.type
            }];
            localStorage.setItem(`pet_${i}_images`, JSON.stringify(previewData));

            uploadText.textContent = 'CHANGE IMAGE? (Offline)';
            uploadZone.classList.remove('uploading');

            // Enable preview button (offline mode works)
            const previewBtn = container.querySelector(`[data-pet-preview-btn="${i}"]`);
            if (previewBtn) {
              previewBtn.disabled = false;
              previewBtn.textContent = 'Preview (Offline)';
              previewBtn.classList.remove('uploading');
              previewBtn.classList.add('offline-mode');
            }

            console.log(`💾 Pet ${i} stored offline (compressed base64 fallback)`);
          };
          reader.readAsDataURL(compressedFile);
        }

        // Save file metadata (for state restoration)
        const fileMetadata = petFiles[i].map(file => ({
          name: file.name,
          size: file.size,
          type: file.type
        }));
        localStorage.setItem(`pet_${i}_file_metadata`, JSON.stringify(fileMetadata));
      });

      // Display uploaded file names with sizes and delete buttons
      function displayUploadedFiles(petIndex, files) {
        const statusWrapper = container.querySelector(`[data-upload-status-wrapper="${petIndex}"]`);
        const statusContainer = container.querySelector(`[data-upload-status="${petIndex}"]`);
        if (!statusWrapper || !statusContainer) return;

        if (files.length === 0) {
          statusWrapper.style.display = 'none';
          statusContainer.innerHTML = '';
          return;
        }

        // Build HTML for file list
        let html = '';
        for (let j = 0; j < files.length; j++) {
          const fileName = files[j].name;
          const fileSize = formatFileSize(files[j].size);

          html += `
            <div class="pet-detail__upload-status__file" data-file-index="${j}">
              <span class="pet-detail__upload-status__file-icon">✓</span>
              <span class="pet-detail__upload-status__file-name">${escapeHtml(fileName)}</span>
              <span class="pet-detail__upload-status__file-size">${fileSize}</span>
              <button type="button"
                      class="pet-detail__upload-status__file-delete"
                      data-pet-index="${petIndex}"
                      data-file-index="${j}"
                      aria-label="Delete ${escapeHtml(fileName)}">×</button>
            </div>
          `;
        }

        statusContainer.innerHTML = html;
        statusWrapper.style.display = 'flex';

        // Attach delete button handlers
        const deleteButtons = statusContainer.querySelectorAll('.pet-detail__upload-status__file-delete');
        deleteButtons.forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            const petIdx = parseInt(btn.dataset.petIndex);
            const fileIdx = parseInt(btn.dataset.fileIndex);
            removeFile(petIdx, fileIdx);
          });
        });
      }

      // Remove a file from the uploaded files list
      function removeFile(petIndex, fileIndex) {
        // Remove from petFiles array
        if (fileIndex < 0 || fileIndex >= petFiles[petIndex].length) {
          return;
        }

        petFiles[petIndex].splice(fileIndex, 1);

        // Update UI (single file - always returns to empty after delete)
        const uploadZone = container.querySelector(`[data-upload-zone="${petIndex}"]`);
        const uploadText = container.querySelector(`[data-upload-text="${petIndex}"]`);
        uploadText.textContent = 'Click or drag to upload';
        uploadZone.classList.remove('has-files');

        // Re-render file list
        displayUploadedFiles(petIndex, petFiles[petIndex]);

        // Update file input with remaining files
        updateFileInputWithAllFiles(petIndex, petFiles[petIndex]);
        populateOrderProperties(petIndex, petFiles[petIndex]);

        // Save state after file deletion
        savePetSelectorStateImmediate();

        // Update preview if first file was removed
        if (petFiles[petIndex].length > 0) {
          const reader = new FileReader();
          reader.onload = (event) => {
            const previewData = [{
              name: petFiles[petIndex][0].name,
              data: event.target.result,
              size: petFiles[petIndex][0].size,
              type: petFiles[petIndex][0].type
            }];
            localStorage.setItem(`pet_${petIndex}_images`, JSON.stringify(previewData));
          };
          reader.readAsDataURL(petFiles[petIndex][0]);

          // NEW: Update file metadata in localStorage after deletion
          const fileMetadata = petFiles[petIndex].map(file => ({
            name: file.name,
            size: file.size,
            type: file.type
          }));
          localStorage.setItem(`pet_${petIndex}_file_metadata`, JSON.stringify(fileMetadata));
          console.log(`💾 Updated metadata after deletion: ${fileMetadata.length} files for Pet ${petIndex}`);
        } else {
          localStorage.removeItem(`pet_${petIndex}_images`);
          // NEW: Remove metadata when no files remain
          localStorage.removeItem(`pet_${petIndex}_file_metadata`);
          console.log(`🗑️ Removed metadata for Pet ${petIndex} (no files remaining)`);
        }
      }

      // Update file input with all current files using DataTransfer API
      function updateFileInputWithAllFiles(petIndex, files) {
        const fileInput = container.querySelector(`[data-pet-file-input="${petIndex}"]`);
        if (!fileInput) return;

        try {
          // Check if DataTransfer is supported
          const dataTransfer = new DataTransfer();

          // Add all files to DataTransfer
          for (let j = 0; j < files.length; j++) {
            dataTransfer.items.add(files[j]);
          }

          // Update file input with new FileList
          fileInput.files = dataTransfer.files;
        } catch (e) {
          console.warn('DataTransfer API not supported, file input may not update correctly:', e);
        }
      }

      // Format file size for display
      function formatFileSize(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
      }

      // Escape HTML to prevent XSS
      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      // Populate hidden order properties for tracking
      function populateOrderProperties(petIndex, files) {
        const orderTypeField = document.getElementById(`order-type-${petIndex}`);
        const processingStateField = document.getElementById(`processing-state-${petIndex}`);
        const uploadTimestampField = document.getElementById(`upload-timestamp-${petIndex}`);

        if (orderTypeField) {
          orderTypeField.value = 'Express Upload';
        }

        if (processingStateField) {
          processingStateField.value = 'uploaded_only';
        }

        if (uploadTimestampField) {
          uploadTimestampField.value = new Date().toISOString();
        }

        // Note: Shopify file input automatically handles the file upload when form submits
        // Files are attached to properties[Pet X Images] and uploaded to Shopify CDN
      }
    }
  }

  // Preview button handlers - Show modal with image processor
  for (let i = 1; i <= 3; i++) {
    const previewBtn = container.querySelector(`[data-pet-preview-btn="${i}"]`);

    if (previewBtn) {
      previewBtn.addEventListener('click', (e) => {
        e.preventDefault();

        // Check for Session Gallery pet first (pre-processed effects already available)
        const sessionGalleryData = sessionStorage.getItem(`session_gallery_pet_${i}`);
        if (sessionGalleryData && window.inlinePreview && typeof window.inlinePreview.openWithPreProcessedEffects === 'function') {
          try {
            const petData = JSON.parse(sessionGalleryData);
            console.log(`🎨 Opening pre-processed effects from Session Gallery for Pet ${i}:`, petData);

            // Get pet name from input or use fallback
            const petName = getPetName(i);

            // Open modal with pre-processed effects (skip processing)
            window.inlinePreview.openWithPreProcessedEffects({
              petNumber: i,
              petName: petName,
              sessionKey: petData.sessionKey,
              selectedEffect: petData.selectedEffect,
              effects: petData.effects,
              artistNote: petData.artistNote || ''
            });
            return;
          } catch (parseError) {
            console.warn(`⚠️ Failed to parse session gallery data for Pet ${i}, falling back to normal flow:`, parseError);
            // Continue to normal flow if parsing fails
          }
        }

        // Check for GCS URL first (NEW format - server-first upload)
        const gcsUrl = localStorage.getItem(`pet_${i}_image_url`);

        if (gcsUrl) {
          // GCS URL exists - use server-first path
          console.log(`🎨 Opening processor with GCS URL for Pet ${i}:`, gcsUrl);
          openProcessorModal(gcsUrl, i);
          return;
        }

        // Fallback: Check for base64 images (OLD format - offline mode)
        const storedImages = localStorage.getItem(`pet_${i}_images`);
        const images = storedImages ? JSON.parse(storedImages) : [];

        if (images.length === 0) {
          alert('Please upload at least one image first');
          return;
        }

        // Use base64 fallback
        console.log(`🎨 Opening processor with base64 for Pet ${i} (offline mode)`);
        openProcessorModal(images[0].data, i);
      });
    }
  }

  // Get pet name from input field
  function getPetName(petIndex) {
    const nameInput = document.querySelector(`[data-pet-name-input="${petIndex}"]`);
    if (nameInput && nameInput.value.trim()) {
      return nameInput.value.trim();
    }
    return `Pet ${petIndex}`; // Fallback name if not provided
  }

  // Create and show processor modal
  function openProcessorModal(imageDataUrl, petIndex) {
    // NEW: Try inline modal first (Phase 1 Integration)
    if (window.inlinePreview && typeof window.inlinePreview.openWithData === 'function') {
      console.log(`🎨 Opening inline preview modal for Pet ${petIndex}`);
      const petName = getPetName(petIndex);
      const gcsUrl = localStorage.getItem(`pet_${petIndex}_image_url`);
      const isGcsUrl = imageDataUrl.startsWith('https://storage.googleapis.com');

      window.inlinePreview.openWithData({
        petNumber: petIndex,
        petName: petName,
        imageUrl: isGcsUrl ? imageDataUrl : gcsUrl || imageDataUrl,
        isGcsUrl: isGcsUrl || !!gcsUrl
      });
      return;
    }

    // FALLBACK: Original processor page navigation
    console.log(`🎨 Inline preview not available, using processor page for Pet ${petIndex}`);

    // Image data already stored in localStorage by file upload handler (line 1273)
    // Store return URL and scroll position for back navigation
    sessionStorage.setItem('pet_selector_return_url', window.location.href);
    sessionStorage.setItem('pet_selector_scroll_position', window.scrollY.toString());

    // Store which pet index user clicked Preview on (for multiple pet handling)
    sessionStorage.setItem('pet_selector_active_index', petIndex.toString());

    // Navigate to processor page - it will read from localStorage automatically
    window.location.href = '/pages/custom-image-processing#processor';
  }

  // === STATE PERSISTENCE MODULE ===
  // Saves and restores pet selector state across page navigation

  /**
   * Get current product ID from container
   */
  function getProductId() {
    // Try to get from URL first
    const urlMatch = window.location.pathname.match(/\/products\/[^\/]+/);
    if (urlMatch) {
      // Use URL as product identifier (more reliable than dataset)
      return urlMatch[0];
    }
    // Fallback to timestamp-based key (per-session)
    return 'current';
  }

  /**
   * Collect current pet selector state
   * @returns {Object} Serializable state object
   */
  function collectPetSelectorState() {
    const productId = getProductId();

    // Get current pet count
    const selectedCountRadio = container.querySelector('[data-pet-count-radio]:checked');
    const petCount = selectedCountRadio ? parseInt(selectedCountRadio.value) : 0;

    // Collect per-pet data
    const pets = {};
    for (let i = 1; i <= 3; i++) {
      const nameInput = container.querySelector(`[data-pet-name-input="${i}"]`);

      if (nameInput) {
        pets[i] = {
          name: nameInput.value.trim(),
          fileCount: (petFiles[i] || []).length
        };
      }
    }

    // Get global selections
    const selectedStyle = container.querySelector('[data-style-radio]:checked');
    const selectedFont = container.querySelector('[data-font-radio]:checked');

    return {
      productId: productId,
      timestamp: Date.now(),
      petCount: petCount,
      pets: pets,
      style: selectedStyle ? selectedStyle.value : '',
      font: selectedFont ? selectedFont.value : ''
    };
  }

  let saveStateTimer;

  /**
   * Save pet selector state to localStorage (debounced)
   */
  function savePetSelectorState() {
    clearTimeout(saveStateTimer);

    saveStateTimer = setTimeout(() => {
      try {
        const state = collectPetSelectorState();
        const key = `perkie_pet_selector_${state.productId}`;

        localStorage.setItem(key, JSON.stringify(state));
        console.log('💾 Saved pet selector state');
      } catch (error) {
        console.error('❌ Failed to save state:', error);

        if (error.name === 'QuotaExceededError') {
          cleanupOldPetSelectorStates();
        }
      }
    }, 300); // 300ms debounce
  }

  /**
   * Save state immediately (no debounce)
   */
  function savePetSelectorStateImmediate() {
    try {
      const state = collectPetSelectorState();
      const key = `perkie_pet_selector_${state.productId}`;

      localStorage.setItem(key, JSON.stringify(state));
      console.log('💾 Saved pet selector state (immediate)');
    } catch (error) {
      console.error('❌ Failed to save state:', error);
    }
  }

  /**
   * Clean up old pet selector states (7+ days old)
   */
  function cleanupOldPetSelectorStates() {
    try {
      const keys = Object.keys(localStorage);
      const petSelectorKeys = keys.filter(k => k.startsWith('perkie_pet_selector_'));
      const MAX_AGE = 7 * 24 * 60 * 60 * 1000; // 7 days

      petSelectorKeys.forEach(key => {
        try {
          const state = JSON.parse(localStorage.getItem(key));
          const age = Date.now() - (state.timestamp || 0);

          if (age > MAX_AGE) {
            localStorage.removeItem(key);
            console.log('🧹 Cleaned up old state:', key);
          }
        } catch (e) {
          localStorage.removeItem(key);
        }
      });
    } catch (error) {
      console.error('❌ Cleanup failed:', error);
    }
  }

  /**
   * Load pet selector state from localStorage
   * @returns {Object|null} State object or null if not found/invalid
   */
  function loadPetSelectorState() {
    try {
      const productId = getProductId();
      const key = `perkie_pet_selector_${productId}`;
      const stored = localStorage.getItem(key);

      if (!stored) {
        console.log('🔍 No saved state found');
        return null;
      }

      const state = JSON.parse(stored);

      // Check expiration (24 hours)
      const age = Date.now() - (state.timestamp || 0);
      const MAX_AGE = 24 * 60 * 60 * 1000;

      if (age > MAX_AGE) {
        console.log('⏰ State expired, clearing');
        localStorage.removeItem(key);
        return null;
      }

      // Validate structure
      if (!state || typeof state.petCount !== 'number' || !state.pets) {
        console.warn('⚠️ Invalid state structure');
        localStorage.removeItem(key);
        return null;
      }

      console.log('✅ Loaded valid state');
      return state;

    } catch (error) {
      console.error('❌ Failed to load state:', error);
      return null;
    }
  }

  /**
   * Apply state to UI elements
   * @param {Object} state - State object to apply
   */
  function applyStateToUI(state) {
    try {
      console.log('🔄 Restoring pet selector state...');

      // 1. Restore pet count
      if (state.petCount > 0) {
        const countRadio = container.querySelector(`[data-pet-count-radio][value="${state.petCount}"]`);
        if (countRadio) {
          countRadio.checked = true;
          updatePetSections(state.petCount);
        }
      }

      // 2. Restore per-pet data
      for (const [index, pet] of Object.entries(state.pets)) {
        const i = parseInt(index);

        // Restore name
        const nameInput = container.querySelector(`[data-pet-name-input="${i}"]`);
        if (nameInput && pet.name) {
          nameInput.value = pet.name;
        }

        // Restore upload zone state
        if (pet.fileCount > 0) {
          const uploadZone = container.querySelector(`[data-upload-zone="${i}"]`);
          const uploadText = container.querySelector(`[data-upload-text="${i}"]`);
          const fileInput = container.querySelector(`[data-pet-file-input="${i}"]`);

          if (uploadZone && fileInput) {
            uploadText.textContent = 'CHANGE IMAGE?';
            uploadZone.classList.add('has-files');

            // Restore from file metadata (single file only)
            const storedMetadata = localStorage.getItem(`pet_${i}_file_metadata`);
            if (storedMetadata) {
              try {
                const fileMetadata = JSON.parse(storedMetadata);

                // Single file only - get first file from metadata
                if (fileMetadata.length > 0) {
                  petFiles[i] = [{
                    name: fileMetadata[0].name,
                    size: fileMetadata[0].size,
                    type: fileMetadata[0].type
                  }];

                  // Display single file in UI
                  displayUploadedFiles(i, petFiles[i]);

                  console.log(`✅ Restored file for Pet ${i}: ${fileMetadata[0].name}`);
                }
              } catch (error) {
                console.error(`❌ Failed to restore file for Pet ${i}:`, error);
              }
            }
          }
        }
      }

      // 3. Restore style selection
      if (state.style) {
        const styleRadio = container.querySelector(`[data-style-radio][value="${state.style}"]`);
        if (styleRadio) {
          styleRadio.checked = true;

          const styleCard = styleRadio.closest('.style-card');
          if (styleCard) {
            container.querySelectorAll('.style-card').forEach(c => c.classList.remove('style-card--active'));
            styleCard.classList.add('style-card--active');
          }
        }
      }

      // 4. Restore font selection
      if (state.font) {
        const fontRadio = container.querySelector(`[data-font-radio][value="${state.font}"]`);
        if (fontRadio) {
          fontRadio.checked = true;

          const fontCard = fontRadio.closest('.font-card');
          if (fontCard) {
            container.querySelectorAll('.font-card').forEach(c => c.classList.remove('font-card--active'));
            fontCard.classList.add('font-card--active');
          }
        }
      }

      // 5. Update font previews and visibility
      updateFontPreviews();
      toggleStyleSection(); // Ensure style section visibility is correct after name restoration
      toggleFontSection();  // Ensure font section visibility is correct after name restoration

      // 6. Check if user returned from processor
      const returnUrl = sessionStorage.getItem('pet_selector_return_url');
      if (returnUrl === window.location.href) {
        // Restore scroll position
        const scrollPos = parseInt(sessionStorage.getItem('pet_selector_scroll_position') || '0');
        setTimeout(() => window.scrollTo(0, scrollPos), 100);

        // Clear markers
        sessionStorage.removeItem('pet_selector_return_url');
        sessionStorage.removeItem('pet_selector_scroll_position');

        console.log('🔙 User returned from processor');
      }

      console.log('✅ State restoration complete');

      // Trigger Add to Cart validation after restoration
      // Without this, button stays disabled because programmatic value changes don't fire events
      if (window.CartPetIntegration && typeof window.CartPetIntegration.validateAndUpdateButton === 'function') {
        // Small delay to ensure all DOM updates are complete
        setTimeout(function() {
          window.CartPetIntegration.validateAndUpdateButton();
          console.log('🔄 Add to Cart validation triggered after restoration');
        }, 100);
      } else {
        console.warn('⚠️ CartPetIntegration not available for validation');
      }

    } catch (error) {
      console.error('❌ Failed to restore state:', error);
    }
  }

  /**
   * Restore state on page load
   */
  function restorePetSelectorState() {
    const state = loadPetSelectorState();
    if (state) {
      applyStateToUI(state);
    }
  }

  /**
   * PHASE 2: Restore product-scoped customization
   * Allows customers to return to same product and see their work
   * Now uses PetStorage v3 as primary source
   */
  function restoreProductScopedCustomization() {
    console.log('🔄 === RESTORE: Checking for pet data to restore ===');
    try {
      var form = document.querySelector('[data-product-form] form');
      if (!form) {
        console.log('[PetRestore] No form found, skipping');
        return;
      }

      // PRIMARY: Try PetStorage v3 (check for recent pet data)
      if (typeof PetStorage !== 'undefined' && PetStorage.getRecentPets) {
        console.log('[PetRestore] Checking PetStorage v3...');
        var recentPets = PetStorage.getRecentPets(1);

        if (recentPets && recentPets.length > 0) {
          var pet = recentPets[0];

          // Check if pet was processed in last 30 minutes
          var age = Date.now() - (pet.processedAt || 0);
          var ageMinutes = Math.round(age / 60000);
          console.log('[PetRestore] Found pet in v3, age:', ageMinutes, 'minutes');

          if (age < 30 * 60 * 1000) {
            console.log('✅ [PetRestore] Using recent pet from v3 storage:', {
              sessionKey: pet.sessionKey,
              name: pet.name,
              selectedEffect: pet.selectedEffect,
              originalGcsUrl: pet.originalGcsUrl ? '✅ present' : '❌ missing',
              effectsAvailable: pet.effects ? Object.keys(pet.effects).join(', ') : 'none'
            });
            populateFormFromPet(form, pet);
            return;
          } else {
            console.log('⚠️ [PetRestore] Pet too old (', ageMinutes, 'min), skipping v3');
          }
        } else {
          console.log('[PetRestore] No pets found in v3 storage');
        }
      } else {
        console.log('[PetRestore] PetStorage v3 not available');
      }

      // FALLBACK: Legacy petCustomization_product_ format
      var productId = window.productId || null;
      if (!productId) {
        console.log('[PetRestore] No product ID, skipping');
        return;
      }

      var storageKey = 'petCustomization_product_' + productId;
      var savedData = localStorage.getItem(storageKey);

      if (!savedData) {
        console.log('[PetRestore] No saved customization for product', productId);
        return;
      }

      var customization = JSON.parse(savedData);

      // Check timeout (10 minutes for legacy)
      var now = Date.now();
      if (now - customization.timestamp > 10 * 60 * 1000) {
        console.log('[PetRestore] Legacy customization expired, removing');
        localStorage.removeItem(storageKey);
        return;
      }

      console.log('[PetRestore] Restoring from legacy customization:', customization);

      // Session key
      var sessionKeyInput = form.querySelector('[name="properties[_pet_1_session_key]"]');
      if (sessionKeyInput) sessionKeyInput.value = customization.sessionKey || '';

      // Pet name
      var petNameInput = form.querySelector('[name="properties[Pet 1 Name]"]');
      if (petNameInput) petNameInput.value = customization.petName || '';

      // Artist notes
      var notesInput = form.querySelector('[name="properties[_pet_1_artist_notes]"]');
      if (notesInput) notesInput.value = customization.artistNotes || '';

      // Selected effect
      var effectInput = form.querySelector('[name="properties[_pet_1_selected_effect]"]');
      if (effectInput) effectInput.value = customization.selectedEffect || '';

      // Processed image URL
      var urlInput = form.querySelector('[name="properties[_pet_1_processed_image_url]"]');
      if (urlInput) urlInput.value = customization.processedImageUrl || '';

      // Original GCS URL
      var originalGcsInput = form.querySelector('[name="properties[_pet_1_original_gcs_url]"]');
      if (originalGcsInput) originalGcsInput.value = customization.originalGcsUrl || '';

      console.log('[PetRestore] Form fields restored from legacy customization');

    } catch (error) {
      console.error('[PetRestore] Error restoring customization:', error);
    }
  }

  /**
   * Populate form fields from PetStorage v3 pet data
   */
  function populateFormFromPet(form, pet) {
    if (!form || !pet) return;

    console.log('📝 === POPULATING FORM FROM V3 PET DATA ===');

    // Get processed image URL for selected effect
    var selectedEffect = pet.selectedEffect || 'enhancedblackwhite';
    var processedImageUrl = pet.effects ? (pet.effects[selectedEffect] || pet.thumbnailUrl) : '';

    var fieldsPopulated = {};

    // Session key
    var sessionKeyInput = form.querySelector('[name="properties[_pet_1_session_key]"]');
    if (sessionKeyInput) {
      sessionKeyInput.value = pet.sessionKey || '';
      fieldsPopulated['_pet_1_session_key'] = pet.sessionKey || '(empty)';
    }

    // Pet name
    var petNameInput = form.querySelector('[name="properties[Pet 1 Name]"]');
    if (petNameInput) {
      petNameInput.value = pet.name || '';
      fieldsPopulated['Pet 1 Name'] = pet.name || '(empty)';
    }

    // Artist notes
    var notesInput = form.querySelector('[name="properties[_pet_1_artist_notes]"]');
    if (notesInput) {
      notesInput.value = pet.artistNote || '';
      fieldsPopulated['_pet_1_artist_notes'] = pet.artistNote ? pet.artistNote.substring(0, 50) + '...' : '(empty)';
    }

    // Selected effect
    var effectInput = form.querySelector('[name="properties[_pet_1_selected_effect]"]');
    if (effectInput) {
      effectInput.value = selectedEffect;
      fieldsPopulated['_pet_1_selected_effect'] = selectedEffect;
    }

    // Processed image URL
    var urlInput = form.querySelector('[name="properties[_pet_1_processed_image_url]"]');
    if (urlInput) {
      urlInput.value = processedImageUrl;
      fieldsPopulated['_pet_1_processed_image_url'] = processedImageUrl ? '✅ ' + processedImageUrl.substring(0, 60) + '...' : '❌ missing';
    }

    // Original GCS URL
    var originalGcsInput = form.querySelector('[name="properties[_pet_1_original_gcs_url]"]');
    if (originalGcsInput) {
      originalGcsInput.value = pet.originalGcsUrl || '';
      fieldsPopulated['_pet_1_original_gcs_url'] = pet.originalGcsUrl ? '✅ ' + pet.originalGcsUrl.substring(0, 60) + '...' : '❌ missing';
    }

    // Previous order number (for reorders)
    var previousOrderInput = form.querySelector('[name="properties[_pet_1_previous_order_number]"]');
    if (previousOrderInput) {
      previousOrderInput.value = pet.previousOrderNumber || '';
      fieldsPopulated['_pet_1_previous_order_number'] = pet.previousOrderNumber || '(none - new upload)';
    }

    console.log('📋 Form Fields Populated:');
    console.table(fieldsPopulated);
    console.log('📝 === END FORM POPULATION ===');
  }

  // === END STATE PERSISTENCE MODULE ===

  // === SELECTED STYLE URL POPULATION MODULE ===
  // NEW: Populate selected style URLs and filenames before form submission

  /**
   * Sanitize filename to prevent path traversal and XSS attacks
   * @param {string} filename - Original filename
   * @returns {string} Sanitized filename
   */
  function sanitizeFilename(filename) {
    if (!filename) return '';

    // Remove path separators (prevent path traversal)
    filename = filename.replace(/[\/\\]/g, '');

    // Remove special characters that could cause issues (keep alphanumeric, dots, dashes, underscores)
    filename = filename.replace(/[^a-zA-Z0-9._-]/g, '_');

    // Limit length to prevent issues
    filename = filename.slice(0, 100);

    return filename;
  }

  /**
   * Validate that URL is a valid GCS URL
   * @param {string} url - URL to validate
   * @returns {boolean} True if valid GCS URL
   */
  function isValidGCSUrl(url) {
    if (!url || typeof url !== 'string') return false;

    // Must be HTTPS
    if (!url.startsWith('https://')) return false;

    try {
      const urlObj = new URL(url);
      // Must be from Google Cloud Storage domain
      return urlObj.hostname === 'storage.googleapis.com' ||
             urlObj.hostname.endsWith('.storage.googleapis.com');
    } catch (e) {
      return false;
    }
  }

  /**
   * Get N latest processed pets from localStorage (within last 10 minutes)
   * @param {number} count - Number of pets to retrieve (1-3)
   * @returns {Array<Object>} Array of pet data objects (newest first)
   */
  function getLatestProcessedPets(count = 1) {
    try {
      const allPets = PetStorage.getAll();

      // Filter: Must have effects, must be recent
      const recentPets = Object.values(allPets)
        .filter(pet => {
          // Must have processed effects
          if (!pet.effects || Object.keys(pet.effects).length === 0) {
            return false;
          }

          // Must have timestamp
          if (!pet.timestamp) {
            return false;
          }

          // Must be within last 10 minutes
          const age = Date.now() - pet.timestamp;
          if (age > 10 * 60 * 1000) {
            return false;
          }

          return true;
        })
        .sort((a, b) => b.timestamp - a.timestamp); // Sort by timestamp, newest first

      const result = recentPets.slice(0, count);

      if (result.length > 0) {
        console.log(`✅ Found ${result.length} recent processed pet(s)`);
      } else {
        console.log('ℹ️ No recent processed pets found (within 10 minutes)');
      }

      return result;

    } catch (error) {
      console.error('❌ Failed to get latest pets:', error);
      return [];
    }
  }

  /**
   * Clean up stale pets (older than 60 minutes) to prevent localStorage bloat
   */
  function cleanupStalePets() {
    try {
      const allPets = PetStorage.getAll();
      let removed = 0;

      Object.keys(allPets).forEach(petId => {
        const pet = allPets[petId];
        if (pet.timestamp) {
          const age = Date.now() - pet.timestamp;

          // Remove pets older than 60 minutes
          if (age > 60 * 60 * 1000) {
            PetStorage.delete(petId);
            removed++;
          }
        }
      });

      if (removed > 0) {
        console.log(`🗑️ Cleaned up ${removed} stale pet(s) from localStorage`);
      }
    } catch (error) {
      console.error('Failed to cleanup stale pets:', error);
    }
  }

  /**
   * Populate selected style URLs and filenames before form submission
   * Reads selected style from radio button and fetches corresponding GCS URL from localStorage
   * @returns {boolean} True if successful, false if missing data
   */
  function populateSelectedStyleUrls() {
    console.log('🔍 Populating selected style URLs for order...');

    // Get selected style (global selection)
    const selectedStyleRadio = container.querySelector('[data-style-radio]:checked');
    if (!selectedStyleRadio) {
      console.warn('⚠️ No style selected - skipping style URL population');
      return false; // Validation should catch this
    }

    // Use data-style-radio attribute to get effect key (e.g., "enhancedblackwhite")
    // NOT value which contains display name (e.g., "Black & White")
    const selectedStyle = selectedStyleRadio.getAttribute('data-style-radio') || selectedStyleRadio.dataset.styleRadio;
    console.log(`✅ Selected style (effect key): ${selectedStyle}`);

    // Get active pet count
    const selectedCountRadio = container.querySelector('[data-pet-count-radio]:checked');
    if (!selectedCountRadio) {
      console.warn('⚠️ No pet count selected - skipping');
      return false;
    }

    const petCount = parseInt(selectedCountRadio.value);
    console.log(`✅ Active pets: ${petCount}`);

    // PRIORITY 1: Check Session Gallery data FIRST (pets selected from library)
    // Session Gallery stores pets with originalUrl that may be older than the 10-min TTL
    const sessionGalleryPets = [];
    for (let i = 1; i <= petCount; i++) {
      const sessionData = sessionStorage.getItem(`session_gallery_pet_${i}`);
      if (sessionData) {
        try {
          const petData = JSON.parse(sessionData);
          if (petData && petData.effects && Object.keys(petData.effects).length > 0) {
            sessionGalleryPets.push({
              ...petData,
              petNumber: petData.petNumber || i
            });
            console.log(`📚 Found Session Gallery pet for slot ${i}:`, {
              name: petData.name || 'unnamed',
              hasOriginalUrl: !!petData.originalUrl,
              effects: Object.keys(petData.effects).join(', ')
            });
          }
        } catch (e) {
          console.warn(`Failed to parse session gallery pet ${i}:`, e);
        }
      }
    }

    // PRIORITY 2: Fall back to latest processed pets (from PetStorage with 10-min TTL)
    const latestPetsFromStorage = getLatestProcessedPets(petCount);

    // Merge: Use Session Gallery data where available, fill gaps with latest processed
    let latestPets = [];
    for (let i = 1; i <= petCount; i++) {
      // Check Session Gallery first for this slot
      const sessionPet = sessionGalleryPets.find(p => p.petNumber === i);
      if (sessionPet) {
        latestPets.push(sessionPet);
        console.log(`✅ Using Session Gallery pet for slot ${i}`);
      } else {
        // Fall back to latest processed pet for this slot
        const storagePet = latestPetsFromStorage.find(p => p.petNumber === i);
        if (storagePet) {
          latestPets.push(storagePet);
          console.log(`✅ Using PetStorage pet for slot ${i}`);
        }
      }
    }

    if (latestPets.length > 0) {
      console.log(`🎨 Populating from ${latestPets.length} processed pet(s)`);

      // Populate each available processed pet
      for (let i = 0; i < latestPets.length; i++) {
        const pet = latestPets[i];
        // Use actual pet slot number from storage, NOT array index
        // This ensures Pet 2's data goes to _pet_2_* fields even if sorted by timestamp
        const petNumber = pet.petNumber || (i + 1);
        console.log(`🎯 Processing pet "${pet.name || 'unnamed'}" → slot ${petNumber} (array index ${i})`);

        // CRITICAL FIX: Only populate artist notes if they exist for THIS SPECIFIC PET
        // Do NOT carry over notes from other pets in PetStorage
        const artistNotesField = document.querySelector(`[data-artist-notes="${petNumber}"]`);
        if (artistNotesField) {
          // Check if this specific pet has artist notes
          if (pet.artistNote && pet.artistNote.trim() !== '') {
            // SECURITY: Enhanced sanitization (prevent XSS, limit length)
            const sanitizedNotes = pet.artistNote
              .substring(0, 200) // Limit to 200 chars
              .replace(/<[^>]*>/g, '') // Strip HTML tags
              .replace(/&lt;/g, '') // Remove encoded tags
              .replace(/&gt;/g, '')
              .replace(/javascript:/gi, '') // Remove javascript: protocol
              .replace(/on\w+=/gi, '') // Remove event handlers (onclick=, onload=, etc)
              .replace(/[\u0000-\u001F\u007F-\u009F]/g, '') // Remove control characters
              .trim();

            artistNotesField.value = sanitizedNotes;
            console.log(`✅ Artist notes from processed Pet ${petNumber}: "${sanitizedNotes.substring(0, 50)}${sanitizedNotes.length > 50 ? '...' : ''}"`);
          } else {
            // CRITICAL FIX: If pet has no artist notes, explicitly clear the field
            // This prevents carryover from previous products
            artistNotesField.value = '';
            console.log(`ℹ️ Pet ${petNumber} has no artist notes - field cleared`);
          }
        }

        // Populate processed URL for selected style
        const urlField = document.querySelector(`[data-pet-processed-url="${petNumber}"]`);
        if (urlField) {
          if (pet.effects && pet.effects[selectedStyle]) {
            const styleData = pet.effects[selectedStyle];
            // V3 FORMAT FIX: Handle both string URLs (v3) and object format (legacy)
            let gcsUrl;
            if (typeof styleData === 'string') {
              gcsUrl = styleData;  // V3 format: direct URL string
            } else {
              gcsUrl = styleData.gcsUrl || styleData.dataUrl || '';  // Legacy object format
            }

            if (gcsUrl) {
              // SECURITY: Validate URL before populating (prevent URL injection)
              if (isValidGCSUrl(gcsUrl)) {
                urlField.value = gcsUrl;
                console.log(`✅ Pet ${petNumber} processed URL [${selectedStyle}]: ${gcsUrl.substring(0, 60)}...`);
              } else {
                console.error(`❌ Invalid GCS URL for Pet ${petNumber}, skipping: ${gcsUrl.substring(0, 60)}...`);
              }
            }
          } else {
            // CRITICAL FIX: If pet has no processed effects, explicitly clear the field
            // This prevents carryover of processed URLs from other pets
            urlField.value = '';
            console.log(`ℹ️ Pet ${petNumber} has no processed effects for style "${selectedStyle}" - URL field cleared`);
          }
        }

        // Extract original filename from processed pet data (if available)
        const filenameField = document.querySelector(`[data-pet-filename="${petNumber}"]`);
        if (filenameField) {
          if (pet.filename && pet.filename.trim() !== '') {
            const sanitizedFilename = sanitizeFilename(pet.filename);
            filenameField.value = sanitizedFilename;
            console.log(`✅ Pet ${petNumber} filename from processor: ${sanitizedFilename}`);
          } else {
            // CRITICAL FIX: If pet has no filename, explicitly clear the field
            // This prevents carryover of filenames from other pets
            filenameField.value = '';
            console.log(`ℹ️ Pet ${petNumber} has no filename - field cleared`);
          }
        }

        // Populate original GCS URL for fulfillment (stores original uploaded image)
        const originalUrlField = document.querySelector(`[data-pet-original-gcs-url="${petNumber}"]`);
        if (originalUrlField) {
          if (pet.originalUrl && pet.originalUrl.trim() !== '') {
            // SECURITY: Validate URL before populating
            if (isValidGCSUrl(pet.originalUrl)) {
              originalUrlField.value = pet.originalUrl;
              console.log(`✅ Pet ${petNumber} original GCS URL: ${pet.originalUrl.substring(0, 60)}...`);
            } else {
              console.error(`❌ Invalid original GCS URL for Pet ${petNumber}, skipping`);
              originalUrlField.value = '';
            }
          } else {
            // Clear if no original URL available
            originalUrlField.value = '';
            console.log(`ℹ️ Pet ${petNumber} has no original GCS URL - field cleared`);
          }
        }

        // Populate session key for this pet
        const sessionKeyField = document.querySelector(`[data-pet-session-key="${petNumber}"]`);
        if (sessionKeyField) {
          sessionKeyField.value = pet.sessionKey || '';
          console.log(`✅ Pet ${petNumber} session key: ${pet.sessionKey || 'none'}`);
        }

        // Populate selected effect for this pet
        const selectedEffectField = document.querySelector(`[data-pet-selected-effect="${petNumber}"]`);
        if (selectedEffectField) {
          selectedEffectField.value = selectedStyle || 'enhancedblackwhite';
          console.log(`✅ Pet ${petNumber} selected effect: ${selectedStyle}`);
        }
      }

      // If user selected MORE pets than processed, remaining pets will use product page uploads
      if (latestPets.length < petCount) {
        console.log(`ℹ️ ${petCount - latestPets.length} pet(s) will use product page uploads`);
      }

      console.log('✅ Order properties populated from processed pets');
      return true;
    }

    // FALLBACK: No recent processed pets, use name-based lookup
    console.log('⚠️ No recent processed pets, trying name-based lookup');

    // For each active pet, populate processed URL and filename (EXISTING FALLBACK LOGIC)
    for (let i = 1; i <= petCount; i++) {
      // Get pet name to construct localStorage key
      const petNameInput = container.querySelector(`[data-pet-name-input="${i}"]`);
      const petName = petNameInput ? petNameInput.value.trim() : '';

      if (!petName) {
        console.warn(`⚠️ Pet ${i} has no name - skipping URL population`);
        continue;
      }

      // Construct localStorage key (matches pet-storage.js pattern: perkie_pet_{name})
      const storageKey = `perkie_pet_${petName.toLowerCase().replace(/\s+/g, '_')}`;
      const storedData = localStorage.getItem(storageKey);

      if (!storedData) {
        console.warn(`⚠️ No localStorage data found for pet ${i} (${petName}) - key: ${storageKey}`);
        continue;
      }

      let petData;
      try {
        petData = JSON.parse(storedData);
      } catch (e) {
        console.error(`❌ Failed to parse localStorage data for pet ${i}:`, e);
        continue;
      }

      // Extract selected style URL
      if (petData.effects && petData.effects[selectedStyle]) {
        const styleData = petData.effects[selectedStyle];
        const styleUrl = styleData.gcsUrl || styleData.dataUrl || '';

        if (styleUrl) {
          // SECURITY: Validate URL before populating (prevent URL injection)
          if (isValidGCSUrl(styleUrl)) {
            const urlField = document.querySelector(`[data-pet-processed-url="${i}"]`);
            if (urlField) {
              urlField.value = styleUrl;
              console.log(`✅ Pet ${i} processed URL set: ${styleUrl.substring(0, 60)}...`);
            }
          } else {
            console.error(`❌ Invalid GCS URL for Pet ${i}, skipping: ${styleUrl.substring(0, 60)}...`);
          }
        } else {
          console.warn(`⚠️ Pet ${i} style "${selectedStyle}" has no URL`);
        }
      } else {
        console.warn(`⚠️ Pet ${i} missing effect data for style "${selectedStyle}"`);
      }

      // Extract original filename from file input (NEW FUNCTIONALITY)
      const fileInput = container.querySelector(`[data-pet-file-input="${i}"]`);
      if (fileInput && fileInput.files && fileInput.files.length > 0) {
        const originalFilename = fileInput.files[0].name;

        // SECURITY: Sanitize filename before storing (prevent path traversal and XSS)
        const sanitizedFilename = sanitizeFilename(originalFilename);

        const filenameField = document.querySelector(`[data-pet-filename="${i}"]`);
        if (filenameField) {
          filenameField.value = sanitizedFilename;
          console.log(`✅ Pet ${i} filename set: ${sanitizedFilename} (original: ${originalFilename})`);
        }
      }

      // Extract artist notes from petData (per-pet fields)
      if (petData.artistNote) {
        const artistNotesField = document.querySelector(`[data-artist-notes="${i}"]`);
        if (artistNotesField) {
          // SECURITY: Sanitize artist notes (prevent XSS, limit length)
          const sanitizedNotes = petData.artistNote
            .substring(0, 200) // Limit to 200 chars
            .replace(/<[^>]*>/g, '') // Strip HTML tags
            .trim();

          artistNotesField.value = sanitizedNotes;
          console.log(`✅ Pet ${i} artist notes set: "${sanitizedNotes.substring(0, 50)}${sanitizedNotes.length > 50 ? '...' : ''}"`);
        }
      }
    }

    return true; // Success
  }

  // === END SELECTED STYLE URL POPULATION MODULE ===

  // Initialize - No default selections
  // User must actively select pet count, style, and font
  // Pet sections remain hidden until count is selected

  // CRITICAL: Setup form submission handler to populate hidden fields before submit
  // With HTML5 form attribute, inputs are automatically associated with form
  // We only need to populate values from localStorage before submission

  function setupFormSubmitHandler() {
    // Find the product form using explicit ID selector (more reliable)
    const form = document.getElementById('{{ product_form_id }}');
    if (!form) {
      console.warn('⚠️ Pet Selector: Form not found yet, will retry after DOM loads');
      return false;
    }

    console.log('✅ Pet Selector: Form handler attached to', form.getAttribute('id'));

    form.addEventListener('submit', function(e) {
      // Populate selected style URLs and filenames from localStorage before submission
      // No pre-clearing needed - Layer 1 prevents carryover after cart success
      populateSelectedStyleUrls();

      // Note: File inputs and all other inputs are now associated with form via
      // HTML5 form attribute - no need to move them manually!

      // === CART DATA VERIFICATION LOGGING ===
      console.log('🛒 === CART SUBMISSION - PET DATA VERIFICATION ===');

      // Collect all pet properties being submitted
      var petProperties = {};
      var allInputs = form.querySelectorAll('input[name^="properties["]');
      allInputs.forEach(function(input) {
        var name = input.name;
        var value = input.value;
        // Only log pet-related properties
        if (name.indexOf('pet') !== -1 || name.indexOf('Pet') !== -1 ||
            name.indexOf('artist') !== -1 || name.indexOf('Style') !== -1) {
          petProperties[name] = value ? (value.length > 100 ? value.substring(0, 100) + '...' : value) : '(empty)';
        }
      });

      console.log('📋 Pet Properties Being Submitted:');
      console.table(petProperties);

      // Summary check for critical fields (only those required for fulfillment)
      // Note: _session_key, _artist_notes, _previous_order_number are optional
      var criticalFields = [
        'properties[Pet 1 Name]',
        'properties[_pet_1_selected_effect]',
        'properties[_pet_1_processed_image_url]',
        'properties[_pet_1_original_gcs_url]'
      ];

      var missingFields = [];
      criticalFields.forEach(function(fieldName) {
        var input = form.querySelector('[name="' + fieldName + '"]');
        if (!input || !input.value) {
          missingFields.push(fieldName);
        }
      });

      if (missingFields.length > 0) {
        console.warn('⚠️ Missing/Empty Critical Fields:', missingFields);
      } else {
        console.log('✅ All critical pet fields populated');
      }

      console.log('🛒 === END CART SUBMISSION VERIFICATION ===');
    });

    return true;
  }

  // Try immediately (form might already exist)
  if (!setupFormSubmitHandler()) {
    // If form doesn't exist yet, wait for DOM to be fully loaded
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setupFormSubmitHandler);
    } else {
      // DOM already loaded, try one more time after a short delay
      setTimeout(setupFormSubmitHandler, 100);
    }
  }

  // === BRIDGE V3 EVENT LISTENER ===
  // Listen for petBridgeApplied event from main-product.liquid bridge
  window.addEventListener('petBridgeApplied', function(event) {
    var detail = event.detail;
    if (!detail) return;

    console.log('🌉 === BRIDGE V3 - PET DATA RECEIVED ===');
    console.log('📦 Bridge Data:', {
      petNumber: detail.petNumber,
      sessionKey: detail.sessionKey,
      name: detail.name,
      artistNote: detail.artistNote ? detail.artistNote.substring(0, 50) + '...' : '(none)',
      selectedEffect: detail.selectedEffect,
      processedImageUrl: detail.processedImageUrl ? '✅ ' + detail.processedImageUrl.substring(0, 60) + '...' : '❌ missing',
      originalGcsUrl: detail.originalGcsUrl ? '✅ ' + detail.originalGcsUrl.substring(0, 60) + '...' : '❌ missing',
      previousOrderNumber: detail.previousOrderNumber || '(none - new upload)'
    });

    var form = document.querySelector('[data-product-form] form');
    if (!form) {
      console.warn('[PetSelector] No product form found');
      return;
    }

    // Populate form fields directly from v3 pet data
    var fieldsPopulated = [];

    // Session key
    var sessionKeyInput = form.querySelector('[name="properties[_pet_1_session_key]"]');
    if (sessionKeyInput) {
      sessionKeyInput.value = detail.sessionKey || '';
      fieldsPopulated.push('_pet_1_session_key');
    }

    // Pet name (visible to customer)
    var petNameInput = form.querySelector('[name="properties[Pet 1 Name]"]');
    if (petNameInput) {
      petNameInput.value = detail.name || '';
      fieldsPopulated.push('Pet 1 Name');
    }

    // Artist notes
    var notesInput = form.querySelector('[name="properties[_pet_1_artist_notes]"]');
    if (notesInput) {
      notesInput.value = detail.artistNote || '';
      fieldsPopulated.push('_pet_1_artist_notes');
    }

    // Selected effect
    var effectInput = form.querySelector('[name="properties[_pet_1_selected_effect]"]');
    if (effectInput) {
      effectInput.value = detail.selectedEffect || 'enhancedblackwhite';
      fieldsPopulated.push('_pet_1_selected_effect');
    }

    // Processed image URL
    var urlInput = form.querySelector('[name="properties[_pet_1_processed_image_url]"]');
    if (urlInput) {
      urlInput.value = detail.processedImageUrl || '';
      fieldsPopulated.push('_pet_1_processed_image_url');
    }

    // Original GCS URL (for fulfillment)
    var originalGcsInput = form.querySelector('[name="properties[_pet_1_original_gcs_url]"]');
    if (originalGcsInput) {
      originalGcsInput.value = detail.originalGcsUrl || '';
      fieldsPopulated.push('_pet_1_original_gcs_url');
    }

    // Previous order number (for reorders)
    var previousOrderInput = form.querySelector('[name="properties[_pet_1_previous_order_number]"]');
    if (previousOrderInput) {
      previousOrderInput.value = detail.previousOrderNumber || '';
      fieldsPopulated.push('_pet_1_previous_order_number');
    }

    console.log('✅ Form Fields Populated:', fieldsPopulated.join(', '));
    console.log('🌉 === END BRIDGE V3 ===');
  });

  // === RESTORE STATE ON PAGE LOAD ===
  // Wait for DOM to be fully ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      // LAYER 2: Clear stale pet property fields from previous products
      if (window.PetPropertyUtils) {
        window.PetPropertyUtils.clearFieldsWithTelemetry(null, 'page_load');
      }

      cleanupStalePets(); // Clean up before restoring
      restoreProductScopedCustomization(); // Phase 2: Restore if same product
      restorePetSelectorState();
      toggleStyleSection(); // Set initial style section visibility
    });
  } else {
    // LAYER 2: Clear stale pet property fields from previous products
    if (window.PetPropertyUtils) {
      window.PetPropertyUtils.clearFieldsWithTelemetry(null, 'page_load');
    }

    cleanupStalePets(); // Clean up before restoring
    restoreProductScopedCustomization(); // Phase 2: Restore if same product
    restorePetSelectorState();
    toggleStyleSection(); // Set initial style section visibility
  }

  // Also handle pageshow (for mobile back/forward cache)
  window.addEventListener('pageshow', (e) => {
    if (e.persisted) {
      console.log('📄 Page loaded from cache, reloading state...');

      // LAYER 3: Clear stale pet property fields on bfcache restore
      if (window.PetPropertyUtils) {
        window.PetPropertyUtils.clearFieldsWithTelemetry(null, 'bfcache');
      }

      cleanupStalePets(); // Clean up before restoring
      restoreProductScopedCustomization(); // Phase 2: Restore if same product
      restorePetSelectorState();
      toggleStyleSection(); // Update style section visibility
    }
  });
})();
</script>

{% endif %}
